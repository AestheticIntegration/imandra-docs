<!DOCTYPE html>
<html>
    <head>
	  <meta charset="utf-8">
	  <meta http-equiv="x-ua-compatible" content="ie=edge">
	  <meta name="viewport" content="width=device-width, initial-scale=1">

	  <title>Region Decomposition</title>
	  
	  <link rel="shortcut icon" type="image/x-icon" href="/imandra-docs/favicon.ico">
	  <link rel="stylesheet" href="/imandra-docs/css/main.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:300,300i,400,400i%7CMerriweather:300,300i,400,400i%7CRoboto+Slab:300,300i,400,400i">

	  <link rel="canonical" href="https://docs.imandra.ai//imandra-docs/regionDecomposition/">
	  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.1/jquery.min.js"></script>
	  <script type="text/javascript" src = "/imandra-docs/jekyll-resources/assets/scripts/jquery.scrollme.min.js"></script>
	  <script type="text/javascript" src = "/imandra-docs/jekyll-resources/assets/scripts/jquery.sticky.min.js"></script>
	  <script type="text/javascript">
	  	 
		$(document).ready(function(){
			$("#StickMenu").sticky({topSpacing:52});
		});

	  </script>

</head> 


    <body>
	      <div class="TopRowContainer">
	<div class="TopRow">
		<div class="TopNavLogoContainer">
			<a class="TopNavLogoLink" href="https://docs.imandra.ai/">
				<img class="TopNavLogo" src = "/imandra-docs/jekyll-resources/assets/img/imandra_doc_logo_main.svg">
			</a>
		</div>
		<nav class="TopNavContainer">
			<ul class="TopNavList">
				
				 
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/configuration/">Configuration</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/examples/">Examples</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/hacking/">Hacking</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink TopNavLink__Active" href="/imandra-docs/regionDecomposition/">Region Decomposition</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/extra/">Further functionality</a></li>
				
				
				
			</ul>
		</nav>
	</div>
</div>

<header class="TemplateHeader">
	<div class="TemplateHeaderImageContainer">
	<a href ="/imandra-docs">
		<img class="SiteSpecificImage" src="/imandra-docs/assets/img/site_specific_image_v_2.svg">
	</a>
	</div>
</header>


	      <main class="MainContentColumn">
		        <article class="ArticleContainer">
			          <!-- Sidebar -->
<div class="SideMenuContainer">
    <div id="StickMenu" class="SideMenu">
        
        
        
        
        <A href=#>Region Decompositions</A>
        
        
        
        <A href=#regionPrinters>Region Printers</A>
        
        
        
        <A href=#advancedTechniques>Advanced Techniques</A>
        
        
        
    </div>
</div>
<!--MainContent-->
<div class="MainContent">
    
    
    
    <h2 id=regionDecomposition>Region Decompositions</h2>
    
    <p>Imandra has a first-class notion of state-space decompositions which we call principal region decompositions. These allow one to compute a symbolic representation of the possible unique behaviours of a program subject to a given query constraint.</p>

<p>For example: “Compute all regions of the venue state-space in which the price of the next trade will be the venue’s reference price,” or “Compute all regions of the state-space that will cause the venue to transition into volatility auction.”</p>

<p>These region descriptions are subject to a given basis, a collection of functions whose definitions will not be expanded and may carry lemmata exposing facts about their behaviour. We compute these decompositions through a special form of symbolic execution. Decompositions play a key role in how we generate certified documentation and high-coverage test suites. We often represent them as interactive hierarchical voronoi diagrams.</p>

    
    
    <h2 class="internalLink-padding" id=regionPrinters>Region Printers</h2>
    
    <p>Custom region printers may be defined in <code class="highlighter-rouge">:program</code> mode using the <code class="highlighter-rouge">Reflect</code> API.</p>

<p>A region printer is a function that maps a <code class="highlighter-rouge">Reflect.Region.t</code> value to a <code class="highlighter-rouge">string</code>.</p>

<p>Let us first see the definition of the datatype <code class="highlighter-rouge">Reflect.Region.t</code>. We’ll use the <code class="highlighter-rouge">module X = Foo</code> trick which causes Imandra to display the signature of the module <code class="highlighter-rouge">Foo</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :program
&gt; module R = Reflect.Region;;
module R :
  sig
    type t =
      Reflect.Region.t = {
        name : string;
        depth : int;
        constraints : Reflect.Expr.t list;
        invariant : Reflect.Expr.t option;
      }
    val install_printer : name:string -&gt; f:(t -&gt; string) -&gt; unit
  end
</code></pre></div></div>

<p>For region printers, the important part of the above signature is the record type <code class="highlighter-rouge">t</code>. A region printer will render a string for such a value.</p>

<p>Note that both the <code class="highlighter-rouge">constraints</code> and <code class="highlighter-rouge">invariant</code> fields contain <code class="highlighter-rouge">Reflect.Expr.t</code> values. This is a datatype of Imandra logical expressions. A region printer will typically analyze these <code class="highlighter-rouge">Reflect.Expr.t</code> values and display them in a domain-relevant manner.</p>

<p>Let us inspect the signature of <code class="highlighter-rouge">Reflect.Expr</code> below:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; module E = Reflect.Expr;;
module E :
  sig
    type name = string
    type t =
    Reflect.Expr.t =
      Fun of name * t list
      | Atom of name
      | Nil
      | True
      | False
      | And of t list
      | Or of t list
      | Not of t
      | Equal of t * t
      | Implies of t * t
      | If of t * t * t
      | Rec of name * (name * t) list
      | Rec_field of t * name
      | Target_fun of t list
      val pp : Format.formatter -&gt; t -&gt; unit
      val to_string : t -&gt; string
  end
</code></pre></div></div>

<h4 id="a-simple-example">A simple example</h4>

<p>Let us define a simple region printer, taking advantage of the <code class="highlighter-rouge">Reflect.Expr.to_string</code> function, which is a built-in default pretty-printer for <code class="highlighter-rouge">Reflect.Expr.t</code> values:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; let pp (x : Reflect.Region.t) =
let open Reflect in
  let open Reflect.Region in
  let open Printf in
  sprintf "---\\nname: %s\\nhyps:\\n[%s]\\ninv:\\n %s\\n---\\n%!"
    x.name
    (String.concat "," (List.map Expr.to_string x.constraints))
    (match x.invariant with
      Some i -&gt; Expr.to_string i
      | None   -&gt; "&lt;none&gt;")
  ;;
val pp : Reflect.Region.t -&gt; string = &lt;fun&gt;
</code></pre></div></div>

<h4 id="installation">Installation</h4>

<p>Region printers must be installed using the <code class="highlighter-rouge">Reflect.Region.install_printer</code> function.</p>

<ul>
  <li><code class="highlighter-rouge">Reflect.Region.install_printer : name:string -&gt; f:(Reflect.Region.t -&gt; string) -&gt; unit</code></li>
</ul>

<p>For example, to we can install our <code class="highlighter-rouge">pp</code> region printer as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Reflect.Region.install_printer ~name:\"ex_pp\" ~f:pp;;
- : unit = ()
</code></pre></div></div>

<h4 id="invocation">Invocation</h4>

<p>Once the printer is installed, we may use it in <code class="highlighter-rouge">:decompose</code> and <code class="highlighter-rouge">:testgen</code> invocations via the <code class="highlighter-rouge">region_printer</code> parameter.</p>

<p>As an example, let us define a simple arithmetic function <code class="highlighter-rouge">f</code> and decompose it, printing the results using our <code class="highlighter-rouge">pp</code> region printer. Recall that we’ve installed <code class="highlighter-rouge">pp</code> with the name <code class="highlighter-rouge">ex_pp</code>.</p>

<p>First, we switch to <code class="highlighter-rouge">:logic</code> mode and define our <code class="highlighter-rouge">f</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; :logic
# let f x =
  if x &gt; 10 then 99
  else 100;;
val f : int -&gt; int = &lt;fun&gt;
</code></pre></div></div>

<p>Now, we <code class="highlighter-rouge">:decompose</code> it and apply our region printer:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :decompose f region_printer ex_pp
----------------------------------------------------------------------------
 Beginning principal region decomposition for f
----------------------------------------------------------------------------
- Isolated region #1 (2, depth=1): --------------------

---
name: 2
hyps:
  [&gt;(x1, 10)]
  inv:
    Equal(99, F(x1))
---

- Isolated region #2 (1, depth=1): --------------------

---
name: 1
hyps:
  [&lt;=(x1, 10)]
inv:
  Equal(100, F(x1))
---

----------------------------------------------------------------------------
Finished principal region decomposition for f
Stats: {rounds=2; regions=2; time=0.038sec}
----------------------------------------------------------------------------
</code></pre></div></div>

<h4 id="a-more-sophisticated-example-using-json">A more sophisticated example using JSON</h4>

<p>Imandra infrastructure often expects region decompositions to be printed in JSON. This JSON printing of regions is done by default when one enters <code class="highlighter-rouge">:web</code> mode and uses Imandra’s default region printer. However, when a custom region printer is used, the type of string produced for the region is completely determined by the custom region printer itself. Thus, to work with other Imandra tools, it is likely you will need to write your region printers to output JSON.</p>

<p>Here is an example doing just that via the <code class="highlighter-rouge">Yojson</code> library. This widely used OCaml JSON library is included with Imandra, available for use out of the box.</p>

<p>Note the required JSON fields for Imandra region descriptions:</p>

<ul>
  <li><code class="highlighter-rouge">name : String</code> – The name of the region, e.g., <code class="highlighter-rouge">4.21.2</code></li>
  <li><code class="highlighter-rouge">vars : String List</code> – A list of variables (with their associated types) used in the region constraints. This is currently ignored in Imandra web interfaces (e.g., Imandra Regions Explorer / interactive voronoi).</li>
  <li><code class="highlighter-rouge">constraints : String List</code> – A list of strings representing the region constraints.</li>
  <li><code class="highlighter-rouge">invariant : String</code> – A single string representing the region invariant.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(* A simple region printer that produces JSON. *)
let pp_json (x : Reflect.Region.t) =
  let open Reflect in
  let open Reflect.Region in
  let open Yojson.Basic in
  let cs = List.map (fun c -&gt; `String (Expr.to_string c)) x.constraints in
  let i =
  match x.invariant with
    Some i -&gt; `String (Expr.to_string i)
    | None   -&gt; `String "&lt;none&gt;" in
    let j = `Assoc [ ("name", `String x.name)
    ; ("vars", `List [])
    ; ("constraints", `List cs)
    ; (\"invariant\", i) ]
    in
      (to_string j) ^ "\n\"\n;;
</code></pre></div></div>

<p>Once we’ve defined it, let’s install it. We’ll give it the name <code class="highlighter-rouge">ex_pp_json</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Reflect.Region.install_printer ~name:\"ex_pp_json\" ~f:pp_json;;
- : unit = ()
</code></pre></div></div>

<p>Finally, we may switch to <code class="highlighter-rouge">:logic</code> mode and apply it:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; :logic
# :decompose f region_printer ex_pp_json
----------------------------------------------------------------------------
  Beginning principal region decomposition for f
----------------------------------------------------------------------------
- Isolated region #1 (2, depth=1): --------------------

{"name": "2", "vars": [], "constraints": [&gt;(x1, 10)], "invariant": "Equal(99, F(x1))"}

- Isolated region #2 (1, depth=1): --------------------
{ "name" : "1", "vars" : [], "constraints": ["&lt;=(x1, 10)"], "invariant": "Equal(100, F(x1))"}

----------------------------------------------------------------------------
Finished principal region decomposition for f\nStats: {rounds=2; regions=2; time=0.018sec}
----------------------------------------------------------------------------

</code></pre></div></div>

    
    
    <h2 class="internalLink-padding" id=advancedTechniques>Advanced Techniques</h2>
    
    <p>[block:api-header]
{
  “title”: “Staged Symbolic Execution”
}
[/block]
‘Staging’ is an advanced feature that uses ‘staged symbolic execution’ to incrementally unroll top-level recursive functions during region decompositions. This is useful when you wish to analyse the effect of a sequence of ‘events’ (i.e., a sequence of instructions or messages) on a state vector.</p>

<p>Here’s a simple example. Notice how we ‘stage’ the top-level recursive <code class="highlighter-rouge">run</code> function. Notice also how the <em>shape</em> of the program we’re analysing is given, but we allow it to have symbolic parameters. We then ask Imandra to symbolically execute the program from a starting initial state, and using an <code class="highlighter-rouge">assuming</code> statement we ask Imandra to solve for the regions where a property holds (in this case, where the <code class="highlighter-rouge">x</code> value of the state vector is non-negative).</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type state = { x : int };;
type msg = Add of int
  | Sub of int
  | Replace of int
;;

let step (s, m) =
  match m with
    Add n -&gt; {s with x = s.x + n}
    | Sub n -&gt; {s with x = s.x - n}
    | Replace n -&gt; {s with x = n}
;;

let rec run (s, ms) =
  match ms with
    [] -&gt; s
    | m :: ms -&gt;
      let s' = step (s, m) in
        run (s', ms)
;;

let init_state = { x = 0 };;
let run_example (n1,n2,n3,n4,n5) =
  run (init_state, [Add n1;
                    Sub n2;
                    Replace n3;
                    Add n4;
                    Sub n5])
;;

let run_example_gt_0 (n1,n2,n3,n4,n5) =
  (run_example (n1,n2,n3,n4,n5)).x &gt; 0
;;

:stage run
:decompose run_example assuming run_example_gt_0

</code></pre></div></div>

<p>And here is the result:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :decompose run_example assuming run_example_gt_0
----------------------------------------------------------------------------
Beginning principal region decomposition for run_example
----------------------------------------------------------------------------
- Assuming predicate run_example_gt_0 for all regions.
- Isolated region #1 (Goal 1, depth=1): --------------------

Name: Goal 1

Vars: {x1 : int; x2 : int; x3 : int; x4 : int; x5 : int}

Constraints:\n [ (x3 + x4 + (-x5)) &gt; 0 ]

Invariant:\n { x = (x3 + x4 + (-x5)) } = F(x1, x2, x3, x4, x5).

----------------------------------------------------------------------------
Finished principal region decomposition for run_example s.t. run_example_gt_0
Stats: {rounds=2; regions=1; time=0.083sec}
----------------------------------------------------------------------------

</code></pre></div></div>

    
    
</div>
		        </article>
	      </main>
	      <footer class="Footer">
	  <a class="Copyrights"href="http://imandra.ai">&#9400; 2018 Aesthetic Integration Ltd. All rights reserved.</a>
</footer>

    </body>

</html>
