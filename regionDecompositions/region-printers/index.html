<p>Custom region printers may be defined in <code class="highlighter-rouge">:program</code> mode using the <code class="highlighter-rouge">Reflect</code> API.</p>

<p>A region printer is a function that maps a <code class="highlighter-rouge">Reflect.Region.t</code> value to a <code class="highlighter-rouge">string</code>.</p>

<p>Let us first see the definition of the datatype <code class="highlighter-rouge">Reflect.Region.t</code>. We’ll use the <code class="highlighter-rouge">module X = Foo</code> trick which causes Imandra to display the signature of the module <code class="highlighter-rouge">Foo</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :program
&gt; module R = Reflect.Region;;
module R :
  sig
    type t =
      Reflect.Region.t = {
        name : string;
        depth : int;
        constraints : Reflect.Expr.t list;
        invariant : Reflect.Expr.t option;
      }
    val install_printer : name:string -&gt; f:(t -&gt; string) -&gt; unit
  end
</code></pre></div></div>

<p>For region printers, the important part of the above signature is the record type <code class="highlighter-rouge">t</code>. A region printer will render a string for such a value.</p>

<p>Note that both the <code class="highlighter-rouge">constraints</code> and <code class="highlighter-rouge">invariant</code> fields contain <code class="highlighter-rouge">Reflect.Expr.t</code> values. This is a datatype of Imandra logical expressions. A region printer will typically analyze these <code class="highlighter-rouge">Reflect.Expr.t</code> values and display them in a domain-relevant manner.</p>

<p>Let us inspect the signature of <code class="highlighter-rouge">Reflect.Expr</code> below:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; module E = Reflect.Expr;;
module E :
  sig
    type name = string
    type t =
    Reflect.Expr.t =
      Fun of name * t list
      | Atom of name
      | Nil
      | True
      | False
      | And of t list
      | Or of t list
      | Not of t
      | Equal of t * t
      | Implies of t * t
      | If of t * t * t
      | Rec of name * (name * t) list
      | Rec_field of t * name
      | Target_fun of t list
      val pp : Format.formatter -&gt; t -&gt; unit
      val to_string : t -&gt; string
  end
</code></pre></div></div>

<h4 id="a-simple-example">A simple example</h4>

<p>Let us define a simple region printer, taking advantage of the <code class="highlighter-rouge">Reflect.Expr.to_string</code> function, which is a built-in default pretty-printer for <code class="highlighter-rouge">Reflect.Expr.t</code> values:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; let pp (x : Reflect.Region.t) =
let open Reflect in
  let open Reflect.Region in
  let open Printf in
  sprintf "---\\nname: %s\\nhyps:\\n[%s]\\ninv:\\n %s\\n---\\n%!"
    x.name
    (String.concat "," (List.map Expr.to_string x.constraints))
    (match x.invariant with
      Some i -&gt; Expr.to_string i
      | None   -&gt; "&lt;none&gt;")
  ;;
val pp : Reflect.Region.t -&gt; string = &lt;fun&gt;
</code></pre></div></div>

<h4 id="installation">Installation</h4>

<p>Region printers must be installed using the <code class="highlighter-rouge">Reflect.Region.install_printer</code> function.</p>

<ul>
  <li><code class="highlighter-rouge">Reflect.Region.install_printer : name:string -&gt; f:(Reflect.Region.t -&gt; string) -&gt; unit</code></li>
</ul>

<p>For example, to we can install our <code class="highlighter-rouge">pp</code> region printer as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Reflect.Region.install_printer ~name:\"ex_pp\" ~f:pp;;
- : unit = ()
</code></pre></div></div>

<h4 id="invocation">Invocation</h4>

<p>Once the printer is installed, we may use it in <code class="highlighter-rouge">:decompose</code> and <code class="highlighter-rouge">:testgen</code> invocations via the <code class="highlighter-rouge">region_printer</code> parameter.</p>

<p>As an example, let us define a simple arithmetic function <code class="highlighter-rouge">f</code> and decompose it, printing the results using our <code class="highlighter-rouge">pp</code> region printer. Recall that we’ve installed <code class="highlighter-rouge">pp</code> with the name <code class="highlighter-rouge">ex_pp</code>.</p>

<p>First, we switch to <code class="highlighter-rouge">:logic</code> mode and define our <code class="highlighter-rouge">f</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; :logic
# let f x =
  if x &gt; 10 then 99
  else 100;;
val f : int -&gt; int = &lt;fun&gt;
</code></pre></div></div>

<p>Now, we <code class="highlighter-rouge">:decompose</code> it and apply our region printer:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :decompose f region_printer ex_pp
----------------------------------------------------------------------------
 Beginning principal region decomposition for f
----------------------------------------------------------------------------
- Isolated region #1 (2, depth=1): --------------------

---
name: 2
hyps:
  [&gt;(x1, 10)]
  inv:
    Equal(99, F(x1))
---

- Isolated region #2 (1, depth=1): --------------------

---
name: 1
hyps:
  [&lt;=(x1, 10)]
inv:
  Equal(100, F(x1))
---

----------------------------------------------------------------------------
Finished principal region decomposition for f
Stats: {rounds=2; regions=2; time=0.038sec}
----------------------------------------------------------------------------
</code></pre></div></div>

<h4 id="a-more-sophisticated-example-using-json">A more sophisticated example using JSON</h4>

<p>Imandra infrastructure often expects region decompositions to be printed in JSON. This JSON printing of regions is done by default when one enters <code class="highlighter-rouge">:web</code> mode and uses Imandra’s default region printer. However, when a custom region printer is used, the type of string produced for the region is completely determined by the custom region printer itself. Thus, to work with other Imandra tools, it is likely you will need to write your region printers to output JSON.</p>

<p>Here is an example doing just that via the <code class="highlighter-rouge">Yojson</code> library. This widely used OCaml JSON library is included with Imandra, available for use out of the box.</p>

<p>Note the required JSON fields for Imandra region descriptions:</p>

<ul>
  <li><code class="highlighter-rouge">name : String</code> – The name of the region, e.g., <code class="highlighter-rouge">4.21.2</code></li>
  <li><code class="highlighter-rouge">vars : String List</code> – A list of variables (with their associated types) used in the region constraints. This is currently ignored in Imandra web interfaces (e.g., Imandra Regions Explorer / interactive voronoi).</li>
  <li><code class="highlighter-rouge">constraints : String List</code> – A list of strings representing the region constraints.</li>
  <li><code class="highlighter-rouge">invariant : String</code> – A single string representing the region invariant.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(* A simple region printer that produces JSON. *)
let pp_json (x : Reflect.Region.t) =
  let open Reflect in
  let open Reflect.Region in
  let open Yojson.Basic in
  let cs = List.map (fun c -&gt; `String (Expr.to_string c)) x.constraints in
  let i =
  match x.invariant with
    Some i -&gt; `String (Expr.to_string i)
    | None   -&gt; `String "&lt;none&gt;" in
    let j = `Assoc [ ("name", `String x.name)
    ; ("vars", `List [])
    ; ("constraints", `List cs)
    ; (\"invariant\", i) ]
    in
      (to_string j) ^ "\n\"\n;;
</code></pre></div></div>

<p>Once we’ve defined it, let’s install it. We’ll give it the name <code class="highlighter-rouge">ex_pp_json</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Reflect.Region.install_printer ~name:\"ex_pp_json\" ~f:pp_json;;
- : unit = ()
</code></pre></div></div>

<p>Finally, we may switch to <code class="highlighter-rouge">:logic</code> mode and apply it:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; :logic
# :decompose f region_printer ex_pp_json
----------------------------------------------------------------------------
  Beginning principal region decomposition for f
----------------------------------------------------------------------------
- Isolated region #1 (2, depth=1): --------------------

{"name": "2", "vars": [], "constraints": [&gt;(x1, 10)], "invariant": "Equal(99, F(x1))"}

- Isolated region #2 (1, depth=1): --------------------
{ "name" : "1", "vars" : [], "constraints": ["&lt;=(x1, 10)"], "invariant": "Equal(100, F(x1))"}

----------------------------------------------------------------------------
Finished principal region decomposition for f\nStats: {rounds=2; regions=2; time=0.018sec}
----------------------------------------------------------------------------

</code></pre></div></div>
