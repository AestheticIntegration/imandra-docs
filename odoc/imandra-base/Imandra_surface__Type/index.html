<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Imandra_surface__Type (imandra-base.Imandra_surface__Type)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">imandra-base</a> &#x00BB; Imandra_surface__Type</nav><h1>Module <code>Imandra_surface__Type</code></h1><h2 id="imandra/pure-type-definitions"><a href="#imandra/pure-type-definitions" class="anchor"></a>Imandra/Pure type definitions</h2><nav class="toc"><ul><li><a href="#unification">Unification</a></li><li><a href="#basic-predicates-for-built-in-types">Basic predicates for built-in types</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-t.Var" class="anchored"><td class="def constructor"><a href="#type-t.Var" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Var</span><span class="keyword"> of </span><a href="index.html#type-var">var</a></code></td></tr><tr id="type-t.Arrow" class="anchored"><td class="def constructor"><a href="#type-t.Arrow" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Arrow</span><span class="keyword"> of </span>string<span class="keyword"> * </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Tuple" class="anchored"><td class="def constructor"><a href="#type-t.Tuple" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Tuple</span><span class="keyword"> of </span><a href="index.html#type-t">t</a> list</code></td></tr><tr id="type-t.Constr" class="anchored"><td class="def constructor"><a href="#type-t.Constr" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Constr</span><span class="keyword"> of </span><a href="index.html#type-def">def</a><span class="keyword"> * </span><a href="index.html#type-t">t</a> list</code></td></tr></table></dt><dd><p>A general type expression for Imandra</p></dd></dl><dl><dt class="spec type" id="type-var"><a href="#type-var" class="anchor"></a><code><span class="keyword">and </span>var</code><code><span class="keyword"> = </span><a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a></code></dt><dd><p>Variable, including <code>'a</code></p></dd></dl><dl><dt class="spec type" id="type-decl"><a href="#type-decl" class="anchor"></a><code><span class="keyword">and </span>decl</code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-decl.Algebraic" class="anchored"><td class="def constructor"><a href="#type-decl.Algebraic" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Algebraic</span><span class="keyword"> of </span><a href="index.html#type-adt_row">adt_row</a> list</code></td></tr><tr id="type-decl.Record" class="anchored"><td class="def constructor"><a href="#type-decl.Record" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Record</span><span class="keyword"> of </span><a href="index.html#type-rec_row">rec_row</a> list</code></td></tr><tr id="type-decl.Alias" class="anchored"><td class="def constructor"><a href="#type-decl.Alias" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Alias</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-decl.target" class="anchored"><td class="def field"><a href="#type-decl.target" class="anchor"></a><code>target : <a href="index.html#type-t">t</a>;</code></td></tr></table><code>}</code></td></tr><tr id="type-decl.Skolem" class="anchored"><td class="def constructor"><a href="#type-decl.Skolem" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Skolem</span></code></td></tr><tr id="type-decl.Builtin" class="anchored"><td class="def constructor"><a href="#type-decl.Builtin" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Builtin</span><span class="keyword"> of </span><a href="../Imandra_surface/Builtin/Ty/index.html#type-t">Imandra_surface.Builtin.Ty.t</a></code></td></tr><tr id="type-decl.Other" class="anchored"><td class="def constructor"><a href="#type-decl.Other" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Other</span></code></td></tr></table></dt><dd><p>Definition of a named type</p></dd></dl><dl><dt class="spec type" id="type-adt_row"><a href="#type-adt_row" class="anchor"></a><code><span class="keyword">and </span>adt_row</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-adt_row.c" class="anchored"><td class="def field"><a href="#type-adt_row.c" class="anchor"></a><code>c : <a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a>;</code></td></tr><tr id="type-adt_row.labels" class="anchored"><td class="def field"><a href="#type-adt_row.labels" class="anchor"></a><code>labels : <a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a> list option;</code></td></tr><tr id="type-adt_row.args" class="anchored"><td class="def field"><a href="#type-adt_row.args" class="anchor"></a><code>args : <a href="index.html#type-t">t</a> list;</code></td></tr></table><code>}</code></dt><dd><p>List of constructors for an algebraic type</p></dd></dl><dl><dt class="spec type" id="type-rec_row"><a href="#type-rec_row" class="anchor"></a><code><span class="keyword">and </span>rec_row</code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-rec_row.f" class="anchored"><td class="def field"><a href="#type-rec_row.f" class="anchor"></a><code>f : <a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a>;</code></td></tr><tr id="type-rec_row.ty" class="anchored"><td class="def field"><a href="#type-rec_row.ty" class="anchor"></a><code>ty : <a href="index.html#type-t">t</a>;</code></td></tr></table><code>}</code></dt><dd><p>List of record fields</p></dd></dl><dl><dt class="spec type" id="type-def"><a href="#type-def" class="anchor"></a><code><span class="keyword">and </span>def</code><code><span class="keyword"> = </span><span class="keyword">private </span></code><code>{</code><table class="record"><tr id="type-def.params" class="anchored"><td class="def field"><a href="#type-def.params" class="anchor"></a><code>params : <a href="index.html#type-var">var</a> list;</code></td></tr><tr id="type-def.name" class="anchored"><td class="def field"><a href="#type-def.name" class="anchor"></a><code>name : <a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a>;</code></td></tr><tr id="type-def.loc" class="anchored"><td class="def field"><a href="#type-def.loc" class="anchor"></a><code>loc : <a href="../Imandra_util/Iloc/index.html#type-t">Imandra_util.Iloc.t</a>;</code></td></tr><tr id="type-def.decl" class="anchored"><td class="def field"><a href="#type-def.decl" class="anchor"></a><code>decl : <a href="index.html#type-decl">decl</a> lazy_t;</code></td></tr><tr id="type-def.clique" class="anchored"><td class="def field"><a href="#type-def.clique" class="anchor"></a><code>clique : <a href="../Imandra_surface__Uid/index.html#module-Set">Imandra_surface.Uid.Set</a>.t;</code></td></tr><tr id="type-def.doc" class="anchored"><td class="def field"><a href="#type-def.doc" class="anchor"></a><code>doc : <a href="../Imandra_surface/Document/index.html#type-t">Imandra_surface.Document.t</a> option;</code></td></tr><tr id="type-def.validated" class="anchored"><td class="def field"><a href="#type-def.validated" class="anchor"></a><code><span class="keyword">mutable </span>validated : float option;</code></td></tr></table><code>}</code></dt><dd><p>A type definition, parametrized by some type variables</p></dd></dl><dl><dt class="spec value" id="val-chash"><a href="#val-chash" class="anchor"></a><code><span class="keyword">val </span>chash : ?&#8288;local:<a href="../Imandra_surface/Uid/Chash_map/index.html#type-t">Imandra_surface.Uid.Chash_map.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="../Imandra_util/Chash/index.html#type-hasher">Imandra_util.Chash.hasher</a></code></dt><dd><p>hash type structurally</p></dd></dl><dl><dt class="spec value" id="val-mk_def"><a href="#val-mk_def" class="anchor"></a><code><span class="keyword">val </span>mk_def : ?&#8288;no_validate:bool <span>&#45;&gt;</span> ?&#8288;loc:<a href="../Imandra_util/Iloc/index.html#type-t">Imandra_util.Iloc.t</a> <span>&#45;&gt;</span> ?&#8288;doc:<a href="../Imandra_surface/Document/index.html#type-t">Imandra_surface.Document.t</a> <span>&#45;&gt;</span> ?&#8288;clique:<a href="../Imandra_surface__Uid/index.html#module-Set">Imandra_surface.Uid.Set</a>.t <span>&#45;&gt;</span> name:<a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a> <span>&#45;&gt;</span> params:<a href="index.html#type-var">var</a> list <span>&#45;&gt;</span> <a href="index.html#type-decl">decl</a> lazy_t <span>&#45;&gt;</span> <a href="index.html#type-def">def</a></code></dt></dl><div class="spec module" id="module-Var"><a href="#module-Var" class="anchor"></a><code><span class="keyword">module </span><a href="Var/index.html">Var</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Type equality</p></dd></dl><dl><dt class="spec value" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span class="keyword">val </span>hash : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Hash type</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-print"><a href="#val-print" class="anchor"></a><code><span class="keyword">val </span>print : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-to_doc"><a href="#val-to_doc" class="anchor"></a><code><span class="keyword">val </span>to_doc : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Imandra_surface/Document/index.html#type-t">Imandra_surface.Document.t</a></code></dt></dl><aside><p>Printers that output valid OCaml types</p></aside><dl><dt class="spec type" id="type-printer"><a href="#type-printer" class="anchor"></a><code><span class="keyword">type </span>'a printer</code><code><span class="keyword"> = </span><span class="type-var">'a</span> CCFormat.printer</code></dt></dl><dl><dt class="spec value" id="val-print_as_ocaml_with"><a href="#val-print_as_ocaml_with" class="anchor"></a><code><span class="keyword">val </span>print_as_ocaml_with : <a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a> <a href="index.html#type-printer">printer</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <a href="index.html#type-printer">printer</a></code></dt><dt class="spec value" id="val-to_string_as_ocaml"><a href="#val-to_string_as_ocaml" class="anchor"></a><code><span class="keyword">val </span>to_string_as_ocaml : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-print_as_ocaml"><a href="#val-print_as_ocaml" class="anchor"></a><code><span class="keyword">val </span>print_as_ocaml : <a href="index.html#type-t">t</a> <a href="index.html#type-printer">printer</a></code></dt><dt class="spec value" id="val-print_def_as_ocaml"><a href="#val-print_def_as_ocaml" class="anchor"></a><code><span class="keyword">val </span>print_def_as_ocaml : id:<a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a> <a href="index.html#type-printer">printer</a> <span>&#45;&gt;</span> ty:<a href="index.html#type-t">t</a> <a href="index.html#type-printer">printer</a> <span>&#45;&gt;</span> <a href="index.html#type-def">def</a> <a href="index.html#type-printer">printer</a></code></dt><dt class="spec value" id="val-string_of_def"><a href="#val-string_of_def" class="anchor"></a><code><span class="keyword">val </span>string_of_def : <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-print_def"><a href="#val-print_def" class="anchor"></a><code><span class="keyword">val </span>print_def : <a href="index.html#type-def">def</a> <a href="index.html#type-printer">printer</a></code></dt><dt class="spec value" id="val-def_to_doc"><a href="#val-def_to_doc" class="anchor"></a><code><span class="keyword">val </span>def_to_doc : <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> <a href="../Imandra_surface/Document/index.html#type-t">Imandra_surface.Document.t</a></code></dt><dt class="spec value" id="val-documentation"><a href="#val-documentation" class="anchor"></a><code><span class="keyword">val </span>documentation : <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> <a href="../Imandra_surface/Document/index.html#type-t">Imandra_surface.Document.t</a> option</code></dt><dt class="spec value" id="val-validated"><a href="#val-validated" class="anchor"></a><code><span class="keyword">val </span>validated : <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-print_defs"><a href="#val-print_defs" class="anchor"></a><code><span class="keyword">val </span>print_defs : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-def">def</a> list <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-print_defs_as_ocaml"><a href="#val-print_defs_as_ocaml" class="anchor"></a><code><span class="keyword">val </span>print_defs_as_ocaml : id:<a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a> <a href="index.html#type-printer">printer</a> <span>&#45;&gt;</span> ty:<a href="index.html#type-t">t</a> <a href="index.html#type-printer">printer</a> <span>&#45;&gt;</span> <a href="index.html#type-def">def</a> list <a href="index.html#type-printer">printer</a></code></dt><dt class="spec value" id="val-print_clique"><a href="#val-print_clique" class="anchor"></a><code><span class="keyword">val </span>print_clique : <a href="../Imandra_surface__Uid/index.html#module-Set">Imandra_surface.Uid.Set</a>.t CCFormat.printer</code></dt><dt class="spec value" id="val-in_out_types"><a href="#val-in_out_types" class="anchor"></a><code><span class="keyword">val </span>in_out_types : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></dt><dd><p>Open the toplevel function types</p></dd></dl><dl><dt class="spec value" id="val-n_args"><a href="#val-n_args" class="anchor"></a><code><span class="keyword">val </span>n_args : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Number of arguments for a function type</p></dd></dl><dl><dt class="spec value" id="val-make_other"><a href="#val-make_other" class="anchor"></a><code><span class="keyword">val </span>make_other : <a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a> <span>&#45;&gt;</span> <a href="index.html#type-def">def</a></code></dt><dd><p>Undefined type</p></dd></dl><dl><dt class="spec value" id="val-returns"><a href="#val-returns" class="anchor"></a><code><span class="keyword">val </span>returns : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Return type of a function (same as <code>snd (in_out_types ty)</code>)</p></dd></dl><dl><dt class="spec value" id="val-drop_n_args"><a href="#val-drop_n_args" class="anchor"></a><code><span class="keyword">val </span>drop_n_args : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Assuming the type has at least <code>n</code> arguments, remove the n first. Normally one should have <code>drop_n_args (n_args ty) = returns ty</code></p></dd></dl><dl><dt class="spec value" id="val-is_param"><a href="#val-is_param" class="anchor"></a><code><span class="keyword">val </span>is_param : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Parametric type (higher order, or polymorphic)?</p></dd></dl><dl><dt class="spec type" id="type-subst"><a href="#type-subst" class="anchor"></a><code><span class="keyword">type </span>subst</code><code><span class="keyword"> = </span><a href="index.html#type-t">t</a> <a href="../Imandra_surface__Uid/index.html#module-Map">Var.Map</a>.t</code></dt><dd><p>Substitution: a binding from variables to types</p></dd></dl><dl><dt class="spec value" id="val-empty_subst"><a href="#val-empty_subst" class="anchor"></a><code><span class="keyword">val </span>empty_subst : <a href="index.html#type-subst">subst</a></code></dt><dt class="spec value" id="val-apply_subst"><a href="#val-apply_subst" class="anchor"></a><code><span class="keyword">val </span>apply_subst : ?&#8288;rec_:bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply substitution</p><dl><dt>parameter rec_</dt><dd><p>if true (default), substitute in RHS of substitution too.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-apply_subst'"><a href="#val-apply_subst'" class="anchor"></a><code><span class="keyword">val </span>apply_subst' : ?&#8288;rec_:bool <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-print_subst"><a href="#val-print_subst" class="anchor"></a><code><span class="keyword">val </span>print_subst : Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-string_of_subst"><a href="#val-string_of_subst" class="anchor"></a><code><span class="keyword">val </span>string_of_subst : <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-free_vars"><a href="#val-free_vars" class="anchor"></a><code><span class="keyword">val </span>free_vars : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Imandra_surface__Uid/index.html#module-Set">Var.Set</a>.t</code></dt><dd><p>Set of variables of the type</p></dd></dl><dl><dt class="spec value" id="val-free_vars_add"><a href="#val-free_vars_add" class="anchor"></a><code><span class="keyword">val </span>free_vars_add : <a href="../Imandra_surface__Uid/index.html#module-Set">Var.Set</a>.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Imandra_surface__Uid/index.html#module-Set">Var.Set</a>.t</code></dt><dd><p>add free vars of the type to this set</p></dd></dl><dl><dt class="spec value" id="val-is_ground"><a href="#val-is_ground" class="anchor"></a><code><span class="keyword">val </span>is_ground : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the type ground (i.e. without variables)?</p></dd></dl><dl><dt class="spec value" id="val-is_poly"><a href="#val-is_poly" class="anchor"></a><code><span class="keyword">val </span>is_poly : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the type non-ground (i.e. with some variables)?</p></dd></dl><dl><dt class="spec value" id="val-is_ground_def"><a href="#val-is_ground_def" class="anchor"></a><code><span class="keyword">val </span>is_ground_def : <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Is the definition parameter-free?</p></dd></dl><dl><dt class="spec value" id="val-name"><a href="#val-name" class="anchor"></a><code><span class="keyword">val </span>name : <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> <a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a></code></dt><dt class="spec value" id="val-mk_var"><a href="#val-mk_var" class="anchor"></a><code><span class="keyword">val </span>mk_var : <a href="Var/index.html#type-t">Var.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-mk_arrow_l"><a href="#val-mk_arrow_l" class="anchor"></a><code><span class="keyword">val </span>mk_arrow_l : <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-mk_skolem"><a href="#val-mk_skolem" class="anchor"></a><code><span class="keyword">val </span>mk_skolem : <a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Skolem type</p></dd></dl><dl><dt class="spec value" id="val-is_inline_record_cstor"><a href="#val-is_inline_record_cstor" class="anchor"></a><code><span class="keyword">val </span>is_inline_record_cstor : <a href="index.html#type-def">def</a> <span>&#45;&gt;</span> <a href="../Imandra_surface/Uid/index.html#type-t">Imandra_surface.Uid.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>is_inline_record_cstor def c</code> returns <code>true</code> if <code>c</code> is a constructor of <code>def</code> with an inline record</p></dd></dl><section><header><h3 id="unification"><a href="#unification" class="anchor"></a>Unification</h3></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val </span>iter : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit) <span>&#45;&gt;</span> unit</code></dt><dd><p>Iterate on immediate sub-types</p></dd></dl><dl><dt class="spec value" id="val-chase"><a href="#val-chase" class="anchor"></a><code><span class="keyword">val </span>chase : ?&#8288;subst:<a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>follow bound variables and aliases at the root of the type. The returned type is either an arrow, a non-bound variable or a non-alias Constr.</p></dd></dl><dl><dt class="spec value" id="val-chase_deep"><a href="#val-chase_deep" class="anchor"></a><code><span class="keyword">val </span>chase_deep : ?&#8288;subst:<a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Deep version of <a href="index.html#val-chase"><code>chase</code></a>, normalizing arguments recursively</p></dd></dl><dl><dt class="spec value" id="val-match_"><a href="#val-match_" class="anchor"></a><code><span class="keyword">val </span>match_ : ?&#8288;subst:<a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> option</code></dt><dd><p><code>match_ subst t1 t2</code> returns the most general substitution <code>sigma</code> that is an extension of <code>subst</code> such that <code>sigma(t1)</code> and <code>t2</code> equal.</p><dl><dt>raises Not_unifiable</dt><dd><p>if not such substitution exists</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-unify"><a href="#val-unify" class="anchor"></a><code><span class="keyword">val </span>unify : ?&#8288;subst:<a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> option</code></dt><dd><p><code>unify subst t1 t2</code> returns the most general substitution <code>sigma</code> that is an extension of <code>subst</code> such that <code>sigma(t1)</code> and <code>sigma(t2)</code> equal.</p><dl><dt>raises Not_unifiable</dt><dd><p>if not such substitution exists</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-alpha_equiv"><a href="#val-alpha_equiv" class="anchor"></a><code><span class="keyword">val </span>alpha_equiv : ?&#8288;subst:<a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> can_bind:(<a href="Var/index.html#type-t">Var.t</a> <span>&#45;&gt;</span> bool) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> option</code></dt><dd><p><code>alpha_equiv ~can_bind t1 t2</code> searchs for <code>sigma</code> where <code>sigma(t1) = t2</code> such that <code>sigma</code> only binds variables that satisfy <code>can_bind</code>. In practice, if <code>t1</code> and <code>t2</code> have disjoint variables and <code>can_bind</code> returns <code>true</code> only for variables of <code>t1</code>, then this checks for alpha-equivalence. NOTE: you need to apply <a href="index.html#val-is_renaming"><code>is_renaming</code></a> on the result</p><dl><dt>raises Not_unifiable</dt><dd><p>if not such substitution exists</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-is_renaming"><a href="#val-is_renaming" class="anchor"></a><code><span class="keyword">val </span>is_renaming : <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-apply_arrow_unify"><a href="#val-apply_arrow_unify" class="anchor"></a><code><span class="keyword">val </span>apply_arrow_unify : ?&#8288;subst:<a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> list <span>&#45;&gt;</span> (<a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-subst">subst</a>) option</code></dt><dd><p><code>apply_arrow_unify ty_f args</code> applies the function type <code>ty_f</code> to arguments, unifying types in the process. For example <code>apply_unify ('a -&gt; 'a) [(int-&gt;bool); int]</code> would return <code>bool</code></p><dl><dt>raises Unif_fail</dt><dd><p>if arities are wrong of it types do not match</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-same_base_type"><a href="#val-same_base_type" class="anchor"></a><code><span class="keyword">val </span>same_base_type : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Same head constructor?</p></dd></dl></section><section><header><h3 id="basic-predicates-for-built-in-types"><a href="#basic-predicates-for-built-in-types" class="anchor"></a>Basic predicates for built-in types</h3></header><dl><dt class="spec value" id="val-is_int"><a href="#val-is_int" class="anchor"></a><code><span class="keyword">val </span>is_int : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_real"><a href="#val-is_real" class="anchor"></a><code><span class="keyword">val </span>is_real : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_float"><a href="#val-is_float" class="anchor"></a><code><span class="keyword">val </span>is_float : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_bool"><a href="#val-is_bool" class="anchor"></a><code><span class="keyword">val </span>is_bool : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_arith"><a href="#val-is_arith" class="anchor"></a><code><span class="keyword">val </span>is_arith : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_list"><a href="#val-is_list" class="anchor"></a><code><span class="keyword">val </span>is_list : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_option"><a href="#val-is_option" class="anchor"></a><code><span class="keyword">val </span>is_option : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_arrow"><a href="#val-is_arrow" class="anchor"></a><code><span class="keyword">val </span>is_arrow : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val </span>int : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val </span>bool : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-real"><a href="#val-real" class="anchor"></a><code><span class="keyword">val </span>real : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-float"><a href="#val-float" class="anchor"></a><code><span class="keyword">val </span>float : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val </span>string : unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl><div class="spec module" id="module-Builtins"><a href="#module-Builtins" class="anchor"></a><code><span class="keyword">module </span><a href="Builtins/index.html">Builtins</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Tbl"><a href="#module-Tbl" class="anchor"></a><code><span class="keyword">module </span>Tbl : CCHashtbl.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Tbl">Tbl</a>.key<span class="keyword"> = </span><a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module </span>Map : CCMap.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Map">Map</a>.key<span class="keyword"> = </span><a href="index.html#type-t">t</a></code></div></section></div></body></html>