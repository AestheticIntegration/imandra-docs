<!DOCTYPE html>
<html>
    <head>
	  <meta charset="utf-8">
	  <meta http-equiv="x-ua-compatible" content="ie=edge">
	  <meta name="viewport" content="width=device-width, initial-scale=1">

	  <title>In more detail</title>
	  
	  <link rel="shortcut icon" type="image/x-icon" href="/imandra-docs/favicon.ico">
	  <link rel="stylesheet" href="/imandra-docs/css/main.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:300,300i,400,400i%7CMerriweather:300,300i,400,400i%7CRoboto+Slab:300,300i,400,400i">

	  <link rel="canonical" href="https://docs.imandra.ai//imandra-docs/theBasics/">
	  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.1/jquery.min.js"></script>
	  <script type="text/javascript" src = "/imandra-docs/jekyll-resources/assets/scripts/jquery.scrollme.min.js"></script>
	  <script type="text/javascript" src = "/imandra-docs/jekyll-resources/assets/scripts/jquery.sticky.min.js"></script>
	  <script type="text/javascript">
	  	 
		$(document).ready(function(){
			$("#StickMenu").sticky({topSpacing:52});
		});

	  </script>

</head> 


    <body>
	      <div class="TopRowContainer">
	<div class="TopRow">
		<div class="TopNavLogoContainer">
			<a class="TopNavLogoLink" href="https://docs.imandra.ai/">
				<img class="TopNavLogo" src = "/imandra-docs/jekyll-resources/assets/img/imandra_doc_logo_main.svg">
			</a>
		</div>
		<nav class="TopNavContainer">
			<ul class="TopNavList">
				
				 
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/configuration/">Configuration</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/examples/">Examples</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/hacking/">Hacking</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/regionDecomposition/">Region Decomposition</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink TopNavLink__Active" href="/imandra-docs/extra/">Further functionality</a></li>
				
				
				
			</ul>
		</nav>
	</div>
</div>

<header class="TemplateHeader">
	<div class="TemplateHeaderImageContainer">
	<a href ="/imandra-docs">
		<img class="SiteSpecificImage" src="/imandra-docs/assets/img/site_specific_image_v_2.svg">
	</a>
	</div>
</header>


	      <main class="MainContentColumn">
		        <article class="ArticleContainer">
			          <!-- Sidebar -->
<div class="SideMenuContainer">
    <div id="StickMenu" class="SideMenu">
        
        
        
        <a href="/imandra-docs/theBasics/">In more detail</a>
        
        <a href="/imandra-docs/pitfalls/">Avoiding Common Mistakes</a>
        
        <a href="/imandra-docs/environments/">Environments</a>
        
        <a href="/imandra-docs/dashingVGs/">Dashing VGs</a>
        
        
    </div>
</div>
<!--MainContent-->
<div class="MainContent">
    <h2>In more detail</h2>
    <p>In this section we’ll get up to speed on writing and experimenting with Imandra code.</p>

<h4 id="executing-iml-code">Executing IML code</h4>

<p>Use <code class="highlighter-rouge">;;</code> to indicate that you’ve finished entering each statement:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 1+1;;
- : int = 2
</code></pre></div></div>

<h4 id="comments">Comments</h4>

<p>IML comments are delimited by <code class="highlighter-rouge">(*</code> and <code class="highlighter-rouge">*)</code>, like this:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(* This is a single-line comment. *)
(* This is a
 * multi-line
 * comment.
 *)
</code></pre></div></div>

<p>The commenting convention is very similar to original C (<code class="highlighter-rouge">\* ... \*</code>). There is currently no single-line comment syntax (like <code class="highlighter-rouge"># ...</code> in Perl or <code class="highlighter-rouge">// ...</code> in C99/C++/Java).</p>

<p>IML counts nested <code class="highlighter-rouge">(* ... *)</code> blocks, and this allows you to comment out regions of code very easily:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(* This code is broken, we comment it out ...

(* Primality test. *)
let is_prime n =
(* note to self: ask about this on the mailing lists *) XXX;;

*)
</code></pre></div></div>

<h4 id="defining-functions">Defining functions</h4>

<p>Functions are defined with the <code class="highlighter-rouge">let</code> command. In Imandra, multi-argument functions must be given a tuple of arguments. This is normal for, e.g., C, Python and Java programmers, but may be strange at first from functional programmers used to writing curried higher-order functions.</p>

<p>When we define a function, Imandra responds telling us the type for the function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># let k(x,y,z) =
if x &gt; y then y else z + 1;;
val k : int * int * int -&gt; int = &lt;fun&gt;
</code></pre></div></div>
<p>In this case, we see that <code class="highlighter-rouge">k</code> maps a triple of integers to an integer.</p>

<p>Because Imandra is both a programming language and a mathematical logic, we must be careful about our definitions, to ensure that they do not introduce inconsistencies into the logic. Luckily, as users, we do not have to worry about this: Imandra checks our definitions to ensure that they do not introduce inconsistency. This does mean however that Imandra will stop us from doing certain things.</p>

<p>For example, once we’ve defined a function, we cannot redefine it in the same Imandra session (without explicitly enabling redefinition):</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># let k(x,y,z) = x + 1;;
Error: Name "k" is already in use.
Use :redef (with caution) to redefine named values.
</code></pre></div></div>
<p>Why is this restriction on redefinition important? Well, if we define a function, we can then prove theorems about it and other functions that depend on it. But if we then later redefine that function, those theorems we’ve proved (and are now available to Imandra’s reasoning engine) may now be false. Thus, redefinition can lead to inconsistency. It’s a useful tool to have while developing a formal model interactively, allowing you to experiment and fix mistakes in your designs. But, once your definitions are set, you should never enable redefinition during verification of your system.</p>

<p>To enable redefinition, use <code class="highlighter-rouge">:redef on</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># let f(x) = x+1;;
val f : int -&gt; int = &lt;fun&gt;
# let f(x) = x+2;;
Error: Name "f" is already in use.
Use :redef (with caution) to redefine named values.
# :redef on
# let f(x) = x+2;;
val f : int -&gt; int = &lt;fun&gt;
# f(3);;
- : int = 5
</code></pre></div></div>

<p>To define recursive functions, we use <code class="highlighter-rouge">let rec</code> instead of <code class="highlighter-rouge">let</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># let rec sum(x) =
if x &lt;= 0 then 0
else x + sum(x-1);;
val sum : int -&gt; int = &lt;fun&gt;
</code></pre></div></div>

<p>When we define recursive functions, Imandra must be able to prove that they terminate for all of their inputs. Why? Again, this connects to logical consistency. Consider what would happen if Imandra allowed us to define the following non-terminating function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># let rec f(x) = f(x) + 1;;
val f : 'a -&gt; int = &lt;fun&gt;
Error: Function f rejected by definitional principle.
</code></pre></div></div>

<p>Thankfully, Imandra will not allow this function to be defined. If it had, we could derive a falsehood by the following chain of reasoning: <code class="highlighter-rouge">f(0) = f(0) + 1</code>, so subtracting <code class="highlighter-rouge">f(0)</code> from both sides, we see <code class="highlighter-rouge">0=1</code>. That terminating recursive functions do not introduce inconsistency is a deep result of mathematical logic. This is part of Imandra’s “definitional principle.” The definitional principle guarantees that all functions (and types) admitted in Imandra extend Imandra’s logical theory in a consistent way (in technical terms, “every definitional extension of Imandra is a conservative extension.”)</p>

<p>In some cases, you may need to tell Imandra why a recursive function is terminating, by specifying a “termination measure.” We’ll go over this in due course.</p>

<h4 id="defining-types">Defining types</h4>

<p>Like OCaml, F# and Haskell, Imandra is a statically-typed language with type inference. Much of the power of the type system extends from the use of <em>algebraic datatypes</em> and <em>exhaustive pattern-matching</em>.</p>

<p>In languages like C, we’re used to enumerated types. These are the simplest form of algebraic datatypes:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># type color = Red | Green | Blue;;
type color = Red | Green | Blue
</code></pre></div></div>

<p>Notice that when we define a type in Imandra, it then prints the type definition back to us.</p>

<p>We call <code class="highlighter-rouge">Red</code>, <code class="highlighter-rouge">Green</code> and <code class="highlighter-rouge">Blue</code> the “constructors” for the type <code class="highlighter-rouge">color</code>. There is no way to be a value of type <code class="highlighter-rouge">color</code> other than being either <code class="highlighter-rouge">Red</code>, <code class="highlighter-rouge">Green</code> or <code class="highlighter-rouge">Blue</code>.</p>

<p>In fact, we can ask Imandra to prove this for us, by asking it to compute an instance of type <code class="highlighter-rouge">color</code> that is neither <code class="highlighter-rouge">Red</code> nor <code class="highlighter-rouge">Green</code> nor <code class="highlighter-rouge">Blue</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># instance _ (x : color) =
  not(x = Red || x = Green || x = Blue);;

No such instance exists.
</code></pre></div></div>

<p>With algebraic datatypes (ADTs), we can define functions using pattern-matching:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># let num_of_color x =
match x with
  Red   -&gt; 0
  | Green -&gt; 1
  | Blue  -&gt; 2
  ;;
val num_of_color : color -&gt; int = &lt;fun&gt;
</code></pre></div></div>

<p>In Imandra, pattern-matching must be exhaustive. For example, if we tried to define the above function but forgot the case for <code class="highlighter-rouge">Green</code>, we’d see the following error:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># let num_of_color_oops x =
  match x with
  Red -&gt; 0
  | Blue -&gt; 2
;;
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
  Green
Error: Pattern-matching must be exhaustive.
</code></pre></div></div>

<p>As part of its static typing, Imandra can always tell us whether or not our patterns are exhaustive.</p>

<p>We can use values of algebraic datatypes in searches for instances and counterexamples in the same way as any other value:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># instance _ x =
num_of_color x &lt;&gt; 2;;
Instance:

{ x = Green; }
</code></pre></div></div>

<p>Is <code class="highlighter-rouge">Green</code> the only such instance? Let’s ask:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># instance _ x =
  num_of_color x &lt;&gt; 2 &amp;&amp; x &lt;&gt; Green;;
Instance:
  { x = Red; }
</code></pre></div></div>

<p>Algebraic datatypes allow us to do much more than simple enumeration types. Crucially, every constructor in an ADT may itself take parameters:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># type cash = GBP of int | USD of int | Euro of int;;
type cash = GBP of int | USD of int | Euro of int
</code></pre></div></div>

<p>Some values of type <code class="highlighter-rouge">cash</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># GBP 10;;
- : cash = GBP 10
# USD 100;;
- : cash = USD 100
# Euro 50;;
- : cash = Euro 50
</code></pre></div></div>

<p>What happens if we try to add them together?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># (Euro 100) + (USD 10);;
  ^^^^^^^^
Error: This expression has type cash but an expression was expected of type
  int
</code></pre></div></div>

<p>We get a type error. The function <code class="highlighter-rouge">+</code> is defined on integers only. Note that this error has nothing to do with which constructors for cash we use. For example, if we try to add two <code class="highlighter-rouge">USD</code> values together, we’ll get the error just the same:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># (USD 100) + (USD 50);;
  ^^^^^^^
Error: This expression has type cash but an expression was expected of type
  int
</code></pre></div></div>

<p>Let’s define our own addition function for the type cash:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># let add (x,y) =
  match x,y with
    USD n, USD m   -&gt; Some (USD (n+m))
    | GBP n, GBP m   -&gt; Some (GBP (n+m))
    | Euro n, Euro m -&gt; Some (Euro (n+m))
    | _ -&gt; None;;
val add : cash * cash -&gt; cash option = &lt;fun&gt;
</code></pre></div></div>

<p>There are a few things to notice here. First, we see the use of variables in pattern matching, i.e., the uses of <code class="highlighter-rouge">n</code> and <code class="highlighter-rouge">m</code> in the patterns for each constructor. This allows us to “destruct” values of an ADT and compute with its constituent parts.</p>

<p>Second, think about what happens if we try to add <code class="highlighter-rouge">GBP</code> and <code class="highlighter-rouge">USD</code> values together. We don’t want that to be allowed. One approach we’re used to from other languages is to raise an exception. In Imandra, however, we do not have exceptions. Instead, we use a special type called the <code class="highlighter-rouge">option</code> type to help us structure possible failures. This allows our handling of exceptional cases to take place fully within the type-system, guaranteeing that we never fail to handle an exceptional case or failure.</p>

<p>With an option type, we have two constructors: <code class="highlighter-rouge">Some</code> and <code class="highlighter-rouge">None</code>. For any type <code class="highlighter-rouge">t</code>, there’s an option type called <code class="highlighter-rouge">t option</code> such that the parameter of the <code class="highlighter-rouge">Some</code> constructor has type <code class="highlighter-rouge">t</code>.</p>

<p>Let’s see what happens when we use this function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># add(USD 5, USD 10);;
- : cash option = Some (USD 15)
# add(GBP 25, GBP 50);;
- : cash option = Some (GBP 75)
# add(USD 5, GBP 10);;
- : cash option = None
</code></pre></div></div>

<p>Let’s verify something about this function. For instance, we may want to ensure that if we call the function with arguments of the same currency, then we’ll never get <code class="highlighter-rouge">None</code> as a result.</p>

<p>To express this, we just need to define the concept <code class="highlighter-rouge">same_currency</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># let same_currency (x,y) =
  match x,y with
  USD _, USD _ -&gt; true
  | GBP _, GBP _ -&gt; true
  | Euro _, Euro _ -&gt; true
  | _ -&gt; false
;;
val same_currency : cash * cash -&gt; bool = &lt;fun&gt;
</code></pre></div></div>

<p>And now we can ask Imandra to prove our theorem:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># theorem _ (x,y) =
  same_currency(x,y) ==&gt; add(x,y) &lt;&gt; None;;
thm _ = &lt;proved&gt;
</code></pre></div></div>

<p>ADTs can also be recursive:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># type foo = A of int | B of foo * foo;;
type foo = A of int | B of foo * foo
</code></pre></div></div>

<p>Let’s compute with some values of this type:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># A 100;;
- : foo = A 100
# B (B (A 10, B (A 5, A 123)), A 999);;
- : foo = B (B (A 10, B (A 5, A 123)), A 999)
# B (A 123, A 456);;
- : foo = B (A 123, A 456)
</code></pre></div></div>

<p>Let’s use Imandra to do some deeper investigations:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># verify _ (x,a,b) =
  x &lt;&gt; B (A (a+1), B (A a, A (a+2)));;

Warning: This conjecture contains free type variables.
We shall concretise them to ints for counterexample search.
You can control this by annotating the conjecture with types.

Counterexample:
  
  { x = B (A 1, B (A 0, A 2));
    a = 0;
    b = 0; }
</code></pre></div></div>

<p>Notice our use of the <code class="highlighter-rouge">verify</code> command. This command first tries to prove the given conjecture, and if that fails, it then searches for counterexamples. If a counterexample is found, its values are reflected into the CX module:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># CX.x;;
- : foo = B (A 1, B (A 0, A 2))
# CX.a;;
- : int = 0
# CX.b;;
- : int = 0
</code></pre></div></div>

<p>Notice that warning “This conjecture contains …”: Because the conjecture contains free type variables, these types must be `concretized’ before a search for counterexamples can commence.</p>

<p>Why does this happen in this example? Because the <code class="highlighter-rouge">b</code> variable isn’t actually used! However, we can have type variables for more interesting reasons as well.</p>

<p>By default, type variables are concretized to be integers during counterexample search.
However, we can override this with explicit type annotations:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># verify _ (x,a,b : _ * _ * foo list) =
  x &lt;&gt; B (A (a+1), B (A a, A (a+2)));;

Counterexample:
  { x = B (A 1, B (A 0, A 2));
    a = 0;
    b = []; }
</code></pre></div></div>

<p>Note that we could achieve the same result by using the <code class="highlighter-rouge">instance</code> command instead. We just have to negate our formula:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># instance _ (x,a,b : _ * _ * foo list) =
  x = B (A (a+1), B (A a, A (a+2)));;

Instance:
  { x = B (A 1, B (A 0, A 2));
    a = 0;
    b = []; }
</code></pre></div></div>

<p>Now, let’s do something a bit more interesting:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># verify _ (x,a,b : _ * _ * foo list) =
  not(x = B (A (a+1), B (A a, A (a+2)))
    &amp;&amp; (List.length b &gt; 2)
    &amp;&amp; (List.hd b = A (2*a + 1)));;

No counterexample found up to bound 1. Use :unroll to increase bound.

</code></pre></div></div>

<p>Imandra tells us that no counterexamples were found up to recursion unrolling bound 1. This is not surprising, as we have a constraint requiring the length of a list is greater than 2.</p>

<p>So, let’s set the unrolling bound to 3 and try again:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
# :unroll 3
unroll set to 3.
# verify _ (x,a,b : _ * _ * foo list) =
  not(x = B (A (a+1), B (A a, A (a+2)))
  &amp;&amp; (List.length b &gt; 2)
  &amp;&amp; (List.hd b = A (2*a + 1)));;
  
Counterexample:
  { x = B (A 1797, B (A 1796, A 1798));
    a = 1796;
    b = [A 3593;
          A 19;
          A 20]; }
</code></pre></div></div>

<p>Again, we can compute with our counterexample:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># CX.x;;
- : foo = B (A 1797, B (A 1796, A 1798))
# CX.a;;
- : int = 1796
# CX.b;;
- : foo list = [A 3593; A 19; A 20]
# List.length CX.b;;
- : int = 3
# List.hd CX.b;;
- : foo = A 3593
# 2*CX.a + 1;;
- : int = 3593
</code></pre></div></div>

</div>
		        </article>
	      </main>
	      <footer class="Footer">
	  <a class="Copyrights"href="http://imandra.ai">&#9400; 2018 Aesthetic Integration Ltd. All rights reserved.</a>
</footer>

    </body>

</html>
