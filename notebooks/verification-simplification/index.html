<!DOCTYPE html>
<html>
    <head><meta charset="utf-8" />
        <meta content="width=device-width, initial-scale=1.0" name="viewport">
        <title>Imandra Documentation - Verification Simplification</title>
        <meta property="og:url" content="https://docs.imandra.ai/imandra-docs/notebooks/verification-simplification/">
        <meta property="og:type" content="website">
        <meta property="og:title" content="Imandra Documentation - Verification Simplification">
        <meta property="og:description" content="A description of Imandra's Simplification strategy">
        <meta property="og:image" content="https://storage.googleapis.com/imandra-assets/images/og_image_default_i78.jpg">


        
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116937440-6"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-116937440-1');
        </script>
        <script type="text/javascript"> var sc_project=11767520; var sc_invisible=1; var sc_security="fa7e88d1"; </script>
        <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
        <noscript><div class="statcounter">
            <a title="Web Analytics" href="http://statcounter.com/" target="_blank">
                <img class="statcounter" src="//c.statcounter.com/11767520/0/fa7e88d1/1/" alt="Web Analytics"></a>
        </div></noscript>
        

        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:300,300i,400,400i%7CMerriweather:300,300i,400,400i%7CRoboto+Slab:300,300i,400,400i">

        <link rel="stylesheet" href="/imandra-docs/static/style/style.min.c7df16ea.css" type="text/css">
        <link rel="stylesheet" href="/imandra-docs/static/nbextensions/nbimandra/styles.b466ce6f.css" type="text/css">
        <link rel="stylesheet" href="/imandra-docs/static/docs-styles.b9de737f.css" type="text/css">
        
        <link rel="stylesheet" href="/imandra-docs/static/jekyll-styles.16c4c669.css" type="text/css">
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />

        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
        <script src="/imandra-docs/static/nbimandra-rjs-bundle.b85e58fd.js"></script>

        <style type="text/css">
         .highlight .hll { background-color: #ffffcc }
         .highlight  { background: #f8f8f8; }
         .highlight .c { color: #408080; font-style: italic } /* Comment */
         .highlight .err { border: 1px solid #FF0000 } /* Error */
         .highlight .k { color: #008000; font-weight: bold } /* Keyword */
         .highlight .o { color: #666666 } /* Operator */
         .highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
         .highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
         .highlight .cp { color: #BC7A00 } /* Comment.Preproc */
         .highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
         .highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
         .highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
         .highlight .gd { color: #A00000 } /* Generic.Deleted */
         .highlight .ge { font-style: italic } /* Generic.Emph */
         .highlight .gr { color: #FF0000 } /* Generic.Error */
         .highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
         .highlight .gi { color: #00A000 } /* Generic.Inserted */
         .highlight .go { color: #888888 } /* Generic.Output */
         .highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
         .highlight .gs { font-weight: bold } /* Generic.Strong */
         .highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
         .highlight .gt { color: #0044DD } /* Generic.Traceback */
         .highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
         .highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
         .highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
         .highlight .kp { color: #008000 } /* Keyword.Pseudo */
         .highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
         .highlight .kt { color: #B00040 } /* Keyword.Type */
         .highlight .m { color: #666666 } /* Literal.Number */
         .highlight .s { color: #BA2121 } /* Literal.String */
         .highlight .na { color: #7D9029 } /* Name.Attribute */
         .highlight .nb { color: #008000 } /* Name.Builtin */
         .highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
         .highlight .no { color: #880000 } /* Name.Constant */
         .highlight .nd { color: #AA22FF } /* Name.Decorator */
         .highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
         .highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
         .highlight .nf { color: #0000FF } /* Name.Function */
         .highlight .nl { color: #A0A000 } /* Name.Label */
         .highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
         .highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
         .highlight .nv { color: #19177C } /* Name.Variable */
         .highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
         .highlight .w { color: #bbbbbb } /* Text.Whitespace */
         .highlight .mb { color: #666666 } /* Literal.Number.Bin */
         .highlight .mf { color: #666666 } /* Literal.Number.Float */
         .highlight .mh { color: #666666 } /* Literal.Number.Hex */
         .highlight .mi { color: #666666 } /* Literal.Number.Integer */
         .highlight .mo { color: #666666 } /* Literal.Number.Oct */
         .highlight .sa { color: #BA2121 } /* Literal.String.Affix */
         .highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
         .highlight .sc { color: #BA2121 } /* Literal.String.Char */
         .highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
         .highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
         .highlight .s2 { color: #BA2121 } /* Literal.String.Double */
         .highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
         .highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
         .highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
         .highlight .sx { color: #008000 } /* Literal.String.Other */
         .highlight .sr { color: #BB6688 } /* Literal.String.Regex */
         .highlight .s1 { color: #BA2121 } /* Literal.String.Single */
         .highlight .ss { color: #19177C } /* Literal.String.Symbol */
         .highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
         .highlight .fm { color: #0000FF } /* Name.Function.Magic */
         .highlight .vc { color: #19177C } /* Name.Variable.Class */
         .highlight .vg { color: #19177C } /* Name.Variable.Global */
         .highlight .vi { color: #19177C } /* Name.Variable.Instance */
         .highlight .vm { color: #19177C } /* Name.Variable.Magic */
         .highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
        </style>

        <!-- Loading mathjax macro -->
        <!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    <!-- End of mathjax configuration --><script>
  function handleCopyClick() {
      var el = this;
      var terminal = el.closest('.terminal');
      var highlight = terminal.getElementsByClassName('highlight')[0];
      copyToClipboardMsg(highlight);

      terminal.classList.add('terminal--hide');
      setTimeout(function () {
          terminal.classList.remove('terminal--hide');
      }, 2000);


      function copyToClipboardMsg(elem) {
          var succeed = copyToClipboard(elem);
          var msg;
          if (!succeed) {
              msg = 'Error!';
          } else {
              msg = 'Copied!';
          }

          var msgElem = terminal.querySelector('.terminal__copy-msg');
          msgElem.innerHTML = msg;
          setTimeout(function () {
              msgElem.innerHTML = 'You rock!';
          }, 1000);
      }

      function copyToClipboard(elem) {
          // create hidden text element, if it doesn't already exist
          var targetId = '_hiddenCopyText_';
          var isInput = elem.tagName === 'INPUT' || elem.tagName === 'TEXTAREA';
          var origSelectionStart, origSelectionEnd;
          if (isInput) {
              // can just use the original source element for the selection and copy
              target = elem;
              origSelectionStart = elem.selectionStart;
              origSelectionEnd = elem.selectionEnd;
          } else {
              // must use a temporary form element for the selection and copy
              target = terminal.querySelector('#' + targetId);
              if (!target) {
                  var target = document.createElement('textarea');
                  // target.style.display = 'flex';
                  // target.style.position = 'absolute';
                  // target.style.left = '-1000%';
                  target.id = targetId;
                 elem.appendChild(target);
              }
              target.textContent = elem.textContent.trim();
          }

          // select the content
          var currentFocus = document.activeElement;
          target.focus();
          target.setSelectionRange(0, target.value.length);

          // copy the selection
          var succeed;
          try {
              succeed = document.execCommand('copy');
          } catch (e) {
              succeed = false;
          }
          // restore original focus
          if (currentFocus && typeof currentFocus.focus === 'function') {
              currentFocus.focus();
          }

          if (isInput) {
              // restore prior selection
              elem.setSelectionRange(origSelectionStart, origSelectionEnd);
          } else {
              // clear temporary content
              elem.removeChild(target);
          }
          return succeed;
      }
  }
</script>
    </head>
    <body>
        <div class="background">
        </div>
        <div class="page-container">
            <main class="main-content-column">
                <!-- Jupyter (Imandra core docs) version -->
<header class="header">
    <div class="top-row-container">
        <div class="top-row">

            <div id="toggler--left" class="side__left-menu-toggler">
                <div class="side__toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
                <p class="side__toggle-text">Docs</p>
            </div>

            <div class="side__logo-container">
                <a class="side__logo-link" href="/">
                    <img class="side__logo " src = "/imandra-docs/jekyll-resources/assets/img/imandra-gradient-logo-docs.svg" alt="Imandra Logo" title="Imandra Logo">
                    <img class="side__logo--min " src="/imandra-docs/jekyll-resources/assets/img/imandra-gradient-logo-min.svg" alt="Imandra Logo" title="Imandra Logo">

                </a>
            </div>

            <div id="toggler--right" class="side__right-menu-toggler">
                <p class="side__toggle-text">Pages</p>
                <div class="side__toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>

            <nav id="side-nav-menu" class="side__nav-container side__nav-container--hidden">
                <ul class="side__nav-list">
                    
                    <li class="side__nav-list-item">
                        <a class="side__nav-link" href="/">Documentation Home</a>
                        
                    </li>
                    
                    <li class="side__nav-list-item">
                        <a class="side__nav-link side__nav-link--active" href="/imandra-docs">Imandra Core</a>
                        
                        <ul class="side__nav-list--sub-level-1">
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 side__nav-list--sub-level-1--empty">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/welcome">A quick tour</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2 ">
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 ">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/installation">Installation</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2 ">
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/installation-simple">Installer</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/installation-manual-opam">Manual (opam)</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/installation-docker">Docker Image</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/installation-jupyter">Jupyter Notebook</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/installation-vscode">VSCode</a>
                                            
                                            
                                            
                                        </li>
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 side__nav-list--sub-level-1--empty">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/logic-and-program-modes">Logic and Program modes</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2 ">
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 ">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/verification">Verification</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2  side__nav-list--sub-level-2--active">
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/verification-commands">Commands</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/verification-attributes">Attributes</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/verification-unrolling">Unrolling</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link side__nav-link--active" href="/imandra-docs/notebooks/verification-simplification">Simplification</a>
                                            
                                            
                                            
                                            <div class="side__within-page-nav--sub-level-2">
                                            
  
  
  
  <a class="side__nav-link--within-page side__nav-link--within-page--h2" href="#Rewrite-Rules">Rewrite Rules</a>
  
  
  
  <a class="side__nav-link--within-page side__nav-link--within-page--h3" href="#Permutative-Restriction">Permutative Restriction</a>
  
  
  
  <a class="side__nav-link--within-page side__nav-link--within-page--h2" href="#Forward-chaining-Rules">Forward-chaining Rules</a>
  
  
                                            </div>
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/verification-blast">Blast</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/verification-induction">Induction</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/verification-waterfall">Waterfall</a>
                                            
                                            
                                            
                                        </li>
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 side__nav-list--sub-level-1--empty">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/proving-program-termination">Proving program termination</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2 ">
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 ">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/decomposition">Region Decomposition</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2 ">
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/imandra-tools-intro">Imandra tools introduction</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/idf">Iterative Decomposition Framework</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/notebooks/region-probabilities">Region probabilities</a>
                                            
                                            
                                            
                                        </li>
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 side__nav-list--sub-level-1--empty">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/loading-files">Multifile development</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2 ">
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 side__nav-list--sub-level-1--empty">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/extracting-ocaml-modules-with-imandra-extract">Extracting OCaml modules</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2 ">
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 side__nav-list--sub-level-1--empty">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/plugins">Code generation and plugins</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2 ">
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 side__nav-list--sub-level-1--empty">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/reflection">Reflection of terms</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2 ">
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                            
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 ">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/examples">Examples</a>
                                
                                
                                
                                    <div class="side__within-page-nav--sub-level-1">
                                    
                                    </div>
                                
                            </li>
                            
                            
                            
                            <li class="side__nav-list-item--sub-level-1 ">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/reference">Reference</a>
                                
                                
                                    <ul class="side__nav-list--sub-level-2 ">
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/odoc/imandra-base/Imandra_prelude/">Standard Library</a>
                                            
                                            
                                            
                                        </li>
                                        
                                        <li class="side__nav-list-item--sub-level-2 side__nav-list--sub-level-2--empty">
                                            
                                            <a class="side__nav-link" href="/imandra-docs/odoc/">API Docs</a>
                                            
                                            
                                            
                                        </li>
                                        
                                    </ul>
                                
                                
                                
                                
                            </li>
                            
                        </ul>
                        
                    </li>
                    
                    <li class="side__nav-list-item">
                        <a class="side__nav-link" href="/idf-py">Py IDF</a>
                        
                    </li>
                    
                    <li class="side__nav-list-item">
                        <a class="side__nav-link" href="/ipl">Imandra Protocol Language</a>
                        
                    </li>
                    
                    <li class="side__nav-list-item">
                        <a class="side__nav-link" href="/imandra-rule-synth">Imandra Rule Synth</a>
                        
                    </li>
                    
                    <li class="side__nav-list-item">
                        <a class="side__nav-link" href="/fix-engine">FIX Engine</a>
                        
                    </li>
                    
                </ul>
            </nav>
        </div>
    </div>

    <div class="background">
    </div>



    <div class="template-header">
        <div class="top-bar">
            <div class="side__nav-search">
                <input id="search" type="search" placeholder="Search">
                <div class="side__nav-search-icon">
                    <i class="fa fa-search"></i>
                </div>
            </div>

            <nav class="top-bar__nav-container">
                <a href="#" class="top-bar__toggle">≡</a>
                <div class="top-nav-bar__group ">
                    <div class="top-nav-bar__nav nav-bar--blue top-nav-bar__nav--hidden">
                        <ul class="top-nav-bar__links top-nav-bar__links--hidden-smaller-than-tablet">
                            <li class="top-nav-bar__item">
                                <a href="https://www.imandra.ai/" class="top-nav-bar__link">Home</a>
                            </li>
                            <li class="top-nav-bar__item">
                                <a href="https://try.imandra.ai/" class="top-nav-bar__link">Try</a>
                            </li>
                            <li class="top-nav-bar__item top-nav-bar__item--group dropdown--engine">
                                <a class="top-nav-bar__link top-nav-bar__link--group">Engine</a>
                                <ul class="dropdown-content dropdown-content--engine">
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--core.svg" alt="Imandra Core" title="Imandra Core Icon">
                                        <a class="dropdown__link" href="https://www.imandra.ai/core">Imandra Core</a>
                                    </li>
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--demos.svg" alt="Demo Gallery" title="Imandra Demo Gallery Icon">
                                        <a class="dropdown__link" href="https://www.imandra.ai/demos">Demo Gallery</a>
                                    </li>
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--docs.svg" alt="Docs" title="Docs Icon">
                                        <a class="dropdown__link" href="https://docs.imandra.ai/">Docs</a>
                                    </li>
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--research.svg" alt="Research" title="Research Icon">
                                        <a class="dropdown__link dropdown__link--last" href="https://www.imandra.ai/research">Research</a>
                                    </li>
                                </ul>
                            </li>
                            <li class="top-nav-bar__item top-nav-bar__item--group dropdown--industries">
                                <a class="top-nav-bar__link top-nav-bar__link--group">Industries</a>
                                <ul class="dropdown-content dropdown-content--industries">
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--financial.svg" alt="Financial Markets" title="Financial Markets Icon">
                                        <a class="dropdown__link " href="https://www.imandra.ai/imarkets">Financial Markets</a>
                                    </li>
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--autonomy.svg" alt="Autonomous Systems" title="Autonomous Systems Icon">
                                        <a class="dropdown__link" href="https://www.imandra.ai/autonomy">Autonomous Systems</a>
                                    </li>
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--ml.svg" alt="Machine Learning" title="Machine Learning Icon">
                                        <a class="dropdown__link" href="https://www.imandra.ai/ml">Machine Learning</a>
                                    </li>
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--government.svg" alt="Machine Learning" title="Machine Learning Icon">
                                        <a class="dropdown__link dropdown__link--last" href="https://www.imandra.ai/government">Government and defense</a>
                                    </li>
                                </ul>
                            </li>
                            <li class="top-nav-bar__item top-nav-bar__item--group dropdown--media">
                                <a class="top-nav-bar__link top-nav-bar__link--group">Media</a>
                                <ul class="dropdown-content dropdown-content--media">
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--media.svg" alt="Media" title="Media Icon">
                                        <a class="dropdown__link " href="https://www.imandra.ai/media">Media</a></li>
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--blog.svg" alt="Blog" title="Blog Icon">
                                        <a class="dropdown__link dropdown__link--last " href="https://medium.com/imandra">Blog</a>
                                    </li>
                                </ul>
                            </li>
                            <li class="top-nav-bar__item top-nav-bar__item--group dropdown--company">
                                <a class="top-nav-bar__link top-nav-bar__link--group">Company</a>
                                <ul class="dropdown-content dropdown-content--company">
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--about.svg" alt="About" title="About Icon">
                                        <a class="dropdown__link" href="https://www.imandra.ai/about">About</a></li>
                                    <li class="dropdown__item dropdown__item--with-icon">
                                        <img class="dropdown__icon" src="/imandra-docs/jekyll-resources/assets/img/icon--menu--careers.svg" alt=" Careers" title="Careers Icon">
                                        <a class="dropdown__link dropdown__link--last dropdown__link--bottom" href="https://www.imandra.ai/careers">Careers</a></li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </nav>
        </div>

        <div class="template-header__image-container template-header__image-container--jupyter">
            <div class="template-header__image" href ="/imandra-docs">
                <img class="site-specific-image" src="/imandra-docs/static/img/site_specific_image_v_2.svg">
            </div>
        </div>

    </div>



    <script>
        document.getElementById('toggler--left').addEventListener('click', function () {
            document.querySelector('.side__right-menu-toggler .side__toggle').classList.remove(
                'side__toggle--active');
            document.querySelector('.side__left-menu-toggler .side__toggle').classList.toggle(
                'side__toggle--active');
            document.getElementsByClassName('side__nav-container')[0].classList.toggle(
                'side__nav-container--hidden');
            document.getElementsByClassName('top-nav-bar__nav')[0].classList.add('top-nav-bar__nav--hidden');
        });

        document.getElementById('toggler--right').addEventListener('click', function () {
            document.querySelector('.side__left-menu-toggler .side__toggle').classList.remove(
                'side__toggle--active');
            document.querySelector('.side__right-menu-toggler .side__toggle').classList.toggle(
                'side__toggle--active');

            document.getElementsByClassName('side__nav-container')[0].classList.add(
                'side__nav-container--hidden');
            document.getElementsByClassName('top-nav-bar__nav')[0].classList.toggle(
                'top-nav-bar__nav--hidden');
        });
    </script>
</header>
                <article class="article__container article__container--notebooks">
                    <div class="main-content main-content--jupyter">
                        
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h1 id="Simplification">Simplification<a class="anchor-link" href="#Simplification">&#182;</a></h1><p>At the heart of Imandra is a powerful symbolic simplifier and <a href="https://en.wikipedia.org/wiki/Partial_evaluation">partial
evaluator</a>. The simplifier is
integrated with the <a href="/imandra-docs/notebooks/verification-waterfall/">inductive waterfall</a> (e.g., <code>[@@auto]</code>),
and is the main way in which previously proved lemmas are used during proofs,
through the automatic application of rules. The simplifier
can also be used as a pre-processing step before unrolling, via the <code>[@@simp]</code>
attribute.</p>
<p>As the name suggests, simplification is a process that attempts to transform a
formula into a "simpler" form, bringing the salient features of a formula or
conjecture to the surface. Simplification can also prove goals by reducing them
to <code>true</code>, and refute them by reducing them to <code>false</code>.</p>
<p>Notably, because the symbolic evaluation semantics of the simplifier operate on
a compact <a href="https://en.wikipedia.org/wiki/Directed_graph">digraph</a> representation
of formulas and function definitions, simplification can be thought as having
<a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> semantics for free.</p>
<p>We can see an example of this by using the following naive recursive version of
the fibonacci function:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-2" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span>
    <span class="mi">1</span>
  <span class="k">else</span>
    <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[1]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val fib : int -&gt; int = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-fold panel panel-default" id="fold-55487fbb-31f7-4981-80a8-3468e2422c02"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>termination proof</span></div></div><div class="panel-body collapse"><div><h3>Termination proof</h3><p></p><div class="imandra-fold panel panel-default" id="fold-cfd1f50d-8fb9-4dad-b0e8-3f4b6132bc90"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>call `fib (n - 1)` from `fib n`</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-88366c6f-1c4d-45ea-9920-d41a418fb6c3"><table><tr><td><b>original</b></td><td>fib n</td></tr><tr><td><b>sub</b></td><td>fib (n - 1)</td></tr><tr><td><b>original ordinal</b></td><td>Ordinal.Int (if n &gt;= 0 then n else 0)</td></tr><tr><td><b>sub ordinal</b></td><td>let (_x_0 : int) = n - 1 in Ordinal.Int (if _x_0 &gt;= 0 then _x_0 else 0)</td></tr><tr><td><b>path</b></td><td>[not (n &lt;= 1)]</td></tr><tr><td><b>proof</b></td><td><div class="imandra-fold panel panel-default" id="fold-d221a12c-351f-4564-9a82-3cc22578304c"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>detailed proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-694a1903-1415-49dc-8f7e-042873a283a4"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-4204e728-e3de-41b6-9804-554b717e7bed"><table><tr><td><b>ground_instances</b></td><td>1</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.011s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-86787832-f379-4ba6-8256-4cd4a89c0969"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-b8ea5569-789f-49ad-8d5e-4c85c16e3caa"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-c3879374-5b5d-4ba2-a854-bb9c926541ee"><table><tr><td><b>num checks</b></td><td>3</td></tr><tr><td><b>arith-make-feasible</b></td><td>5</td></tr><tr><td><b>arith-max-columns</b></td><td>11</td></tr><tr><td><b>arith-conflicts</b></td><td>1</td></tr><tr><td><b>rlimit count</b></td><td>2314</td></tr><tr><td><b>mk clause</b></td><td>5</td></tr><tr><td><b>datatype occurs check</b></td><td>2</td></tr><tr><td><b>mk bool var</b></td><td>18</td></tr><tr><td><b>arith-lower</b></td><td>3</td></tr><tr><td><b>decisions</b></td><td>2</td></tr><tr><td><b>arith-propagations</b></td><td>3</td></tr><tr><td><b>propagations</b></td><td>2</td></tr><tr><td><b>arith-bound-propagations-cheap</b></td><td>3</td></tr><tr><td><b>arith-max-rows</b></td><td>4</td></tr><tr><td><b>conflicts</b></td><td>2</td></tr><tr><td><b>datatype accessor ax</b></td><td>2</td></tr><tr><td><b>num allocs</b></td><td>867262736</td></tr><tr><td><b>final checks</b></td><td>1</td></tr><tr><td><b>added eqs</b></td><td>6</td></tr><tr><td><b>del clause</b></td><td>5</td></tr><tr><td><b>arith eq adapter</b></td><td>2</td></tr><tr><td><b>arith-upper</b></td><td>6</td></tr><tr><td><b>memory</b></td><td>29.700000</td></tr><tr><td><b>max memory</b></td><td>35.140000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-86787832-f379-4ba6-8256-4cd4a89c0969';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-16090156-5798-4079-b9ad-752bd958d9b6"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.011s]
  let (_x_0 : int) = if n &gt;= 0 then n else 0 in
  let (_x_1 : int) = n - 1 in
  let (_x_2 : int) = if _x_1 &gt;= 0 then _x_1 else 0 in
  let (_x_3 : bool) = _x_1 &lt;= 1 in
  not (n &lt;= 1) &amp;&amp; _x_0 &gt;= 0 &amp;&amp; _x_2 &gt;= 0
  ==&gt; _x_3 &amp;&amp; _x_3 || Ordinal.( &lt;&lt; ) (Ordinal.Int _x_2) (Ordinal.Int _x_0)</pre></li><li><div><h5>simplify</h5><div class="imandra-table" id="table-f1e70758-8507-47de-99bc-fdebd4ef2c86"><table><tr><td><b>into</b></td><td><pre>(n &lt;= 1 || n &lt;= 2)
|| Ordinal.( &lt;&lt; ) (Ordinal.Int (if n &gt;= 1 then -1 + n else 0))
   (Ordinal.Int (if n &gt;= 0 then n else 0))</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-ba20e70c-5f91-491c-9798-8da36074b84c"><table><tr><td><b>expr</b></td><td><pre>(|Ordinal.&lt;&lt;_102| (|Ordinal.Int_93| (ite (&gt;= n_2441 1) (+ (- 1) n_2441) 0))
                  (|Ordi…</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li>Unsat</li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-16090156-5798-4079-b9ad-752bd958d9b6';
  fold.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-694a1903-1415-49dc-8f7e-042873a283a4';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-d221a12c-351f-4564-9a82-3cc22578304c';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-cfd1f50d-8fb9-4dad-b0e8-3f4b6132bc90';
  fold.hydrate(target);
});
</script></div><p></p><div class="imandra-fold panel panel-default" id="fold-197cd75d-93a0-46dd-82cb-1e136687ed01"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>call `fib (n - 2)` from `fib n`</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-8385cdd2-53ea-49b4-97e3-8cbfb3f02904"><table><tr><td><b>original</b></td><td>fib n</td></tr><tr><td><b>sub</b></td><td>fib (n - 2)</td></tr><tr><td><b>original ordinal</b></td><td>Ordinal.Int (if n &gt;= 0 then n else 0)</td></tr><tr><td><b>sub ordinal</b></td><td>let (_x_0 : int) = n - 2 in Ordinal.Int (if _x_0 &gt;= 0 then _x_0 else 0)</td></tr><tr><td><b>path</b></td><td>[not (n &lt;= 1)]</td></tr><tr><td><b>proof</b></td><td><div class="imandra-fold panel panel-default" id="fold-500f1a54-3e20-45bf-bad9-d43bd3ed6225"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>detailed proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-8288a70a-2223-43fe-a3fa-48e526ef47cf"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-d9a8ada8-194b-4d29-9d21-a2399252932e"><table><tr><td><b>ground_instances</b></td><td>1</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.012s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-5f2f4f28-db81-43ff-89db-539e659a073e"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-65379dce-c2b8-4dae-9672-616b4073511d"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-030e0e23-7c44-44c2-a2b3-4cbb2af3fe4e"><table><tr><td><b>num checks</b></td><td>3</td></tr><tr><td><b>arith-make-feasible</b></td><td>5</td></tr><tr><td><b>arith-max-columns</b></td><td>11</td></tr><tr><td><b>arith-conflicts</b></td><td>1</td></tr><tr><td><b>rlimit count</b></td><td>1157</td></tr><tr><td><b>mk clause</b></td><td>5</td></tr><tr><td><b>datatype occurs check</b></td><td>2</td></tr><tr><td><b>mk bool var</b></td><td>18</td></tr><tr><td><b>arith-lower</b></td><td>3</td></tr><tr><td><b>decisions</b></td><td>2</td></tr><tr><td><b>arith-propagations</b></td><td>3</td></tr><tr><td><b>propagations</b></td><td>2</td></tr><tr><td><b>arith-bound-propagations-cheap</b></td><td>3</td></tr><tr><td><b>arith-max-rows</b></td><td>4</td></tr><tr><td><b>conflicts</b></td><td>2</td></tr><tr><td><b>datatype accessor ax</b></td><td>2</td></tr><tr><td><b>num allocs</b></td><td>844302675</td></tr><tr><td><b>final checks</b></td><td>1</td></tr><tr><td><b>added eqs</b></td><td>6</td></tr><tr><td><b>del clause</b></td><td>5</td></tr><tr><td><b>arith eq adapter</b></td><td>2</td></tr><tr><td><b>arith-upper</b></td><td>6</td></tr><tr><td><b>memory</b></td><td>27.150000</td></tr><tr><td><b>max memory</b></td><td>35.140000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-5f2f4f28-db81-43ff-89db-539e659a073e';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-d4cc535f-d36f-41c2-9040-1606a577e61c"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.012s]
  let (_x_0 : int) = if n &gt;= 0 then n else 0 in
  let (_x_1 : int) = n - 2 in
  let (_x_2 : int) = if _x_1 &gt;= 0 then _x_1 else 0 in
  let (_x_3 : bool) = _x_1 &lt;= 1 in
  not (n &lt;= 1) &amp;&amp; _x_0 &gt;= 0 &amp;&amp; _x_2 &gt;= 0
  ==&gt; _x_3 &amp;&amp; _x_3 || Ordinal.( &lt;&lt; ) (Ordinal.Int _x_2) (Ordinal.Int _x_0)</pre></li><li><div><h5>simplify</h5><div class="imandra-table" id="table-dae9adab-9421-4a26-8ffb-1da2aec46759"><table><tr><td><b>into</b></td><td><pre>(n &lt;= 1 || n &lt;= 3)
|| Ordinal.( &lt;&lt; ) (Ordinal.Int (if n &gt;= 2 then -2 + n else 0))
   (Ordinal.Int (if n &gt;= 0 then n else 0))</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-18462d6f-8ee0-4e3f-9b73-0fa33cc842b2"><table><tr><td><b>expr</b></td><td><pre>(|Ordinal.&lt;&lt;_102| (|Ordinal.Int_93| (ite (&gt;= n_2441 2) (+ (- 2) n_2441) 0))
                  (|Ordi…</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li>Unsat</li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-d4cc535f-d36f-41c2-9040-1606a577e61c';
  fold.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-8288a70a-2223-43fe-a3fa-48e526ef47cf';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-500f1a54-3e20-45bf-bad9-d43bd3ed6225';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-197cd75d-93a0-46dd-82cb-1e136687ed01';
  fold.hydrate(target);
});
</script></div><p></p></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-55487fbb-31f7-4981-80a8-3468e2422c02';
  fold.hydrate(target);
});
</script></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If we try to use Imandra's simplification to search for a solution for <code>fib 200</code>,
Imandra comes back to us with a solution immediately:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-4" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="o">#</span><span class="n">check_models</span> <span class="bp">false</span><span class="o">;;</span>
<span class="n">instance</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fib</span> <span class="mi">200</span><span class="o">)</span> <span class="o">[@@</span><span class="n">simp</span><span class="o">];;</span>
<span class="o">#</span><span class="n">check_models</span> <span class="bp">true</span><span class="o">;;</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[2]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : int -&gt; bool = &lt;fun&gt;
module CX : sig val x : int end
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><pre>Instance (after 0 steps, 0.050s):
 let (x : int) = 453973694165307953197296969697410619233826
</pre></div>

</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Instance</span></div><div><div class="imandra-alternatives" id="alt-6fe52372-b00f-4979-92b2-f5d1a4ccb02a"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>call graph</a></li><li class="" data-toggle="tab"><a>proof</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-graphviz" id="graphviz-edd019a9-6ccb-44f9-ae7c-64898ae124a4"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;x = 453973694165307953197296969697410619233826&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-edd019a9-6ccb-44f9-ae7c-64898ae124a4';
  graphviz.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-ec7da692-d243-4943-a406-92a85b09626d"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof attempt</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-cafc18aa-c05a-473b-a21e-1ea4f87666ad"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-a0ddce41-b4b5-43d4-bc84-8224fcb5170a"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>201</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.050s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-7c10eba3-da8d-4d35-9c38-3f4ead3d2113"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-2b11f77f-3d69-4b11-b52f-ed584875aa3f"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-4d75fa90-8999-4830-a4bd-ba3b691c4c6d"><table><tr><td><b>eliminated vars</b></td><td>1</td></tr><tr><td><b>rlimit count</b></td><td>7905</td></tr><tr><td><b>mk bool var</b></td><td>1</td></tr><tr><td><b>num allocs</b></td><td>942084230</td></tr><tr><td><b>memory</b></td><td>33.060000</td></tr><tr><td><b>max memory</b></td><td>35.140000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-7c10eba3-da8d-4d35-9c38-3f4ead3d2113';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-57201b15-dc8d-4ac0-b119-10e69068ec54"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.050s] :var_0: = fib 200</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-50f034ef-42d6-4649-ac43-b90f674a6748"><table><tr><td><b>into</b></td><td><pre>x = 453973694165307953197296969697410619233826</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li>Sat (Some  let (x : int) = 453973694165307953197296969697410619233826
)</li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-57201b15-dc8d-4ac0-b119-10e69068ec54';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-d1d4e2bd-d25c-4afd-ae1c-bb23d641df38"><textarea style="display: none">digraph &quot;proof&quot; {
p_255 [label=&quot;Start (:var_0: = fib 200 :time 0.050s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_255 -&gt; p_254 [label=&quot;&quot;];
p_254 [label=&quot;Simplify (x = 453973694165307953197296969697410619233826\l          :expansions [fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib]\l          :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_254 -&gt; p_253 [label=&quot;&quot;];
p_253 [label=&quot;Sat (Some  let (x : int) = 453973694165307953197296969697410619233826\l)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-d1d4e2bd-d25c-4afd-ae1c-bb23d641df38';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-cafc18aa-c05a-473b-a21e-1ea4f87666ad';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-ec7da692-d243-4943-a406-92a85b09626d';
  fold.hydrate(target);
});
</script></div></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-6fe52372-b00f-4979-92b2-f5d1a4ccb02a';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If, however, we tried to use normal OCaml evaluation to compute <code>fib 200</code>, OCaml
would take over 10 minutes in order to come back with a response (the
<code>#check_models false</code> command here is used to tell Imandra not to check the
instance Imandra computed using OCaml evaluation, as that requires the expensive
computation of <code>fib 200</code> via standard OCaml evaluation, which is not memoized).</p>
<!-- TODO mention SMT decision procedures? -->

<p>Now that we know what simplification does, let's learn about how to influence it
using rewrite and forward chaining rules.</p>
<h2 id="Rewrite-Rules">Rewrite Rules<a class="anchor-link" href="#Rewrite-Rules">&#182;</a></h2><p>A rewrite rule is a theorem of the form</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<pre><code>h_1 &amp;&amp; ... &amp;&amp; h_k ==&gt; lhs = rhs</code></pre>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>which Imandra can use in further proofs to replace terms that match with <code>lhs</code>
(the "left hand side") with the appropriate instantiation of <code>rhs</code> (the "right
hand side"), provided that the instantiations of the hypotheses can be
established. Observe that rewrite rules are both <em>conditional</em> (requiring in
general the establishment of hypotheses) and <em>directed</em> (replacing <code>lhs</code> with
<code>rhs</code>). The <code>lhs</code> is also called the "pattern" of the rule.</p>
<p>An enabled rewrite rule causes Imandra to look for matches of the <code>lhs</code>,
replacing the matched term with the (suitably instantiated) <code>rhs</code>, provided that
Imandra can establish ("relieve") the (suitably instantiated) hypotheses of the
rule.</p>
<p>For example, consider the lemma <code>rev_len</code> below. This lemma expresses the fact
that the length of a list <code>x</code> is equal to the length of <code>List.rev x</code>, i.e., if
we reverse a list, we end up with a list of the same length. This rule is
unconditional: it has no hypotheses. Thus, it will always be able to fire on
terms that match its left-hand side. Notice that Imandra uses a previously
defined rewrite rule in order to prove this lemma! The lemma <code>rev_len</code> would
make an excellent rewrite rule, so we use the <code>[@@rw]</code> annotation to install it:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-8" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">rev_len</span> <span class="n">x</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">x</span><span class="o">)</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">x</span>
<span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">rw</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[3]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val rev_len : &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

List.length (List.rev x) = List.length x.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

|---------------------------------------------------------------------------
 List.length (List.rev x) = List.length x


Must try induction.

The recursive terms in the conjecture suggest 2 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">List.rev</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (x = [] ==&gt; φ x) &amp;&amp; (not (x = []) &amp;&amp; φ (List.tl x) ==&gt; φ x).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. x = []
|---------------------------------------------------------------------------
 List.length (List.rev x) = List.length x

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.length
</span>and<span class="ansi-blue-intense-fg ansi-bold"> List.rev</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (x = [])
 H1. List.length (List.rev (List.tl x)) = List.length (List.tl x)
|---------------------------------------------------------------------------
 List.length (List.rev x) = List.length x

This simplifies, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.length </span>and<span class="ansi-blue-intense-fg ansi-bold"> List.rev</span> to:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;</span>:

 H0. List.length (List.rev (List.tl x)) = List.length (List.tl x)
 H1. x &lt;&gt; []
|---------------------------------------------------------------------------
 List.length (List.append (List.rev (List.tl x)) [List.hd x]) =
 1 + List.length (List.tl x)


We can eliminate destructors by the following substitution:
 x -&gt; x1 :: x2

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;</span>:

 H0. List.length (List.rev x2) = List.length x2
|---------------------------------------------------------------------------
 List.length (List.append (List.rev x2) [x1]) = 1 + List.length x2


Cross-fertilizing with:

 List.length (List.rev x2) = List.length x2

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;</span>:

|---------------------------------------------------------------------------
 List.length (List.append (List.rev x2) [x1]) = 1 + List.length (List.rev x2)


Candidates for generalization:

 List.rev x2

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;&#39;</span>:

|---------------------------------------------------------------------------
 List.length (List.append gen_1 [x1]) = 1 + List.length gen_1


Must try induction.

The recursive terms in the conjecture suggest 2 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">List.append</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (gen_1 = [] ==&gt; φ gen_1 x1)
 &amp;&amp; (not (gen_1 = []) &amp;&amp; φ (List.tl gen_1) x1 ==&gt; φ gen_1 x1).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;&#39;.2</span>:

 H0. gen_1 = []
|---------------------------------------------------------------------------
 List.length (List.append gen_1 [x1]) = 1 + List.length gen_1

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.append
</span>and<span class="ansi-blue-intense-fg ansi-bold"> List.length</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;&#39;.1</span>:

 H0. not (gen_1 = [])
 H1. List.length (List.append (List.tl gen_1) [x1]) =
     1 + List.length (List.tl gen_1)
|---------------------------------------------------------------------------
 List.length (List.append gen_1 [x1]) = 1 + List.length gen_1

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.append
</span>and<span class="ansi-blue-intense-fg ansi-bold"> List.length</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def List.append)
    (:def List.length)
    (:def List.rev)
    (:fc List.len_nonnegative)
    (:induct List.append)
    (:induct List.rev)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-a2907211-cb54-4e4c-af36-187a496adbbd"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-b6bec59a-c2fb-4bc9-a22f-006b9b234b43"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-0bd3b71c-38e7-45f7-96e7-7d5251577029"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>11</td></tr><tr><td><b>inductions</b></td><td>2</td></tr><tr><td><b>search_time</b></td><td><pre>0.529s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-0777fd69-7eb1-4097-a67c-9a91888ea033"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.529s, &quot;Goal&quot;] List.length (List.rev :var_0:) = List.length :var_0:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-eb28228b-fa6d-4cb4-8fec-777b94142e91"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>List.length (List.rev x) = List.length x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.529s, &quot;1&quot;] List.length (List.rev x) = List.length x</pre></li><li><pre>induction on (functional )
:scheme (x = [] ==&gt; φ x) &amp;&amp; (not (x = []) &amp;&amp; φ (List.tl x) ==&gt; φ x)</pre></li><li><div><pre>Split (let (_x_0 : bool) = not (x = []) in
       let (_x_1 : bool) = List.length (List.rev x) = List.length x in
       let (_x_2 : sko_ty_0 list) = List.tl x in
       (_x_0 || _x_1)
       &amp;&amp; (not (_x_0 &amp;&amp; List.length (List.rev _x_2) = List.length _x_2)
           || _x_1)
       :cases [not (x = []) || List.length (List.rev x) = List.length x;
               let (_x_0 : sko_ty_0 list) = List.tl x in
               (x = []
                || not (List.length (List.rev _x_0) = List.length _x_0))
               || List.length (List.rev x) = List.length x])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-f148954e-d5f8-4be5-b2ca-f3bb44f6f84e"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>let (_x_0 : sko_ty_0 list) = List.tl x in
(x = [] || not (List.length (List.rev _x_0) = List.length _x_0))
|| List.length (List.rev x) = List.length x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.457s, &quot;1.1&quot;]
  let (_x_0 : sko_ty_0 list) = List.tl x in
  (x = [] || not (List.length (List.rev _x_0) = List.length _x_0))
  || List.length (List.rev x) = List.length x</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-ee3623e7-3de8-4cf2-8bce-4983d9c381c0"><table><tr><td><b>into</b></td><td><pre>let (_x_0 : sko_ty_0 list) = List.tl x in
let (_x_1 : sko_ty_0 list) = List.rev _x_0 in
let (_x_2 : int) = List.length _x_0 in
(List.length (List.append _x_1 [List.hd x]) = 1 + _x_2
 || not (List.length _x_1 = _x_2))
|| x = []</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[List.length, List.rev]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li></ul></td></tr></table></div></div></li><li><pre>Elim_destructor (:cstor :: :replace x1 :: x2 :context [])</pre></li><li><pre>Generalize (let (_x_0 : sko_ty_0 list) = List.rev x2 in
            List.length (List.append _x_0 [x1]) = 1 + List.length _x_0
            :as (gen_1 : sko_ty_0 list))</pre></li><li><pre>induction on (functional )
:scheme (gen_1 = [] ==&gt; φ gen_1 x1)
        &amp;&amp; (not (gen_1 = []) &amp;&amp; φ (List.tl gen_1) x1 ==&gt; φ gen_1 x1)</pre></li><li><div><pre>Split (let (_x_0 : bool) = not (gen_1 = []) in
       let (_x_1 : sko_ty_0 list) = [x1] in
       let (_x_2 : bool)
           = List.length (List.append gen_1 _x_1) = 1 + List.length gen_1
       in
       let (_x_3 : sko_ty_0 list) = List.tl gen_1 in
       (_x_0 || _x_2)
       &amp;&amp; (not
           (_x_0
            &amp;&amp; List.length (List.append _x_3 _x_1) = 1 + List.length _x_3)
           || _x_2)
       :cases [not (gen_1 = [])
               || List.length (List.append gen_1 [x1]) =
                  1 + List.length gen_1;
               let (_x_0 : sko_ty_0 list) = List.tl gen_1 in
               let (_x_1 : sko_ty_0 list) = [x1] in
               (gen_1 = []
                || not
                   (List.length (List.append _x_0 _x_1) =
                    1 + List.length _x_0))
               || List.length (List.append gen_1 _x_1) =
                  1 + List.length gen_1])</pre><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-f148954e-d5f8-4be5-b2ca-f3bb44f6f84e';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-b4c98dc0-5b35-473c-b146-6adb260fb0c3"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>not (x = []) || List.length (List.rev x) = List.length x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.457s, &quot;1.2&quot;] not (x = []) || List.length (List.rev x) = List.length x</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-af7bcc7a-3134-40e4-94c7-fe1e6e55ce94"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[List.length, List.length, List.rev]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-b4c98dc0-5b35-473c-b146-6adb260fb0c3';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-eb28228b-fa6d-4cb4-8fec-777b94142e91';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-0777fd69-7eb1-4097-a67c-9a91888ea033';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-8c73bc61-b17f-4414-ad6e-f909e32dddc0"><textarea style="display: none">digraph &quot;proof&quot; {
p_331 [label=&quot;Start (List.length (List.rev :var_0:) = List.length :var_0: :name \&quot;Goal\&quot;\l       :time 0.529s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_331 -&gt; p_329 [label=&quot;&quot;];
subgraph cluster_330 {
  color=blue;
p_329 [label=&quot;Start (List.length (List.rev x) = List.length x :name \&quot;1\&quot; :time 0.529s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_329 -&gt; p_328 [label=&quot;&quot;];
p_328 [label=&quot;Induct ((functional ),\l        :scheme (x = [] ==\&gt; φ x)\l                &amp;&amp; (not (x = []) &amp;&amp; φ (List.tl x) ==\&gt; φ x))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_328 -&gt; p_327 [label=&quot;&quot;];
p_327 [label=&quot;Split (let (_x_0 : bool) = not (x = []) in\l       let (_x_1 : bool) = List.length (List.rev x) = List.length x in\l       let (_x_2 : sko_ty_0 list) = List.tl x in\l       (_x_0 \|\| _x_1)\l       &amp;&amp; (not (_x_0 &amp;&amp; List.length (List.rev _x_2) = List.length _x_2)\l           \|\| _x_1)\l       :cases [not (x = []) \|\| List.length (List.rev x) = List.length x;\l               let (_x_0 : sko_ty_0 list) = List.tl x in\l               (x = []\l                \|\| not (List.length (List.rev _x_0) = List.length _x_0))\l               \|\| List.length (List.rev x) = List.length x])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_327 -&gt; p_322 [label=&quot;&quot;];
subgraph cluster_323 {
  color=blue;
p_322 [label=&quot;Start (let (_x_0 : sko_ty_0 list) = List.tl x in\l       (x = [] \|\| not (List.length (List.rev _x_0) = List.length _x_0))\l       \|\| List.length (List.rev x) = List.length x :name \&quot;1.1\&quot; :time 0.457s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_322 -&gt; p_321 [label=&quot;&quot;];
p_321 [label=&quot;Simplify (let (_x_0 : sko_ty_0 list) = List.tl x in\l          let (_x_1 : sko_ty_0 list) = List.rev _x_0 in\l          let (_x_2 : int) = List.length _x_0 in\l          (List.length (List.append _x_1 [List.hd x]) = 1 + _x_2\l           \|\| not (List.length _x_1 = _x_2))\l          \|\| x = [] :expansions [List.length; List.rev] :rw []\l          :fc [List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_321 -&gt; p_320 [label=&quot;&quot;];
p_320 [label=&quot;Elim_destructor (:cstor :: :replace x1 :: x2 :context [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_320 -&gt; p_319 [label=&quot;&quot;];
p_319 [label=&quot;Generalize (let (_x_0 : sko_ty_0 list) = List.rev x2 in\l            List.length (List.append _x_0 [x1]) = 1 + List.length _x_0\l            :as (gen_1 : sko_ty_0 list))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_319 -&gt; p_318 [label=&quot;&quot;];
p_318 [label=&quot;Induct ((functional ),\l        :scheme (gen_1 = [] ==\&gt; φ gen_1 x1)\l                &amp;&amp; (not (gen_1 = []) &amp;&amp; φ (List.tl gen_1) x1 ==\&gt; φ gen_1 x1))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_318 -&gt; p_317 [label=&quot;&quot;];
p_317 [label=&quot;Split (let (_x_0 : bool) = not (gen_1 = []) in\l       let (_x_1 : sko_ty_0 list) = [x1] in\l       let (_x_2 : bool)\l           = List.length (List.append gen_1 _x_1) = 1 + List.length gen_1\l       in\l       let (_x_3 : sko_ty_0 list) = List.tl gen_1 in\l       (_x_0 \|\| _x_2)\l       &amp;&amp; (not\l           (_x_0\l            &amp;&amp; List.length (List.append _x_3 _x_1) = 1 + List.length _x_3)\l           \|\| _x_2)\l       :cases [not (gen_1 = [])\l               \|\| List.length (List.append gen_1 [x1]) =\l                  1 + List.length gen_1;\l               let (_x_0 : sko_ty_0 list) = List.tl gen_1 in\l               let (_x_1 : sko_ty_0 list) = [x1] in\l               (gen_1 = []\l                \|\| not\l                   (List.length (List.append _x_0 _x_1) =\l                    1 + List.length _x_0))\l               \|\| List.length (List.append gen_1 _x_1) =\l                  1 + List.length gen_1])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_317 -&gt; p_312 [label=&quot;&quot;];
subgraph cluster_313 {
  color=blue;
p_312 [label=&quot;Start (let (_x_0 : sko_ty_0 list) = List.tl gen_1 in\l       let (_x_1 : sko_ty_0 list) = [x1] in\l       (gen_1 = []\l        \|\| not (List.length (List.append _x_0 _x_1) = 1 + List.length _x_0))\l       \|\| List.length (List.append gen_1 _x_1) = 1 + List.length gen_1\l       :name \&quot;1.1''''.1\&quot; :time 0.039s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_312 -&gt; p_311 [label=&quot;&quot;];
p_311 [label=&quot;Simplify (true :expansions [List.length; List.length; List.append] :rw []\l          :fc [List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_317 -&gt; p_315 [label=&quot;&quot;];
subgraph cluster_316 {
  color=blue;
p_315 [label=&quot;Start (not (gen_1 = [])\l       \|\| List.length (List.append gen_1 [x1]) = 1 + List.length gen_1\l       :name \&quot;1.1''''.2\&quot; :time 0.039s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_315 -&gt; p_314 [label=&quot;&quot;];
p_314 [label=&quot;Simplify (true :expansions [List.length; List.length; List.append] :rw []\l          :fc [List.len_nonnegative; List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
p_327 -&gt; p_325 [label=&quot;&quot;];
subgraph cluster_326 {
  color=blue;
p_325 [label=&quot;Start (not (x = []) \|\| List.length (List.rev x) = List.length x :name \&quot;1.2\&quot;\l       :time 0.457s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_325 -&gt; p_324 [label=&quot;&quot;];
p_324 [label=&quot;Simplify (true :expansions [List.length; List.length; List.rev] :rw []\l          :fc [List.len_nonnegative; List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-8c73bc61-b17f-4414-ad6e-f909e32dddc0';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-b6bec59a-c2fb-4bc9-a22f-006b9b234b43';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-a2907211-cb54-4e4c-af36-187a496adbbd';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>With this rule installed and enabled, if Imandra's simplifier encounters a term
of the form <code>List.length (List.rev &lt;term&gt;)</code>, it will replace it with the simpler
form <code>List.length &lt;term&gt;</code>.</p>
<p>Both the hypotheses and <code>rhs</code> can be omitted, in which case Imandra will default
them to <code>true</code>. That is, <code>h_1 &amp;&amp; ... &amp;&amp; h_k ==&gt; lhs</code> is equivalent to
<code>h_1 &amp;&amp; h_k ==&gt; lhs = true</code> and <code>lhs = rhs</code> is equal to <code>true ==&gt; lhs = rhs</code>.</p>
<p>Imandra's rewriting is:</p>
<ul>
<li><p>conditional: rewrite rules may contain conditions (hypotheses), and eligible
rules are only applied when their hypotheses are established. Once the pattern
of a rule has been matched, Imandra uses backward-chaining ("backchaining") to
relieve the rule's hypotheses, recursively attempting to simplify them to
<code>true</code> modulo the current simplification context. This is important to keep in
mind when developing your theories: rewrite rules will not fire unless Imandra
can simplify their instantiated hypotheses to <code>true</code>.</p>
</li>
<li><p>oriented: given a rule whose conclusion is of the form <code>lhs = rhs</code>, rewriting
happens by replacing the (instantiated) <code>lhs</code> with the (instantiated) <code>rhs</code>.</p>
</li>
</ul>
<p>When adding a new rewrite rule, users should take care to orient the equality so
that <code>rhs</code> is <em>simpler</em> or <em>more canonical</em> than <code>lhs</code>. If it's not clear what
it means for an <code>rhs</code> to be "better" than the <code>lhs</code>, e.g., in the case of the
proof for the associativity of append <code>x @ (y @ z) = (x @ y) @ z</code>, a <em>canonical</em>
form should typically be chosen (e.g., associating to the left in this case)
and kept in mind for further rules.</p>
<p>By default, the <code>lhs</code> must contain all the top-level variables of the theorem
(i.e. the arguments to the <em>lambda term</em> representing the goal). There is an
exception to this rule: if the <code>lhs</code> does not contain all the variables of the
theorem but the rule hypotheses have subterms containing the remaining free
variables, these terms can be annotated with <code>[@trigger rw]</code>, signaling Imandra
that the annotated terms should be used to complete the matching.</p>
<p>It's helpful to see an example where the use of <code>[@trigger rw]</code> is necessary.
Let's first define a <code>subset</code> function on lists:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-10" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">subset</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">true</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="n">subset</span> <span class="n">xs</span> <span class="n">y</span>
    <span class="k">else</span> <span class="bp">false</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[4]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val subset : &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-fold panel panel-default" id="fold-2d7adc0d-1a73-4277-8204-09031367954d"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>termination proof</span></div></div><div class="panel-body collapse"><div><h3>Termination proof</h3><p></p><div class="imandra-fold panel panel-default" id="fold-a7728778-3b91-4818-b848-e2129b0f21dc"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>call `subset (List.tl x) y` from `subset x y`</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-2eafa64a-031b-4e53-9f75-fb02040f8d2b"><table><tr><td><b>original</b></td><td>subset x y</td></tr><tr><td><b>sub</b></td><td>subset (List.tl x) y</td></tr><tr><td><b>original ordinal</b></td><td>Ordinal.Int (Ordinal.count x)</td></tr><tr><td><b>sub ordinal</b></td><td>Ordinal.Int (Ordinal.count (List.tl x))</td></tr><tr><td><b>path</b></td><td>[List.mem (List.hd x) y &amp;&amp; not (x = [])]</td></tr><tr><td><b>proof</b></td><td><div class="imandra-fold panel panel-default" id="fold-f8120601-c543-47b0-9cc9-73c2b108772c"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>detailed proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-4ebda62b-a621-4826-843e-700f314d250c"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-d8c96824-7c54-4f61-be8e-73da1cbd61aa"><table><tr><td><b>ground_instances</b></td><td>4</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.016s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-cfc32947-eccb-4922-b168-770791fc5f11"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-4a50ba64-3fdc-4568-96cd-61a41a668c1d"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-6860824b-8073-4ee9-919d-2a81391bd545"><table><tr><td><b>num checks</b></td><td>9</td></tr><tr><td><b>arith-make-feasible</b></td><td>11</td></tr><tr><td><b>arith-max-columns</b></td><td>13</td></tr><tr><td><b>arith-conflicts</b></td><td>1</td></tr><tr><td><b>rlimit count</b></td><td>2579</td></tr><tr><td><b>mk clause</b></td><td>5</td></tr><tr><td><b>datatype occurs check</b></td><td>41</td></tr><tr><td><b>mk bool var</b></td><td>68</td></tr><tr><td><b>arith-lower</b></td><td>4</td></tr><tr><td><b>datatype splits</b></td><td>7</td></tr><tr><td><b>decisions</b></td><td>24</td></tr><tr><td><b>propagations</b></td><td>6</td></tr><tr><td><b>arith-max-rows</b></td><td>5</td></tr><tr><td><b>conflicts</b></td><td>9</td></tr><tr><td><b>datatype accessor ax</b></td><td>6</td></tr><tr><td><b>datatype constructor ax</b></td><td>15</td></tr><tr><td><b>num allocs</b></td><td>2349873516</td></tr><tr><td><b>final checks</b></td><td>10</td></tr><tr><td><b>added eqs</b></td><td>51</td></tr><tr><td><b>del clause</b></td><td>1</td></tr><tr><td><b>arith eq adapter</b></td><td>3</td></tr><tr><td><b>arith-upper</b></td><td>6</td></tr><tr><td><b>memory</b></td><td>33.380000</td></tr><tr><td><b>max memory</b></td><td>55.250000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-cfc32947-eccb-4922-b168-770791fc5f11';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-19e1dd68-74fc-4732-b67f-44b7dfa353eb"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.016s]
  let (_x_0 : int) = Ordinal.count x in
  let (_x_1 : ty_0 list) = List.tl x in
  let (_x_2 : int) = Ordinal.count _x_1 in
  List.mem (List.hd x) y &amp;&amp; not (x = []) &amp;&amp; _x_0 &gt;= 0 &amp;&amp; _x_2 &gt;= 0
  ==&gt; not (List.mem (List.hd _x_1) y &amp;&amp; not (_x_1 = []))
      || Ordinal.( &lt;&lt; ) (Ordinal.Int _x_2) (Ordinal.Int _x_0)</pre></li><li><div><h5>simplify</h5><div class="imandra-table" id="table-ef164f19-0d84-4ef6-be72-12481a016853"><table><tr><td><b>into</b></td><td><pre>let (_x_0 : ty_0 list) = List.tl x in
let (_x_1 : int) = Ordinal.count _x_0 in
let (_x_2 : int) = Ordinal.count x in
(not (List.mem (List.hd _x_0) y &amp;&amp; not (_x_0 = []))
 || Ordinal.( &lt;&lt; ) (Ordinal.Int _x_1) (Ordinal.Int _x_2))
|| not (((List.mem (List.hd x) y &amp;&amp; not (x = [])) &amp;&amp; _x_2 &gt;= 0) &amp;&amp; _x_1 &gt;= 0)</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-1cea8ed5-3154-485c-bd8a-c3ae6a852805"><table><tr><td><b>expr</b></td><td><pre>(|List.mem_2734| (|get.::.0_2727| x_2739) y_2740)</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-351b326b-f440-4fe4-bd0d-63661221c523"><table><tr><td><b>expr</b></td><td><pre>(|count_`ty_0 list`_2750| x_2739)</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-fbbfa34e-6a2d-43da-b743-e56be0c83568"><table><tr><td><b>expr</b></td><td><pre>(|count_`ty_0 list`_2750| (|get.::.1_2728| x_2739))</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-43907744-05fa-4728-98c4-3674298308f9"><table><tr><td><b>expr</b></td><td><pre>(|Ordinal.&lt;&lt;_102| (|Ordinal.Int_93| (|count_`ty_0 list`_2750|
                                      …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li>Unsat</li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-19e1dd68-74fc-4732-b67f-44b7dfa353eb';
  fold.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-4ebda62b-a621-4826-843e-700f314d250c';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-f8120601-c543-47b0-9cc9-73c2b108772c';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-a7728778-3b91-4818-b848-e2129b0f21dc';
  fold.hydrate(target);
});
</script></div><p></p></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-2d7adc0d-1a73-4277-8204-09031367954d';
  fold.hydrate(target);
});
</script></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let's now suppose that we want to verify the transitivity of <code>subset</code>:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-12" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="o">#</span><span class="n">max_induct</span> <span class="mi">1</span><span class="o">;;</span>
<span class="n">verify</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="n">subset</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">subset</span> <span class="n">y</span> <span class="n">z</span> <span class="o">==&gt;</span> <span class="n">subset</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">[@@</span><span class="n">auto</span><span class="o">]</span>
<span class="o">#</span><span class="n">max_induct</span> <span class="mi">3</span><span class="o">;;</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[5]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : &#39;a list -&gt; &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

subset x y &amp;&amp; subset y z ==&gt; subset x z.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. subset x y
 H1. subset y z
|---------------------------------------------------------------------------
 subset x z


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (not (List.mem (List.hd x) z &amp;&amp; not (x = [])) ==&gt; φ x y z)
 &amp;&amp; (not (x = []) &amp;&amp; List.mem (List.hd x) z &amp;&amp; φ (List.tl x) y z
     ==&gt; φ x y z).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. subset x y
 H1. subset y z
|---------------------------------------------------------------------------
 C0. subset x z
 C1. List.mem (List.hd x) z &amp;&amp; not (x = [])

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span> to:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2&#39;</span>:

 H0. subset x y
 H1. subset y z
 H2. x &lt;&gt; []
|---------------------------------------------------------------------------
 List.mem (List.hd x) z


We can eliminate destructors by the following substitution:
 x -&gt; x1 :: x2

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2&#39;&#39;</span>:

 H0. subset (x1 :: x2) y
 H1. subset y z
|---------------------------------------------------------------------------
 List.mem x1 z

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span> to:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2&#39;&#39;&#39;</span>:

 H0. subset y z
 H1. List.mem x1 y
 H2. subset x2 y
|---------------------------------------------------------------------------
 List.mem x1 z


Must try induction.

<span class="ansi-red-intense-fg ansi-bold"> ⚠ </span> Aborting proof attempt for <span class="ansi-white-intense-fg ansi-bold">_verify_target</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def subset)
    (:induct subset)

<span class="ansi-cyan-intense-fg ansi-bold">Checkpoints</span>:

 H0. subset y z
 H1. List.mem x1 y
 H2. subset x2 y
<span class="ansi-white-fg">|---------------------------------------------------------------------------</span>
 List.mem x1 z

<span class="ansi-red-intense-fg ansi-bold">Error</span>[/server]: Maximum induction depth reached (1). You can set this with #max_induct.
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>It looks like Imandra needs an additional lemma in order to prove this. By
inspecting the checkpoint, it looks like all we need is a rule relating <code>subset</code>
and <code>List.mem</code>. Let's attempt to prove it:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-14" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">mem_subset</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">subset</span> <span class="n">y</span> <span class="n">z</span> <span class="o">==&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">z</span>
<span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">rewrite</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[6]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val mem_subset : &#39;a -&gt; &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

List.mem x y &amp;&amp; subset y z ==&gt; List.mem x z.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. List.mem x y
 H1. subset y z
|---------------------------------------------------------------------------
 List.mem x z


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 2.

Only 1 of those schemes are unflawed.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (not (List.mem (List.hd y) z &amp;&amp; not (y = [])) ==&gt; φ x y z)
 &amp;&amp; (not (y = []) &amp;&amp; List.mem (List.hd y) z &amp;&amp; φ x (List.tl y) z
     ==&gt; φ x y z).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. List.mem x y
 H1. subset y z
|---------------------------------------------------------------------------
 C0. List.mem (List.hd y) z &amp;&amp; not (y = [])
 C1. List.mem x z

This simplifies to the following 2 subgoals:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.2</span>:

 H0. List.mem x y
 H1. subset y z
|---------------------------------------------------------------------------
 C0. List.mem (List.hd y) z
 C1. List.mem x z

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.1</span>:

 H0. y = []
 H1. List.mem x y
 H2. subset y z
 H3. List.mem (List.hd y) z
|---------------------------------------------------------------------------
 List.mem x z

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. List.mem x y
 H1. subset y z
 H2. not (y = [])
 H3. List.mem (List.hd y) z
 H4. List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z ==&gt; List.mem x z
|---------------------------------------------------------------------------
 List.mem x z

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def List.mem)
    (:def subset)
    (:induct subset)

File &#34;jupyter cell 6&#34;, line 1, characters 0-91<span class="ansi-red-intense-fg ansi-bold">Error</span>: in rewrite rule,
variable (y : &#39;a list) does not occur in left-hand side of the rule
or in `[@trigger rw]` terms
See https://docs.imandra.ai/imandra-docs/notebooks/verification-simplification/#Rewrite-Rules
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-76385a94-604c-4da9-84b0-796f51bd8f90"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-3b75e593-c943-4ae4-8907-e1f02c553254"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-9e5e2162-a156-402d-8f6a-2bdda02e0b12"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>7</td></tr><tr><td><b>inductions</b></td><td>1</td></tr><tr><td><b>search_time</b></td><td><pre>0.490s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-51d59798-ace8-4895-a7b8-b41cff95fd2c"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.490s, &quot;Goal&quot;]
  List.mem :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:
  ==&gt; List.mem :var_0: :var_2:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-0eda0ff3-c4fc-4255-a377-c91da4091e37"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(not (List.mem x y) || not (subset y z)) || List.mem x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.490s, &quot;1&quot;] (not (List.mem x y) || not (subset y z)) || List.mem x z</pre></li><li><pre>induction on (functional )
:scheme (not (List.mem (List.hd y) z &amp;&amp; not (y = [])) ==&gt; φ x y z)
        &amp;&amp; (not (y = []) &amp;&amp; List.mem (List.hd y) z &amp;&amp; φ x (List.tl y) z
            ==&gt; φ x y z)</pre></li><li><div><pre>Split (let (_x_0 : bool) = List.mem (List.hd y) z in
       let (_x_1 : bool) = not (y = []) in
       let (_x_2 : bool) = not (List.mem x y) in
       let (_x_3 : bool) = not (subset y z) in
       let (_x_4 : bool) = List.mem x z in
       let (_x_5 : sko_ty_0 list) = List.tl y in
       (((_x_0 &amp;&amp; _x_1 || _x_2) || _x_3) || _x_4)
       &amp;&amp; (((_x_2 || _x_3) || _x_4)
           || not
              ((_x_1 &amp;&amp; _x_0)
               &amp;&amp; ((_x_4 || not (List.mem x _x_5)) || not (subset _x_5 z))))
       :cases [((not (List.mem x y) || not (subset y z))
                || List.mem (List.hd y) z &amp;&amp; not (y = []))
               || List.mem x z;
               let (_x_0 : sko_ty_0 list) = List.tl y in
               let (_x_1 : bool) = List.mem x z in
               ((((not (List.mem x y) || not (subset y z)) || y = [])
                 || not (List.mem (List.hd y) z))
                || not (List.mem x _x_0 &amp;&amp; subset _x_0 z ==&gt; _x_1))
               || _x_1])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-cc69716c-123b-4594-b608-685e9b551e3a"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>let (_x_0 : sko_ty_0 list) = List.tl y in
let (_x_1 : bool) = List.mem x z in
((((not (List.mem x y) || not (subset y z)) || y = [])
  || not (List.mem (List.hd y) z))
 || not (List.mem x _x_0 &amp;&amp; subset _x_0 z ==&gt; _x_1))
|| _x_1</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.369s, &quot;1.1&quot;]
  let (_x_0 : sko_ty_0 list) = List.tl y in
  let (_x_1 : bool) = List.mem x z in
  ((((not (List.mem x y) || not (subset y z)) || y = [])
    || not (List.mem (List.hd y) z))
   || not (List.mem x _x_0 &amp;&amp; subset _x_0 z ==&gt; _x_1))
  || _x_1</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-5ba6df0c-a5a1-48cb-91a0-08a51fa74c26"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[subset, List.mem, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-cc69716c-123b-4594-b608-685e9b551e3a';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-a7cacfdb-e0e2-47ee-9dd8-b1d592192839"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((not (List.mem x y) || not (subset y z))
 || List.mem (List.hd y) z &amp;&amp; not (y = []))
|| List.mem x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.369s, &quot;1.2&quot;]
  ((not (List.mem x y) || not (subset y z))
   || List.mem (List.hd y) z &amp;&amp; not (y = []))
  || List.mem x z</pre></li><li><div><div><h6>simplify</h6><div class="imandra-table" id="table-f000be78-1e35-40c6-823f-4a4d0c979131"><table><tr><td><b>into</b></td><td><pre>let (_x_0 : bool) = List.mem (List.hd y) z in
let (_x_1 : bool) = not (List.mem x y) in
let (_x_2 : bool) = not (subset y z) in
let (_x_3 : bool) = List.mem x z in
(((_x_0 || _x_1) || _x_2) || _x_3)
&amp;&amp; ((((not (y = []) || _x_1) || _x_2) || _x_3) || not _x_0)</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-a7cacfdb-e0e2-47ee-9dd8-b1d592192839';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-0eda0ff3-c4fc-4255-a377-c91da4091e37';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-51d59798-ace8-4895-a7b8-b41cff95fd2c';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-4fd23942-c822-4ff6-92ac-17d6dad8bd58"><textarea style="display: none">digraph &quot;proof&quot; {
p_395 [label=&quot;Start (List.mem :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:\l       ==\&gt; List.mem :var_0: :var_2: :name \&quot;Goal\&quot; :time 0.490s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_395 -&gt; p_393 [label=&quot;&quot;];
subgraph cluster_394 {
  color=blue;
p_393 [label=&quot;Start ((not (List.mem x y) \|\| not (subset y z)) \|\| List.mem x z :name \&quot;1\&quot;\l       :time 0.490s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_393 -&gt; p_392 [label=&quot;&quot;];
p_392 [label=&quot;Induct ((functional ),\l        :scheme (not (List.mem (List.hd y) z &amp;&amp; not (y = [])) ==\&gt; φ x y z)\l                &amp;&amp; (not (y = [])\l                    &amp;&amp; List.mem (List.hd y) z &amp;&amp; φ x (List.tl y) z\l                    ==\&gt; φ x y z))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_392 -&gt; p_391 [label=&quot;&quot;];
p_391 [label=&quot;Split (let (_x_0 : bool) = List.mem (List.hd y) z in\l       let (_x_1 : bool) = not (y = []) in\l       let (_x_2 : bool) = not (List.mem x y) in\l       let (_x_3 : bool) = not (subset y z) in\l       let (_x_4 : bool) = List.mem x z in\l       let (_x_5 : sko_ty_0 list) = List.tl y in\l       (((_x_0 &amp;&amp; _x_1 \|\| _x_2) \|\| _x_3) \|\| _x_4)\l       &amp;&amp; (((_x_2 \|\| _x_3) \|\| _x_4)\l           \|\| not\l              ((_x_1 &amp;&amp; _x_0)\l               &amp;&amp; ((_x_4 \|\| not (List.mem x _x_5)) \|\| not (subset _x_5 z))))\l       :cases [((not (List.mem x y) \|\| not (subset y z))\l                \|\| List.mem (List.hd y) z &amp;&amp; not (y = []))\l               \|\| List.mem x z;\l               let (_x_0 : sko_ty_0 list) = List.tl y in\l               let (_x_1 : bool) = List.mem x z in\l               ((((not (List.mem x y) \|\| not (subset y z)) \|\| y = [])\l                 \|\| not (List.mem (List.hd y) z))\l                \|\| not (List.mem x _x_0 &amp;&amp; subset _x_0 z ==\&gt; _x_1))\l               \|\| _x_1])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_391 -&gt; p_380 [label=&quot;&quot;];
subgraph cluster_381 {
  color=blue;
p_380 [label=&quot;Start (let (_x_0 : sko_ty_0 list) = List.tl y in\l       let (_x_1 : bool) = List.mem x z in\l       ((((not (List.mem x y) \|\| not (subset y z)) \|\| y = [])\l         \|\| not (List.mem (List.hd y) z))\l        \|\| not (List.mem x _x_0 &amp;&amp; subset _x_0 z ==\&gt; _x_1))\l       \|\| _x_1 :name \&quot;1.1\&quot; :time 0.369s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_380 -&gt; p_379 [label=&quot;&quot;];
p_379 [label=&quot;Simplify (true :expansions [subset; List.mem; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_391 -&gt; p_389 [label=&quot;&quot;];
subgraph cluster_390 {
  color=blue;
p_389 [label=&quot;Start (((not (List.mem x y) \|\| not (subset y z))\l        \|\| List.mem (List.hd y) z &amp;&amp; not (y = []))\l       \|\| List.mem x z :name \&quot;1.2\&quot; :time 0.369s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_389 -&gt; p_388 [label=&quot;&quot;];
p_388 [label=&quot;Simplify (let (_x_0 : bool) = List.mem (List.hd y) z in\l          let (_x_1 : bool) = not (List.mem x y) in\l          let (_x_2 : bool) = not (subset y z) in\l          let (_x_3 : bool) = List.mem x z in\l          (((_x_0 \|\| _x_1) \|\| _x_2) \|\| _x_3)\l          &amp;&amp; ((((not (y = []) \|\| _x_1) \|\| _x_2) \|\| _x_3) \|\| not _x_0)\l          :expansions [] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_388 -&gt; p_383 [label=&quot;&quot;];
subgraph cluster_384 {
  color=blue;
p_383 [label=&quot;Start ((((not (y = []) \|\| not (List.mem x y)) \|\| not (subset y z))\l        \|\| List.mem x z)\l       \|\| not (List.mem (List.hd y) z) :name \&quot;1.2.1\&quot; :time 0.289s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_383 -&gt; p_382 [label=&quot;&quot;];
p_382 [label=&quot;Simplify (true :expansions [List.mem; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_388 -&gt; p_386 [label=&quot;&quot;];
subgraph cluster_387 {
  color=blue;
p_386 [label=&quot;Start (((List.mem (List.hd y) z \|\| not (List.mem x y)) \|\| not (subset y z))\l       \|\| List.mem x z :name \&quot;1.2.2\&quot; :time 0.289s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_386 -&gt; p_385 [label=&quot;&quot;];
p_385 [label=&quot;Simplify (true :expansions [List.mem; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-4fd23942-c822-4ff6-92ac-17d6dad8bd58';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-3b75e593-c943-4ae4-8907-e1f02c553254';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-76385a94-604c-4da9-84b0-796f51bd8f90';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>While Imandra was successful in proving this lemma, it raised an error while
trying to turn this lemma into a rewrite rule. As Imandra tells us, this is
because the free variable <code>y</code> does not appear in the <code>lhs</code> term <code>List.mem x z</code>.
If we, however, annotate the <code>subset y z</code> term with the appropriate <code>[@trigger
rw]</code> attribute, Imandra can then successfully turn this term into a valid
rewrite rule:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-16" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">mem_subset</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">subset</span> <span class="n">y</span> <span class="n">z</span> <span class="o">[@</span><span class="n">trigger</span> <span class="n">rw</span><span class="o">])</span> <span class="o">==&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">z</span>
<span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">rewrite</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[7]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val mem_subset : &#39;a -&gt; &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

List.mem x y &amp;&amp; subset y z ==&gt; List.mem x z.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. List.mem x y
 H1. subset y z
|---------------------------------------------------------------------------
 List.mem x z


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 2.

Only 1 of those schemes are unflawed.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (not (List.mem (List.hd y) z &amp;&amp; not (y = [])) ==&gt; φ x y z)
 &amp;&amp; (not (y = []) &amp;&amp; List.mem (List.hd y) z &amp;&amp; φ x (List.tl y) z
     ==&gt; φ x y z).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. List.mem x y
 H1. subset y z
|---------------------------------------------------------------------------
 C0. List.mem (List.hd y) z &amp;&amp; not (y = [])
 C1. List.mem x z

This simplifies to the following 2 subgoals:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.2</span>:

 H0. List.mem x y
 H1. subset y z
|---------------------------------------------------------------------------
 C0. List.mem (List.hd y) z
 C1. List.mem x z

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.1</span>:

 H0. y = []
 H1. List.mem x y
 H2. subset y z
 H3. List.mem (List.hd y) z
|---------------------------------------------------------------------------
 List.mem x z

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. List.mem x y
 H1. subset y z
 H2. not (y = [])
 H3. List.mem (List.hd y) z
 H4. List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z ==&gt; List.mem x z
|---------------------------------------------------------------------------
 List.mem x z

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def List.mem)
    (:def subset)
    (:induct subset)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-80fa7e3a-a06c-44df-9b1d-a4d77108e24b"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-0cb7484a-0e3b-4151-a116-6b99abdfa4c3"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-0aeaac5f-53db-4cd5-a6df-dd8fe834782b"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>7</td></tr><tr><td><b>inductions</b></td><td>1</td></tr><tr><td><b>search_time</b></td><td><pre>0.491s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-10b13247-a3d4-4ce0-acab-705d57a55dab"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.491s, &quot;Goal&quot;]
  List.mem :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:
  ==&gt; List.mem :var_0: :var_2:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-1c7704b2-d67e-4e7b-a55a-bec1b1c27897"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(not (List.mem x y) || not (subset y z)) || List.mem x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.491s, &quot;1&quot;] (not (List.mem x y) || not (subset y z)) || List.mem x z</pre></li><li><pre>induction on (functional )
:scheme (not (List.mem (List.hd y) z &amp;&amp; not (y = [])) ==&gt; φ x y z)
        &amp;&amp; (not (y = []) &amp;&amp; List.mem (List.hd y) z &amp;&amp; φ x (List.tl y) z
            ==&gt; φ x y z)</pre></li><li><div><pre>Split (let (_x_0 : bool) = List.mem (List.hd y) z in
       let (_x_1 : bool) = not (y = []) in
       let (_x_2 : bool) = not (List.mem x y) in
       let (_x_3 : bool) = not (subset y z) in
       let (_x_4 : bool) = List.mem x z in
       let (_x_5 : sko_ty_0 list) = List.tl y in
       (((_x_0 &amp;&amp; _x_1 || _x_2) || _x_3) || _x_4)
       &amp;&amp; (((_x_2 || _x_3) || _x_4)
           || not
              ((_x_1 &amp;&amp; _x_0)
               &amp;&amp; ((_x_4 || not (List.mem x _x_5)) || not (subset _x_5 z))))
       :cases [((not (List.mem x y) || not (subset y z))
                || List.mem (List.hd y) z &amp;&amp; not (y = []))
               || List.mem x z;
               let (_x_0 : sko_ty_0 list) = List.tl y in
               let (_x_1 : bool) = List.mem x z in
               ((((not (List.mem x y) || not (subset y z)) || y = [])
                 || not (List.mem (List.hd y) z))
                || not (List.mem x _x_0 &amp;&amp; subset _x_0 z ==&gt; _x_1))
               || _x_1])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-69ae513a-d57f-4111-899f-17816c414ea5"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>let (_x_0 : sko_ty_0 list) = List.tl y in
let (_x_1 : bool) = List.mem x z in
((((not (List.mem x y) || not (subset y z)) || y = [])
  || not (List.mem (List.hd y) z))
 || not (List.mem x _x_0 &amp;&amp; subset _x_0 z ==&gt; _x_1))
|| _x_1</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.405s, &quot;1.1&quot;]
  let (_x_0 : sko_ty_0 list) = List.tl y in
  let (_x_1 : bool) = List.mem x z in
  ((((not (List.mem x y) || not (subset y z)) || y = [])
    || not (List.mem (List.hd y) z))
   || not (List.mem x _x_0 &amp;&amp; subset _x_0 z ==&gt; _x_1))
  || _x_1</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-1e0dc89c-3f05-4cbf-9bd9-81aff75688c2"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[subset, List.mem, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-69ae513a-d57f-4111-899f-17816c414ea5';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-92d9eb71-01ab-4be3-b1f5-873a106afa21"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((not (List.mem x y) || not (subset y z))
 || List.mem (List.hd y) z &amp;&amp; not (y = []))
|| List.mem x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.405s, &quot;1.2&quot;]
  ((not (List.mem x y) || not (subset y z))
   || List.mem (List.hd y) z &amp;&amp; not (y = []))
  || List.mem x z</pre></li><li><div><div><h6>simplify</h6><div class="imandra-table" id="table-a3d0c816-56d3-4f6d-b39e-e97759be508d"><table><tr><td><b>into</b></td><td><pre>let (_x_0 : bool) = List.mem (List.hd y) z in
let (_x_1 : bool) = not (List.mem x y) in
let (_x_2 : bool) = not (subset y z) in
let (_x_3 : bool) = List.mem x z in
(((_x_0 || _x_1) || _x_2) || _x_3)
&amp;&amp; ((((not (y = []) || _x_1) || _x_2) || _x_3) || not _x_0)</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-92d9eb71-01ab-4be3-b1f5-873a106afa21';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-1c7704b2-d67e-4e7b-a55a-bec1b1c27897';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-10b13247-a3d4-4ce0-acab-705d57a55dab';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-da39e685-5ed9-4f2c-b47a-bea7ea50bb90"><textarea style="display: none">digraph &quot;proof&quot; {
p_422 [label=&quot;Start (List.mem :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:\l       ==\&gt; List.mem :var_0: :var_2: :name \&quot;Goal\&quot; :time 0.491s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_422 -&gt; p_420 [label=&quot;&quot;];
subgraph cluster_421 {
  color=blue;
p_420 [label=&quot;Start ((not (List.mem x y) \|\| not (subset y z)) \|\| List.mem x z :name \&quot;1\&quot;\l       :time 0.491s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_420 -&gt; p_419 [label=&quot;&quot;];
p_419 [label=&quot;Induct ((functional ),\l        :scheme (not (List.mem (List.hd y) z &amp;&amp; not (y = [])) ==\&gt; φ x y z)\l                &amp;&amp; (not (y = [])\l                    &amp;&amp; List.mem (List.hd y) z &amp;&amp; φ x (List.tl y) z\l                    ==\&gt; φ x y z))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_419 -&gt; p_418 [label=&quot;&quot;];
p_418 [label=&quot;Split (let (_x_0 : bool) = List.mem (List.hd y) z in\l       let (_x_1 : bool) = not (y = []) in\l       let (_x_2 : bool) = not (List.mem x y) in\l       let (_x_3 : bool) = not (subset y z) in\l       let (_x_4 : bool) = List.mem x z in\l       let (_x_5 : sko_ty_0 list) = List.tl y in\l       (((_x_0 &amp;&amp; _x_1 \|\| _x_2) \|\| _x_3) \|\| _x_4)\l       &amp;&amp; (((_x_2 \|\| _x_3) \|\| _x_4)\l           \|\| not\l              ((_x_1 &amp;&amp; _x_0)\l               &amp;&amp; ((_x_4 \|\| not (List.mem x _x_5)) \|\| not (subset _x_5 z))))\l       :cases [((not (List.mem x y) \|\| not (subset y z))\l                \|\| List.mem (List.hd y) z &amp;&amp; not (y = []))\l               \|\| List.mem x z;\l               let (_x_0 : sko_ty_0 list) = List.tl y in\l               let (_x_1 : bool) = List.mem x z in\l               ((((not (List.mem x y) \|\| not (subset y z)) \|\| y = [])\l                 \|\| not (List.mem (List.hd y) z))\l                \|\| not (List.mem x _x_0 &amp;&amp; subset _x_0 z ==\&gt; _x_1))\l               \|\| _x_1])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_418 -&gt; p_407 [label=&quot;&quot;];
subgraph cluster_408 {
  color=blue;
p_407 [label=&quot;Start (let (_x_0 : sko_ty_0 list) = List.tl y in\l       let (_x_1 : bool) = List.mem x z in\l       ((((not (List.mem x y) \|\| not (subset y z)) \|\| y = [])\l         \|\| not (List.mem (List.hd y) z))\l        \|\| not (List.mem x _x_0 &amp;&amp; subset _x_0 z ==\&gt; _x_1))\l       \|\| _x_1 :name \&quot;1.1\&quot; :time 0.405s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_407 -&gt; p_406 [label=&quot;&quot;];
p_406 [label=&quot;Simplify (true :expansions [subset; List.mem; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_418 -&gt; p_416 [label=&quot;&quot;];
subgraph cluster_417 {
  color=blue;
p_416 [label=&quot;Start (((not (List.mem x y) \|\| not (subset y z))\l        \|\| List.mem (List.hd y) z &amp;&amp; not (y = []))\l       \|\| List.mem x z :name \&quot;1.2\&quot; :time 0.405s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_416 -&gt; p_415 [label=&quot;&quot;];
p_415 [label=&quot;Simplify (let (_x_0 : bool) = List.mem (List.hd y) z in\l          let (_x_1 : bool) = not (List.mem x y) in\l          let (_x_2 : bool) = not (subset y z) in\l          let (_x_3 : bool) = List.mem x z in\l          (((_x_0 \|\| _x_1) \|\| _x_2) \|\| _x_3)\l          &amp;&amp; ((((not (y = []) \|\| _x_1) \|\| _x_2) \|\| _x_3) \|\| not _x_0)\l          :expansions [] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_415 -&gt; p_410 [label=&quot;&quot;];
subgraph cluster_411 {
  color=blue;
p_410 [label=&quot;Start ((((not (y = []) \|\| not (List.mem x y)) \|\| not (subset y z))\l        \|\| List.mem x z)\l       \|\| not (List.mem (List.hd y) z) :name \&quot;1.2.1\&quot; :time 0.320s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_410 -&gt; p_409 [label=&quot;&quot;];
p_409 [label=&quot;Simplify (true :expansions [List.mem; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_415 -&gt; p_413 [label=&quot;&quot;];
subgraph cluster_414 {
  color=blue;
p_413 [label=&quot;Start (((List.mem (List.hd y) z \|\| not (List.mem x y)) \|\| not (subset y z))\l       \|\| List.mem x z :name \&quot;1.2.2\&quot; :time 0.320s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_413 -&gt; p_412 [label=&quot;&quot;];
p_412 [label=&quot;Simplify (true :expansions [List.mem; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-da39e685-5ed9-4f2c-b47a-bea7ea50bb90';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-0cb7484a-0e3b-4151-a116-6b99abdfa4c3';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-80fa7e3a-a06c-44df-9b1d-a4d77108e24b';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>And finally, let's verify that the rewrite rule can indeed match as we expect:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-18" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[8]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">verify</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="n">subset</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">subset</span> <span class="n">y</span> <span class="n">z</span> <span class="o">==&gt;</span> <span class="n">subset</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">[@@</span><span class="n">auto</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[8]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : &#39;a list -&gt; &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

subset x y &amp;&amp; subset y z ==&gt; subset x z.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. subset x y
 H1. subset y z
|---------------------------------------------------------------------------
 subset x z


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (not (List.mem (List.hd x) z &amp;&amp; not (x = [])) ==&gt; φ x y z)
 &amp;&amp; (not (x = []) &amp;&amp; List.mem (List.hd x) z &amp;&amp; φ (List.tl x) y z
     ==&gt; φ x y z).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. subset x y
 H1. subset y z
|---------------------------------------------------------------------------
 C0. subset x z
 C1. List.mem (List.hd x) z &amp;&amp; not (x = [])

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span> to:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2&#39;</span>:

 H0. subset x y
 H1. subset y z
 H2. x &lt;&gt; []
|---------------------------------------------------------------------------
 List.mem (List.hd x) z

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">List.mem</span>,
and the rewrite rule <span class="ansi-magenta-intense-fg ansi-bold">mem_subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (x = [])
 H1. List.mem (List.hd x) z
 H2. subset (List.tl x) y &amp;&amp; subset y z ==&gt; subset (List.tl x) z
 H3. subset x y
 H4. subset y z
|---------------------------------------------------------------------------
 subset x z

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def List.mem)
    (:def subset)
    (:rw mem_subset)
    (:induct subset)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-c0d08795-9947-49c6-b50f-f4329f82c704"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-a4c50318-48dc-41f9-8abf-9183a97c59b5"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-26ad2043-a1ea-4b39-aaa3-bc9f6d13846d"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>5</td></tr><tr><td><b>inductions</b></td><td>1</td></tr><tr><td><b>search_time</b></td><td><pre>0.662s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-5a144991-0294-4357-92cb-b0af3a47bd6b"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.662s, &quot;Goal&quot;]
  subset :var_0: :var_1: &amp;&amp; subset :var_1: :var_2: ==&gt; subset :var_0: :var_2:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-7775da8a-3189-4332-92ee-5bb5ec946f86"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(not (subset x y) || not (subset y z)) || subset x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.662s, &quot;1&quot;] (not (subset x y) || not (subset y z)) || subset x z</pre></li><li><pre>induction on (functional )
:scheme (not (List.mem (List.hd x) z &amp;&amp; not (x = [])) ==&gt; φ x y z)
        &amp;&amp; (not (x = []) &amp;&amp; List.mem (List.hd x) z &amp;&amp; φ (List.tl x) y z
            ==&gt; φ x y z)</pre></li><li><div><pre>Split (let (_x_0 : bool) = not (subset x y) in
       let (_x_1 : bool) = not (subset y z) in
       let (_x_2 : bool) = subset x z in
       let (_x_3 : bool) = List.mem (List.hd x) z in
       let (_x_4 : bool) = not (x = []) in
       let (_x_5 : sko_ty_0 list) = List.tl x in
       (((_x_0 || _x_1) || _x_2) || _x_3 &amp;&amp; _x_4)
       &amp;&amp; (((not
             ((_x_4 &amp;&amp; _x_3)
              &amp;&amp; ((not (subset _x_5 y) || subset _x_5 z) || _x_1))
             || _x_0)
            || _x_1)
           || _x_2)
       :cases [((not (subset x y) || not (subset y z)) || subset x z)
               || List.mem (List.hd x) z &amp;&amp; not (x = []);
               let (_x_0 : sko_ty_0 list) = List.tl x in
               let (_x_1 : bool) = subset y z in
               ((((x = [] || not (List.mem (List.hd x) z))
                  || not (subset _x_0 y &amp;&amp; _x_1 ==&gt; subset _x_0 z))
                 || not (subset x y))
                || not _x_1)
               || subset x z])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-cfbb13a7-123f-40c0-9f26-d0756477adef"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>let (_x_0 : sko_ty_0 list) = List.tl x in
let (_x_1 : bool) = subset y z in
((((x = [] || not (List.mem (List.hd x) z))
   || not (subset _x_0 y &amp;&amp; _x_1 ==&gt; subset _x_0 z))
  || not (subset x y))
 || not _x_1)
|| subset x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.465s, &quot;1.1&quot;]
  let (_x_0 : sko_ty_0 list) = List.tl x in
  let (_x_1 : bool) = subset y z in
  ((((x = [] || not (List.mem (List.hd x) z))
     || not (subset _x_0 y &amp;&amp; _x_1 ==&gt; subset _x_0 z))
    || not (subset x y))
   || not _x_1)
  || subset x z</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-11dc6b46-75d5-4ab3-9033-f49cefa06556"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[subset, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-cfbb13a7-123f-40c0-9f26-d0756477adef';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-c8f0dfe2-7dbc-4912-90f7-f0495b7edee2"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((not (subset x y) || not (subset y z)) || subset x z)
|| List.mem (List.hd x) z &amp;&amp; not (x = [])</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.465s, &quot;1.2&quot;]
  ((not (subset x y) || not (subset y z)) || subset x z)
  || List.mem (List.hd x) z &amp;&amp; not (x = [])</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-60b12212-dae7-4671-ae82-739c817938a9"><table><tr><td><b>into</b></td><td><pre>((List.mem (List.hd x) z || not (subset x y)) || not (subset y z)) || x = []</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[subset, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-8d40b74c-88e6-44ab-8f04-d829c13f863f"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>List.mem</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul><li><pre>mem_subset</pre></li><li><pre>mem_subset</pre></li></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-c8f0dfe2-7dbc-4912-90f7-f0495b7edee2';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-7775da8a-3189-4332-92ee-5bb5ec946f86';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-5a144991-0294-4357-92cb-b0af3a47bd6b';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-2770c0d7-853f-457e-89ea-20291addb56e"><textarea style="display: none">digraph &quot;proof&quot; {
p_444 [label=&quot;Start (subset :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:\l       ==\&gt; subset :var_0: :var_2: :name \&quot;Goal\&quot; :time 0.662s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_444 -&gt; p_442 [label=&quot;&quot;];
subgraph cluster_443 {
  color=blue;
p_442 [label=&quot;Start ((not (subset x y) \|\| not (subset y z)) \|\| subset x z :name \&quot;1\&quot;\l       :time 0.662s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_442 -&gt; p_441 [label=&quot;&quot;];
p_441 [label=&quot;Induct ((functional ),\l        :scheme (not (List.mem (List.hd x) z &amp;&amp; not (x = [])) ==\&gt; φ x y z)\l                &amp;&amp; (not (x = [])\l                    &amp;&amp; List.mem (List.hd x) z &amp;&amp; φ (List.tl x) y z\l                    ==\&gt; φ x y z))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_441 -&gt; p_440 [label=&quot;&quot;];
p_440 [label=&quot;Split (let (_x_0 : bool) = not (subset x y) in\l       let (_x_1 : bool) = not (subset y z) in\l       let (_x_2 : bool) = subset x z in\l       let (_x_3 : bool) = List.mem (List.hd x) z in\l       let (_x_4 : bool) = not (x = []) in\l       let (_x_5 : sko_ty_0 list) = List.tl x in\l       (((_x_0 \|\| _x_1) \|\| _x_2) \|\| _x_3 &amp;&amp; _x_4)\l       &amp;&amp; (((not\l             ((_x_4 &amp;&amp; _x_3)\l              &amp;&amp; ((not (subset _x_5 y) \|\| subset _x_5 z) \|\| _x_1))\l             \|\| _x_0)\l            \|\| _x_1)\l           \|\| _x_2)\l       :cases [((not (subset x y) \|\| not (subset y z)) \|\| subset x z)\l               \|\| List.mem (List.hd x) z &amp;&amp; not (x = []);\l               let (_x_0 : sko_ty_0 list) = List.tl x in\l               let (_x_1 : bool) = subset y z in\l               ((((x = [] \|\| not (List.mem (List.hd x) z))\l                  \|\| not (subset _x_0 y &amp;&amp; _x_1 ==\&gt; subset _x_0 z))\l                 \|\| not (subset x y))\l                \|\| not _x_1)\l               \|\| subset x z])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_440 -&gt; p_434 [label=&quot;&quot;];
subgraph cluster_435 {
  color=blue;
p_434 [label=&quot;Start (let (_x_0 : sko_ty_0 list) = List.tl x in\l       let (_x_1 : bool) = subset y z in\l       ((((x = [] \|\| not (List.mem (List.hd x) z))\l          \|\| not (subset _x_0 y &amp;&amp; _x_1 ==\&gt; subset _x_0 z))\l         \|\| not (subset x y))\l        \|\| not _x_1)\l       \|\| subset x z :name \&quot;1.1\&quot; :time 0.465s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_434 -&gt; p_433 [label=&quot;&quot;];
p_433 [label=&quot;Simplify (true :expansions [subset; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_440 -&gt; p_438 [label=&quot;&quot;];
subgraph cluster_439 {
  color=blue;
p_438 [label=&quot;Start (((not (subset x y) \|\| not (subset y z)) \|\| subset x z)\l       \|\| List.mem (List.hd x) z &amp;&amp; not (x = []) :name \&quot;1.2\&quot; :time 0.465s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_438 -&gt; p_437 [label=&quot;&quot;];
p_437 [label=&quot;Simplify (((List.mem (List.hd x) z \|\| not (subset x y)) \|\| not (subset y z))\l          \|\| x = [] :expansions [subset; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_437 -&gt; p_436 [label=&quot;&quot;];
p_436 [label=&quot;Simplify (true :expansions [List.mem] :rw [mem_subset; mem_subset] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-2770c0d7-853f-457e-89ea-20291addb56e';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-a4c50318-48dc-41f9-8abf-9183a97c59b5';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-c0d08795-9947-49c6-b50f-f4329f82c704';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Permutative-Restriction">Permutative Restriction<a class="anchor-link" href="#Permutative-Restriction">&#182;</a></h3><p>The <code>@@permutative</code> annotation applies only to rewrite rules and is used to
restrict the rule so that it will only apply if the instantiated <code>rhs</code> is
lexicographically smaller than the matched <code>lhs</code>. This restriction can be
particularly useful in order to break out of infinite rewrite loops while trying
to "canonicalize" a form, for example distributing the "simplest" terms to the
left.</p>
<p>Let's say we want to prove the commutativity of <code>Peano_nat.plus</code> and install it as
a rewrite rule:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-20" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[9]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">comm_plus</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
  <span class="nn">Peano_nat</span><span class="p">.</span><span class="o">(</span><span class="n">plus</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">plus</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
 <span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">rw</span><span class="o">]</span> <span class="o">[@@</span><span class="n">permutative</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[9]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val comm_plus : Peano_nat.t -&gt; Peano_nat.t -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

Peano_nat.( = ) (Peano_nat.plus x y) (Peano_nat.plus y x).

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

|---------------------------------------------------------------------------
 Peano_nat.plus x y = Peano_nat.plus y x


Must try induction.

The recursive terms in the conjecture suggest 2 inductions.

As we have backtracked, we break ties by purity.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (x = Peano_nat.Z ==&gt; φ x y)
 &amp;&amp; (not (x = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, x)) y ==&gt; φ x y).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. x = Peano_nat.Z
|---------------------------------------------------------------------------
 Peano_nat.plus x y = Peano_nat.plus y x

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span> to:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2&#39;</span>:

|---------------------------------------------------------------------------
 y = Peano_nat.plus y Peano_nat.Z


Must try induction.

We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (y = Peano_nat.Z ==&gt; φ y)
 &amp;&amp; (not (y = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, y)) ==&gt; φ y).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2&#39;.2</span>:

 H0. y = Peano_nat.Z
|---------------------------------------------------------------------------
 y = Peano_nat.plus y Peano_nat.Z

But simplification reduces this to true, using the definition of
<span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2&#39;.1</span>:

 H0. not (y = Peano_nat.Z)
 H1. Destruct(Peano_nat.S, 0, y) =
     Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) Peano_nat.Z
|---------------------------------------------------------------------------
 y = Peano_nat.plus y Peano_nat.Z

But simplification reduces this to true, using the definition of
<span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (x = Peano_nat.Z)
 H1. Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) y =
     Peano_nat.plus y (Destruct(Peano_nat.S, 0, x))
|---------------------------------------------------------------------------
 Peano_nat.plus x y = Peano_nat.plus y x

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span> to:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;</span>:

 H0. Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) y =
     Peano_nat.plus y (Destruct(Peano_nat.S, 0, x))
|---------------------------------------------------------------------------
 C0. x = Peano_nat.Z
 C1. Peano_nat.S (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) y) =
     Peano_nat.plus y x


We can eliminate destructors by the following
substitution:
 x -&gt; Peano_nat.S x1

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;</span>:

 H0. Peano_nat.plus x1 y = Peano_nat.plus y x1
|---------------------------------------------------------------------------
 Peano_nat.S (Peano_nat.plus x1 y) = Peano_nat.plus y (Peano_nat.S x1)


Cross-fertilizing with:

 Peano_nat.plus x1 y = Peano_nat.plus y x1

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;</span>:

|---------------------------------------------------------------------------
 Peano_nat.S (Peano_nat.plus y x1) = Peano_nat.plus y (Peano_nat.S x1)


Must try induction.

The recursive terms in the conjecture suggest 2 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (y = Peano_nat.Z ==&gt; φ x1 y)
 &amp;&amp; (not (y = Peano_nat.Z) &amp;&amp; φ x1 (Destruct(Peano_nat.S, 0, y)) ==&gt; φ x1 y).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;.2</span>:

 H0. y = Peano_nat.Z
|---------------------------------------------------------------------------
 Peano_nat.S (Peano_nat.plus y x1) = Peano_nat.plus y (Peano_nat.S x1)

But simplification reduces this to true, using the definition of
<span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;.1</span>:

 H0. not (y = Peano_nat.Z)
 H1. Peano_nat.S (Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x1) =
     Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) (Peano_nat.S x1)
|---------------------------------------------------------------------------
 Peano_nat.S (Peano_nat.plus y x1) = Peano_nat.plus y (Peano_nat.S x1)

But simplification reduces this to true, using the definition of
<span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def Peano_nat.plus)
    (:induct Peano_nat.plus)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-1ea6f77b-3e85-4dac-8f6c-a46ce047b6b5"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-daf7f284-e0f5-424d-a651-3181abf9879a"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-e5a525b8-dde9-4f8c-8514-3e93a2f2cc0d"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>8</td></tr><tr><td><b>inductions</b></td><td>3</td></tr><tr><td><b>search_time</b></td><td><pre>0.762s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-54093d65-7f32-478c-b0b8-8e9d66d899fc"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.762s, &quot;Goal&quot;]
  Peano_nat.plus :var_0: :var_1: = Peano_nat.plus :var_1: :var_0:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-905df691-a421-418a-b95c-61c4901f1160"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Peano_nat.plus x y = Peano_nat.plus y x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.762s, &quot;1&quot;] Peano_nat.plus x y = Peano_nat.plus y x</pre></li><li><pre>induction on (functional )
:scheme (x = Peano_nat.Z ==&gt; φ x y)
        &amp;&amp; (not (x = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, x)) y
            ==&gt; φ x y)</pre></li><li><div><pre>Split (let (_x_0 : bool) = not (x = Peano_nat.Z) in
       let (_x_1 : bool) = Peano_nat.plus x y = Peano_nat.plus y x in
       let (_x_2 : Peano_nat.t) = Destruct(Peano_nat.S, 0, x) in
       (_x_0 || _x_1)
       &amp;&amp; (not (_x_0 &amp;&amp; Peano_nat.plus _x_2 y = Peano_nat.plus y _x_2)
           || _x_1)
       :cases [not (x = Peano_nat.Z)
               || Peano_nat.plus x y = Peano_nat.plus y x;
               let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, x) in
               (x = Peano_nat.Z
                || not (Peano_nat.plus _x_0 y = Peano_nat.plus y _x_0))
               || Peano_nat.plus x y = Peano_nat.plus y x])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-540de44c-4302-4de2-af42-912c568c4104"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, x) in
(x = Peano_nat.Z || not (Peano_nat.plus _x_0 y = Peano_nat.plus y _x_0))
|| Peano_nat.plus x y = Peano_nat.plus y x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.682s, &quot;1.1&quot;]
  let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, x) in
  (x = Peano_nat.Z || not (Peano_nat.plus _x_0 y = Peano_nat.plus y _x_0))
  || Peano_nat.plus x y = Peano_nat.plus y x</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-71cae65d-c0dd-4409-acc0-a2cc4e47ffa3"><table><tr><td><b>into</b></td><td><pre>let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, x) in
let (_x_1 : Peano_nat.t) = Peano_nat.plus _x_0 y in
(x = Peano_nat.Z || not (_x_1 = Peano_nat.plus y _x_0))
|| Peano_nat.S _x_1 = Peano_nat.plus y x</pre></td></tr><tr><td><b>expansions</b></td><td><pre>Peano_nat.plus</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><pre>Elim_destructor (:cstor Peano_nat.S :replace Peano_nat.S x1 :context [])</pre></li><li><pre>induction on (functional )
:scheme (y = Peano_nat.Z ==&gt; φ x1 y)
        &amp;&amp; (not (y = Peano_nat.Z) &amp;&amp; φ x1 (Destruct(Peano_nat.S, 0, y))
            ==&gt; φ x1 y)</pre></li><li><div><pre>Split (let (_x_0 : bool) = not (y = Peano_nat.Z) in
       let (_x_1 : Peano_nat.t) = Peano_nat.S x1 in
       let (_x_2 : bool)
           = Peano_nat.S (Peano_nat.plus y x1) = Peano_nat.plus y _x_1
       in
       let (_x_3 : Peano_nat.t) = Destruct(Peano_nat.S, 0, y) in
       (_x_0 || _x_2)
       &amp;&amp; (not
           (_x_0
            &amp;&amp; Peano_nat.S (Peano_nat.plus _x_3 x1) =
               Peano_nat.plus _x_3 _x_1)
           || _x_2)
       :cases [not (y = Peano_nat.Z)
               || Peano_nat.S (Peano_nat.plus y x1) =
                  Peano_nat.plus y (Peano_nat.S x1);
               let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, y) in
               let (_x_1 : Peano_nat.t) = Peano_nat.S x1 in
               (y = Peano_nat.Z
                || not
                   (Peano_nat.S (Peano_nat.plus _x_0 x1) =
                    Peano_nat.plus _x_0 _x_1))
               || Peano_nat.S (Peano_nat.plus y x1) = Peano_nat.plus y _x_1])</pre><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-540de44c-4302-4de2-af42-912c568c4104';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-8b03604b-38c2-4e7f-b15f-fe41d1a82da9"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>not (x = Peano_nat.Z) || Peano_nat.plus x y = Peano_nat.plus y x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.682s, &quot;1.2&quot;]
  not (x = Peano_nat.Z) || Peano_nat.plus x y = Peano_nat.plus y x</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-c4acc5d5-59dc-4c1c-9983-82a3d1f8ea8f"><table><tr><td><b>into</b></td><td><pre>y = Peano_nat.plus y Peano_nat.Z</pre></td></tr><tr><td><b>expansions</b></td><td><pre>Peano_nat.plus</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><pre>induction on (functional )
:scheme (y = Peano_nat.Z ==&gt; φ y)
        &amp;&amp; (not (y = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, y))
            ==&gt; φ y)</pre></li><li><div><pre>Split (let (_x_0 : bool) = not (y = Peano_nat.Z) in
       let (_x_1 : bool) = y = Peano_nat.plus y Peano_nat.Z in
       let (_x_2 : Peano_nat.t) = Destruct(Peano_nat.S, 0, y) in
       (_x_0 || _x_1)
       &amp;&amp; (not (_x_0 &amp;&amp; _x_2 = Peano_nat.plus _x_2 Peano_nat.Z) || _x_1)
       :cases [not (y = Peano_nat.Z) || y = Peano_nat.plus y Peano_nat.Z;
               let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, y) in
               (y = Peano_nat.Z
                || not (_x_0 = Peano_nat.plus _x_0 Peano_nat.Z))
               || y = Peano_nat.plus y Peano_nat.Z])</pre><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-8b03604b-38c2-4e7f-b15f-fe41d1a82da9';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-905df691-a421-418a-b95c-61c4901f1160';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-54093d65-7f32-478c-b0b8-8e9d66d899fc';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-852cee5c-7b7d-4df9-9ef5-74dca9fb59ae"><textarea style="display: none">digraph &quot;proof&quot; {
p_518 [label=&quot;Start (Peano_nat.plus :var_0: :var_1: = Peano_nat.plus :var_1: :var_0:\l       :name \&quot;Goal\&quot; :time 0.762s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_518 -&gt; p_516 [label=&quot;&quot;];
subgraph cluster_517 {
  color=blue;
p_516 [label=&quot;Start (Peano_nat.plus x y = Peano_nat.plus y x :name \&quot;1\&quot; :time 0.762s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_516 -&gt; p_515 [label=&quot;&quot;];
p_515 [label=&quot;Induct ((functional ),\l        :scheme (x = Peano_nat.Z ==\&gt; φ x y)\l                &amp;&amp; (not (x = Peano_nat.Z)\l                    &amp;&amp; φ (Destruct(Peano_nat.S, 0, x)) y ==\&gt; φ x y))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_515 -&gt; p_514 [label=&quot;&quot;];
p_514 [label=&quot;Split (let (_x_0 : bool) = not (x = Peano_nat.Z) in\l       let (_x_1 : bool) = Peano_nat.plus x y = Peano_nat.plus y x in\l       let (_x_2 : Peano_nat.t) = Destruct(Peano_nat.S, 0, x) in\l       (_x_0 \|\| _x_1)\l       &amp;&amp; (not (_x_0 &amp;&amp; Peano_nat.plus _x_2 y = Peano_nat.plus y _x_2)\l           \|\| _x_1)\l       :cases [not (x = Peano_nat.Z)\l               \|\| Peano_nat.plus x y = Peano_nat.plus y x;\l               let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, x) in\l               (x = Peano_nat.Z\l                \|\| not (Peano_nat.plus _x_0 y = Peano_nat.plus y _x_0))\l               \|\| Peano_nat.plus x y = Peano_nat.plus y x])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_514 -&gt; p_501 [label=&quot;&quot;];
subgraph cluster_502 {
  color=blue;
p_501 [label=&quot;Start (let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, x) in\l       (x = Peano_nat.Z\l        \|\| not (Peano_nat.plus _x_0 y = Peano_nat.plus y _x_0))\l       \|\| Peano_nat.plus x y = Peano_nat.plus y x :name \&quot;1.1\&quot; :time 0.682s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_501 -&gt; p_500 [label=&quot;&quot;];
p_500 [label=&quot;Simplify (let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, x) in\l          let (_x_1 : Peano_nat.t) = Peano_nat.plus _x_0 y in\l          (x = Peano_nat.Z \|\| not (_x_1 = Peano_nat.plus y _x_0))\l          \|\| Peano_nat.S _x_1 = Peano_nat.plus y x\l          :expansions [Peano_nat.plus] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_500 -&gt; p_499 [label=&quot;&quot;];
p_499 [label=&quot;Elim_destructor (:cstor Peano_nat.S :replace Peano_nat.S x1 :context [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_499 -&gt; p_498 [label=&quot;&quot;];
p_498 [label=&quot;Induct ((functional ),\l        :scheme (y = Peano_nat.Z ==\&gt; φ x1 y)\l                &amp;&amp; (not (y = Peano_nat.Z)\l                    &amp;&amp; φ x1 (Destruct(Peano_nat.S, 0, y)) ==\&gt; φ x1 y))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_498 -&gt; p_497 [label=&quot;&quot;];
p_497 [label=&quot;Split (let (_x_0 : bool) = not (y = Peano_nat.Z) in\l       let (_x_1 : Peano_nat.t) = Peano_nat.S x1 in\l       let (_x_2 : bool)\l           = Peano_nat.S (Peano_nat.plus y x1) = Peano_nat.plus y _x_1\l       in\l       let (_x_3 : Peano_nat.t) = Destruct(Peano_nat.S, 0, y) in\l       (_x_0 \|\| _x_2)\l       &amp;&amp; (not\l           (_x_0\l            &amp;&amp; Peano_nat.S (Peano_nat.plus _x_3 x1) =\l               Peano_nat.plus _x_3 _x_1)\l           \|\| _x_2)\l       :cases [not (y = Peano_nat.Z)\l               \|\| Peano_nat.S (Peano_nat.plus y x1) =\l                  Peano_nat.plus y (Peano_nat.S x1);\l               let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, y) in\l               let (_x_1 : Peano_nat.t) = Peano_nat.S x1 in\l               (y = Peano_nat.Z\l                \|\| not\l                   (Peano_nat.S (Peano_nat.plus _x_0 x1) =\l                    Peano_nat.plus _x_0 _x_1))\l               \|\| Peano_nat.S (Peano_nat.plus y x1) = Peano_nat.plus y _x_1])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_497 -&gt; p_492 [label=&quot;&quot;];
subgraph cluster_493 {
  color=blue;
p_492 [label=&quot;Start (let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, y) in\l       let (_x_1 : Peano_nat.t) = Peano_nat.S x1 in\l       (y = Peano_nat.Z\l        \|\| not\l           (Peano_nat.S (Peano_nat.plus _x_0 x1) = Peano_nat.plus _x_0 _x_1))\l       \|\| Peano_nat.S (Peano_nat.plus y x1) = Peano_nat.plus y _x_1\l       :name \&quot;1.1'''.1\&quot; :time 0.041s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_492 -&gt; p_491 [label=&quot;&quot;];
p_491 [label=&quot;Simplify (true :expansions [Peano_nat.plus; Peano_nat.plus] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_497 -&gt; p_495 [label=&quot;&quot;];
subgraph cluster_496 {
  color=blue;
p_495 [label=&quot;Start (not (y = Peano_nat.Z)\l       \|\| Peano_nat.S (Peano_nat.plus y x1) =\l          Peano_nat.plus y (Peano_nat.S x1)\l       :name \&quot;1.1'''.2\&quot; :time 0.041s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_495 -&gt; p_494 [label=&quot;&quot;];
p_494 [label=&quot;Simplify (true :expansions [Peano_nat.plus; Peano_nat.plus] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
p_514 -&gt; p_512 [label=&quot;&quot;];
subgraph cluster_513 {
  color=blue;
p_512 [label=&quot;Start (not (x = Peano_nat.Z) \|\| Peano_nat.plus x y = Peano_nat.plus y x\l       :name \&quot;1.2\&quot; :time 0.682s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_512 -&gt; p_511 [label=&quot;&quot;];
p_511 [label=&quot;Simplify (y = Peano_nat.plus y Peano_nat.Z :expansions [Peano_nat.plus]\l          :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_511 -&gt; p_510 [label=&quot;&quot;];
p_510 [label=&quot;Induct ((functional ),\l        :scheme (y = Peano_nat.Z ==\&gt; φ y)\l                &amp;&amp; (not (y = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, y))\l                    ==\&gt; φ y))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_510 -&gt; p_509 [label=&quot;&quot;];
p_509 [label=&quot;Split (let (_x_0 : bool) = not (y = Peano_nat.Z) in\l       let (_x_1 : bool) = y = Peano_nat.plus y Peano_nat.Z in\l       let (_x_2 : Peano_nat.t) = Destruct(Peano_nat.S, 0, y) in\l       (_x_0 \|\| _x_1)\l       &amp;&amp; (not (_x_0 &amp;&amp; _x_2 = Peano_nat.plus _x_2 Peano_nat.Z) \|\| _x_1)\l       :cases [not (y = Peano_nat.Z) \|\| y = Peano_nat.plus y Peano_nat.Z;\l               let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, y) in\l               (y = Peano_nat.Z\l                \|\| not (_x_0 = Peano_nat.plus _x_0 Peano_nat.Z))\l               \|\| y = Peano_nat.plus y Peano_nat.Z])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_509 -&gt; p_504 [label=&quot;&quot;];
subgraph cluster_505 {
  color=blue;
p_504 [label=&quot;Start (let (_x_0 : Peano_nat.t) = Destruct(Peano_nat.S, 0, y) in\l       (y = Peano_nat.Z \|\| not (_x_0 = Peano_nat.plus _x_0 Peano_nat.Z))\l       \|\| y = Peano_nat.plus y Peano_nat.Z :name \&quot;1.2'.1\&quot; :time 0.608s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_504 -&gt; p_503 [label=&quot;&quot;];
p_503 [label=&quot;Simplify (true :expansions [Peano_nat.plus] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_509 -&gt; p_507 [label=&quot;&quot;];
subgraph cluster_508 {
  color=blue;
p_507 [label=&quot;Start (not (y = Peano_nat.Z) \|\| y = Peano_nat.plus y Peano_nat.Z\l       :name \&quot;1.2'.2\&quot; :time 0.608s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_507 -&gt; p_506 [label=&quot;&quot;];
p_506 [label=&quot;Simplify (true :expansions [Peano_nat.plus] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-852cee5c-7b7d-4df9-9ef5-74dca9fb59ae';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-daf7f284-e0f5-424d-a651-3181abf9879a';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-1ea6f77b-3e85-4dac-8f6c-a46ce047b6b5';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Had we not restricted <code>comm_plus</code> as a permutative rule, the simplifier would have
entered a rewrite loop every time it encountered a term matching <code>plus &lt;x&gt; &lt;y&gt;</code>,
while with the permutative restriction in place, this has the effect of directing
all the "simplest" terms to the left of <code>plus</code>, which will help with making
further rewrite rules applicable and with simplification in general.</p>
<h2 id="Forward-chaining-Rules">Forward-chaining Rules<a class="anchor-link" href="#Forward-chaining-Rules">&#182;</a></h2><p>Forward chaining is the second type of rule that Imandra allows us to register
and participate automatically in proofs.</p>
<p>A forward chaining rule is a theorem containing a collection of <em>trigger</em> terms
which must include all free variables of the theorem. If Imandra can
appropriately match the triggers with terms in the goal, then an instantiation
of the rule is added to the <em>context</em>. The context of a goal is not displayed in
the goal itself (i.e., when the goal is printed), but is rather used in the
background to aid the simplifier in closing branches, relieving hypotheses of
rewrite rules during backchaining, and so on.</p>
<p>For example, let us prove the following theorem and install it as a
forward-chaining rule:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-22" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[10]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">len_nonnegative</span> <span class="n">x</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">x</span> <span class="o">[@</span><span class="n">trigger</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="o">[@@</span><span class="n">simp</span><span class="o">]</span> <span class="o">[@@</span><span class="n">fc</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[10]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val len_nonnegative : &#39;a list -&gt; bool = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-alternatives" id="alt-a053b047-01ae-437d-84f1-9bfec9fe5533"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>proof</a></li><li class="" data-toggle="tab"><a>call graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-e8642443-6b33-4465-b308-60f60d1a6996"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-0efcc2bd-dd7e-4544-95b6-a2f04d27c1ec"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-0bc6b80d-ce14-426c-8722-418d83d85d21"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.059s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-a2594a92-e269-4f4d-b068-6a56fe2aaa49"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-990ba3c1-2d88-4338-8822-6d41bc66ef97"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-67b186d5-a337-484a-8d64-cc7a1ef9f191"><table><tr><td><b>rlimit count</b></td><td>468</td></tr><tr><td><b>mk bool var</b></td><td>1</td></tr><tr><td><b>memory</b></td><td>32.980000</td></tr><tr><td><b>max memory</b></td><td>66.980000</td></tr><tr><td><b>num allocs</b></td><td>19406225049.000000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-a2594a92-e269-4f4d-b068-6a56fe2aaa49';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-f4b47cf7-035a-4e3d-80fa-c707164b8cfd"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.059s] List.length :var_0: &gt;= 0</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-1c5a51e1-6d90-4d5d-a898-b5d0a84a8c12"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><pre>List.len_nonnegative</pre></td></tr></table></div></div></li><li>Unsat</li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-f4b47cf7-035a-4e3d-80fa-c707164b8cfd';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-58e054c2-3a94-4365-b32f-6a606a5b74dd"><textarea style="display: none">digraph &quot;proof&quot; {
p_521 [label=&quot;Start (List.length :var_0: \&gt;= 0 :time 0.059s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_521 -&gt; p_520 [label=&quot;&quot;];
p_520 [label=&quot;Simplify (true :expansions [] :rw [] :fc [List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_520 -&gt; p_519 [label=&quot;&quot;];
p_519 [label=&quot;Unsat&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-58e054c2-3a94-4365-b32f-6a606a5b74dd';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-0efcc2bd-dd7e-4544-95b6-a2f04d27c1ec';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-e8642443-6b33-4465-b308-60f60d1a6996';
  fold.hydrate(target);
});
</script></div></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-707f38b7-dcb2-43a2-ba05-670aa90129c6"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;not true&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-707f38b7-dcb2-43a2-ba05-670aa90129c6';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-a053b047-01ae-437d-84f1-9bfec9fe5533';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Now when Imandra encounters a term of the form <code>List.length &lt;term&gt;</code>, the formula
<code>List.length &lt;term&gt; &gt;= 0</code> will be added to the <em>context</em> of the goal under
focus. In other words, a forward chaining rule allows Imandra to extend the
database of background logical facts it knows about a goal. These facts are made
available to the simplifier, and can thus be used to enhance simplification by
closing branches and relieving hypotheses of conditional rewrite rules.</p>
<p>A forward chaining rule can contain multiple <em>disjoint</em> triggers. In this case, if
<em>either</em> of the triggers matches, the forward chaining rule fires. For example,
the following forward chaining version of the <code>rev_len</code> rewrite rule we added
above will fire if either <code>List.length x</code> or <code>List.length (List.rev x)</code>
matches.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-24" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[11]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">rev_len_fc</span> <span class="n">x</span> <span class="o">=</span>
   <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">x</span> <span class="o">[@</span><span class="n">trigger</span><span class="o">]</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">x</span><span class="o">)</span> <span class="o">[@</span><span class="n">trigger</span><span class="o">]</span>
<span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">fc</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[11]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val rev_len_fc : &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

List.length x = List.length (List.rev x).

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

|---------------------------------------------------------------------------
 List.length x = List.length (List.rev x)

But simplification reduces this to true, using the rewrite rule <span class="ansi-magenta-intense-fg ansi-bold">rev_len</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:rw rev_len)
    (:fc List.len_nonnegative)
    (:fc len_nonnegative)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-688dd333-f486-4a7e-beb8-6537b504bb1a"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-e01e990f-ca8e-4563-b8ca-811f4f46aea7"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-ba8c9914-9286-4335-b16c-25ab40562274"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.021s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-83eec5b5-a1e0-4177-983a-2f0bed87b03a"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.021s, &quot;Goal&quot;] List.length :var_0: = List.length (List.rev :var_0:)</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-d17badb2-c535-4c95-912f-b20fa9edc338"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>List.length x = List.length (List.rev x)</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.021s, &quot;1&quot;] List.length x = List.length (List.rev x)</pre></li><li><div><h5>simplify</h5><div class="imandra-table" id="table-8339eb29-b425-4f03-903f-e90ec9f263bc"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><pre>rev_len</pre></td></tr><tr><td><b>forward_chaining</b></td><td><ul><li><pre>List.len_nonnegative</pre></li><li><pre>len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>len_nonnegative</pre></li></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-d17badb2-c535-4c95-912f-b20fa9edc338';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-83eec5b5-a1e0-4177-983a-2f0bed87b03a';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-9750ca64-9bba-4f03-9064-c4bf035810b4"><textarea style="display: none">digraph &quot;proof&quot; {
p_525 [label=&quot;Start (List.length :var_0: = List.length (List.rev :var_0:) :name \&quot;Goal\&quot;\l       :time 0.021s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_525 -&gt; p_523 [label=&quot;&quot;];
subgraph cluster_524 {
  color=blue;
p_523 [label=&quot;Start (List.length x = List.length (List.rev x) :name \&quot;1\&quot; :time 0.021s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_523 -&gt; p_522 [label=&quot;&quot;];
p_522 [label=&quot;Simplify (true :expansions [] :rw [rev_len]\l          :fc [List.len_nonnegative;\l               len_nonnegative;\l               List.len_nonnegative;\l               len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-9750ca64-9bba-4f03-9064-c4bf035810b4';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-e01e990f-ca8e-4563-b8ca-811f4f46aea7';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-688dd333-f486-4a7e-beb8-6537b504bb1a';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Additionally, a forward chaining rule can contain multiple <em>conjoined</em> triggers,
forming a <em>trigger cluster</em>. In this case, <em>all</em> the triggers must match in
order for the forward chaining rule to apply.</p>
<p>To create a trigger cluster multiple terms must be annotated with
<code>[@trigger &lt;x&gt;i]</code>, where <code>&lt;x&gt;</code> is a numeric identifier common to all
the triggers in the cluster. For example:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-26" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[12]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">theorem</span> <span class="n">subset_trans</span> <span class="n">l1</span> <span class="n">l2</span> <span class="n">l3</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">subset</span> <span class="n">l1</span> <span class="n">l2</span> <span class="o">[@</span><span class="n">trigger</span> <span class="mi">0</span><span class="n">i</span><span class="o">])</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">subset</span> <span class="n">l2</span> <span class="n">l3</span> <span class="o">[@</span><span class="n">trigger</span> <span class="mi">0</span><span class="n">i</span><span class="o">])</span>
  <span class="o">==&gt;</span>
  <span class="n">subset</span> <span class="n">l1</span> <span class="n">l3</span>
 <span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">forward_chaining</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[12]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val subset_trans : &#39;a list -&gt; &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

subset l1 l2 &amp;&amp; subset l2 l3 ==&gt; subset l1 l3.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. subset l1 l2
 H1. subset l2 l3
|---------------------------------------------------------------------------
 subset l1 l3


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (not (List.mem (List.hd l1) l3 &amp;&amp; not (l1 = [])) ==&gt; φ l1 l2 l3)
 &amp;&amp; (not (l1 = []) &amp;&amp; List.mem (List.hd l1) l3 &amp;&amp; φ (List.tl l1) l2 l3
     ==&gt; φ l1 l2 l3).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. subset l1 l2
 H1. subset l2 l3
|---------------------------------------------------------------------------
 C0. List.mem (List.hd l1) l3 &amp;&amp; not (l1 = [])
 C1. subset l1 l3

This simplifies to the following 2 subgoals:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.2</span>:

 H0. subset l1 l2
 H1. subset l2 l3
|---------------------------------------------------------------------------
 C0. List.mem (List.hd l1) l3
 C1. subset l1 l3

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>, and the rewrite rule <span class="ansi-magenta-intense-fg ansi-bold">mem_subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.1</span>:

 H0. l1 = []
 H1. subset l1 l2
 H2. subset l2 l3
 H3. List.mem (List.hd l1) l3
|---------------------------------------------------------------------------
 subset l1 l3

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. subset l1 l2
 H1. subset l2 l3
 H2. not (l1 = [])
 H3. List.mem (List.hd l1) l3
 H4. subset l2 l3 &amp;&amp; subset (List.tl l1) l2 ==&gt; subset (List.tl l1) l3
|---------------------------------------------------------------------------
 subset l1 l3

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>, and the rewrite rule <span class="ansi-magenta-intense-fg ansi-bold">mem_subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def List.mem)
    (:def subset)
    (:rw mem_subset)
    (:induct subset)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-3596cd58-80ff-475d-964b-55381e6fbdf4"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-07bf4897-08dd-4b18-aca3-7c5d0e83ddd1"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-cfb878ce-2279-46fd-b247-c3b14abae0e5"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>8</td></tr><tr><td><b>inductions</b></td><td>1</td></tr><tr><td><b>search_time</b></td><td><pre>0.624s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-7f0caec4-a1bf-405e-ac08-e4ea8d1c3a75"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.624s, &quot;Goal&quot;]
  subset :var_0: :var_1: &amp;&amp; subset :var_1: :var_2: ==&gt; subset :var_0: :var_2:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-e4c38b4e-4f5c-4e25-b3f5-b970b3f38ffa"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(not (subset l1 l2) || not (subset l2 l3)) || subset l1 l3</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.624s, &quot;1&quot;] (not (subset l1 l2) || not (subset l2 l3)) || subset l1 l3</pre></li><li><pre>induction on (functional )
:scheme (not (List.mem (List.hd l1) l3 &amp;&amp; not (l1 = [])) ==&gt; φ l1 l2 l3)
        &amp;&amp; (not (l1 = [])
            &amp;&amp; List.mem (List.hd l1) l3 &amp;&amp; φ (List.tl l1) l2 l3
            ==&gt; φ l1 l2 l3)</pre></li><li><div><pre>Split (let (_x_0 : bool) = List.mem (List.hd l1) l3 in
       let (_x_1 : bool) = not (l1 = []) in
       let (_x_2 : bool) = not (subset l1 l2) in
       let (_x_3 : bool) = not (subset l2 l3) in
       let (_x_4 : bool) = subset l1 l3 in
       let (_x_5 : sko_ty_0 list) = List.tl l1 in
       (((_x_0 &amp;&amp; _x_1 || _x_2) || _x_3) || _x_4)
       &amp;&amp; (((_x_2 || _x_3) || _x_4)
           || not
              ((_x_1 &amp;&amp; _x_0)
               &amp;&amp; ((_x_3 || not (subset _x_5 l2)) || subset _x_5 l3)))
       :cases [((not (subset l1 l2) || not (subset l2 l3))
                || List.mem (List.hd l1) l3 &amp;&amp; not (l1 = []))
               || subset l1 l3;
               let (_x_0 : bool) = subset l2 l3 in
               let (_x_1 : sko_ty_0 list) = List.tl l1 in
               ((((not (subset l1 l2) || not _x_0) || l1 = [])
                 || not (List.mem (List.hd l1) l3))
                || not (_x_0 &amp;&amp; subset _x_1 l2 ==&gt; subset _x_1 l3))
               || subset l1 l3])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-a8af32db-1324-4d3c-950f-d3cfa266dbc0"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>let (_x_0 : bool) = subset l2 l3 in
let (_x_1 : sko_ty_0 list) = List.tl l1 in
((((not (subset l1 l2) || not _x_0) || l1 = [])
  || not (List.mem (List.hd l1) l3))
 || not (_x_0 &amp;&amp; subset _x_1 l2 ==&gt; subset _x_1 l3))
|| subset l1 l3</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.469s, &quot;1.1&quot;]
  let (_x_0 : bool) = subset l2 l3 in
  let (_x_1 : sko_ty_0 list) = List.tl l1 in
  ((((not (subset l1 l2) || not _x_0) || l1 = [])
    || not (List.mem (List.hd l1) l3))
   || not (_x_0 &amp;&amp; subset _x_1 l2 ==&gt; subset _x_1 l3))
  || subset l1 l3</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-16fd33b4-51eb-4105-b6e2-0649f03c0948"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[subset, subset, List.mem, List.mem, List.mem]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul><li><pre>mem_subset</pre></li><li><pre>mem_subset</pre></li><li><pre>mem_subset</pre></li><li><pre>mem_subset</pre></li></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-a8af32db-1324-4d3c-950f-d3cfa266dbc0';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-60204aa5-aede-4a03-8722-cc6af88d32f1"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((not (subset l1 l2) || not (subset l2 l3))
 || List.mem (List.hd l1) l3 &amp;&amp; not (l1 = []))
|| subset l1 l3</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.469s, &quot;1.2&quot;]
  ((not (subset l1 l2) || not (subset l2 l3))
   || List.mem (List.hd l1) l3 &amp;&amp; not (l1 = []))
  || subset l1 l3</pre></li><li><div><div><h6>simplify</h6><div class="imandra-table" id="table-43e2442d-8273-4994-bde7-a2aa00b5fcbd"><table><tr><td><b>into</b></td><td><pre>let (_x_0 : bool) = List.mem (List.hd l1) l3 in
let (_x_1 : bool) = not (subset l1 l2) in
let (_x_2 : bool) = not (subset l2 l3) in
let (_x_3 : bool) = subset l1 l3 in
(((_x_0 || _x_1) || _x_2) || _x_3)
&amp;&amp; ((((not (l1 = []) || _x_1) || _x_2) || _x_3) || not _x_0)</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-60204aa5-aede-4a03-8722-cc6af88d32f1';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-e4c38b4e-4f5c-4e25-b3f5-b970b3f38ffa';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-7f0caec4-a1bf-405e-ac08-e4ea8d1c3a75';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-d499718a-9da3-4572-b451-5bde4eb49a1e"><textarea style="display: none">digraph &quot;proof&quot; {
p_552 [label=&quot;Start (subset :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:\l       ==\&gt; subset :var_0: :var_2: :name \&quot;Goal\&quot; :time 0.624s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_552 -&gt; p_550 [label=&quot;&quot;];
subgraph cluster_551 {
  color=blue;
p_550 [label=&quot;Start ((not (subset l1 l2) \|\| not (subset l2 l3)) \|\| subset l1 l3 :name \&quot;1\&quot;\l       :time 0.624s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_550 -&gt; p_549 [label=&quot;&quot;];
p_549 [label=&quot;Induct ((functional ),\l        :scheme (not (List.mem (List.hd l1) l3 &amp;&amp; not (l1 = []))\l                 ==\&gt; φ l1 l2 l3)\l                &amp;&amp; (not (l1 = [])\l                    &amp;&amp; List.mem (List.hd l1) l3 &amp;&amp; φ (List.tl l1) l2 l3\l                    ==\&gt; φ l1 l2 l3))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_549 -&gt; p_548 [label=&quot;&quot;];
p_548 [label=&quot;Split (let (_x_0 : bool) = List.mem (List.hd l1) l3 in\l       let (_x_1 : bool) = not (l1 = []) in\l       let (_x_2 : bool) = not (subset l1 l2) in\l       let (_x_3 : bool) = not (subset l2 l3) in\l       let (_x_4 : bool) = subset l1 l3 in\l       let (_x_5 : sko_ty_0 list) = List.tl l1 in\l       (((_x_0 &amp;&amp; _x_1 \|\| _x_2) \|\| _x_3) \|\| _x_4)\l       &amp;&amp; (((_x_2 \|\| _x_3) \|\| _x_4)\l           \|\| not\l              ((_x_1 &amp;&amp; _x_0)\l               &amp;&amp; ((_x_3 \|\| not (subset _x_5 l2)) \|\| subset _x_5 l3)))\l       :cases [((not (subset l1 l2) \|\| not (subset l2 l3))\l                \|\| List.mem (List.hd l1) l3 &amp;&amp; not (l1 = []))\l               \|\| subset l1 l3;\l               let (_x_0 : bool) = subset l2 l3 in\l               let (_x_1 : sko_ty_0 list) = List.tl l1 in\l               ((((not (subset l1 l2) \|\| not _x_0) \|\| l1 = [])\l                 \|\| not (List.mem (List.hd l1) l3))\l                \|\| not (_x_0 &amp;&amp; subset _x_1 l2 ==\&gt; subset _x_1 l3))\l               \|\| subset l1 l3])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_548 -&gt; p_537 [label=&quot;&quot;];
subgraph cluster_538 {
  color=blue;
p_537 [label=&quot;Start (let (_x_0 : bool) = subset l2 l3 in\l       let (_x_1 : sko_ty_0 list) = List.tl l1 in\l       ((((not (subset l1 l2) \|\| not _x_0) \|\| l1 = [])\l         \|\| not (List.mem (List.hd l1) l3))\l        \|\| not (_x_0 &amp;&amp; subset _x_1 l2 ==\&gt; subset _x_1 l3))\l       \|\| subset l1 l3 :name \&quot;1.1\&quot; :time 0.469s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_537 -&gt; p_536 [label=&quot;&quot;];
p_536 [label=&quot;Simplify (true :expansions [subset; subset; List.mem; List.mem; List.mem]\l          :rw [mem_subset; mem_subset; mem_subset; mem_subset] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_548 -&gt; p_546 [label=&quot;&quot;];
subgraph cluster_547 {
  color=blue;
p_546 [label=&quot;Start (((not (subset l1 l2) \|\| not (subset l2 l3))\l        \|\| List.mem (List.hd l1) l3 &amp;&amp; not (l1 = []))\l       \|\| subset l1 l3 :name \&quot;1.2\&quot; :time 0.469s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_546 -&gt; p_545 [label=&quot;&quot;];
p_545 [label=&quot;Simplify (let (_x_0 : bool) = List.mem (List.hd l1) l3 in\l          let (_x_1 : bool) = not (subset l1 l2) in\l          let (_x_2 : bool) = not (subset l2 l3) in\l          let (_x_3 : bool) = subset l1 l3 in\l          (((_x_0 \|\| _x_1) \|\| _x_2) \|\| _x_3)\l          &amp;&amp; ((((not (l1 = []) \|\| _x_1) \|\| _x_2) \|\| _x_3) \|\| not _x_0)\l          :expansions [] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_545 -&gt; p_540 [label=&quot;&quot;];
subgraph cluster_541 {
  color=blue;
p_540 [label=&quot;Start ((((not (l1 = []) \|\| not (subset l1 l2)) \|\| not (subset l2 l3))\l        \|\| subset l1 l3)\l       \|\| not (List.mem (List.hd l1) l3) :name \&quot;1.2.1\&quot; :time 0.274s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_540 -&gt; p_539 [label=&quot;&quot;];
p_539 [label=&quot;Simplify (true :expansions [subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_545 -&gt; p_543 [label=&quot;&quot;];
subgraph cluster_544 {
  color=blue;
p_543 [label=&quot;Start (((List.mem (List.hd l1) l3 \|\| not (subset l1 l2))\l        \|\| not (subset l2 l3))\l       \|\| subset l1 l3 :name \&quot;1.2.2\&quot; :time 0.274s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_543 -&gt; p_542 [label=&quot;&quot;];
p_542 [label=&quot;Simplify (true :expansions [List.mem; subset] :rw [mem_subset; mem_subset]\l          :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-d499718a-9da3-4572-b451-5bde4eb49a1e';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-07bf4897-08dd-4b18-aca3-7c5d0e83ddd1';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-3596cd58-80ff-475d-964b-55381e6fbdf4';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This forward chaining rule will match only if a goal contains terms that match
<em>both</em> <code>subset l1 l2</code> and <code>subset l2 l3</code>.</p>
<p>It should be noted that Imandra supports <em>automatic trigger selection</em>, meaning
it's often not necessary to annotate the trigger terms manually. Imandra can
typically infer for us both simple triggers and trigger clusters. In fact for
both the single trigger examples above, we could have omitted the trigger
annotations altogether, and Imandra would have found some for us automatically.</p>
</div>
</div>
</div>
                    </div>
                </article>
            </main>
            <footer class="footer">
                <a class="copyrights"href="http://imandra.ai">&#9400; 2018 - 2020 Imandra Inc. All rights reserved.</a>
            </footer>
        </div>
    
 


    <script>
    (function () {
            var lastId;
            var sideMenu = $("#side-nav-menu");
            var topMenu = $("#top-menu");
            var topMenuHeight = topMenu.outerHeight() + 15;

            // All list items
            var menuItems = sideMenu.find('a.side__nav-link--within-page');

            // Anchors corresponding to menu items
            var scrollItems = menuItems.map(function () {
              var item = $(this).attr("href");
              var thisItem = item.substring(item.lastIndexOf("#") + 1, item.length);
              var linkedItem = $('#' + CSS.escape(thisItem));
              if (linkedItem.length) { return linkedItem; }
            });

            // Bind to scroll
            $(window).scroll(function () {
                // Get container scroll position
                var fromTop = $(this).scrollTop() + topMenuHeight;;
                // Get id of current scroll item
                var cur = scrollItems.map(function () {
                    if ($(this).offset().top < fromTop)
                        return this;
                });
                cur = cur[cur.length - 1];
                // Get the id of the current element
                var id = cur && cur.length ? cur[0].id : "";
                if (id && lastId !== id) {
                    lastId = id;
                    // Set/remove active class
                    menuItems.each(function (idx, item) {
                    var $item = $(item);
                    $item.removeClass("side__nav-link--within-page--active");

                    if (item.href.endsWith('#' + lastId)) {
                        $item.addClass("side__nav-link--within-page--active");
                    };
                    });
                }
            });
        })()
    </script>
    <script type="text/javascript"> docsearch({
      apiKey: 'ff3a61a82b58783e62ebfbf51e50b0bc',
      indexName: 'imandra',
      inputSelector: '#search',
      debug: false // Set debug to true if you want to inspect the dropdown
    });
    </script>

    </body>
</html>
