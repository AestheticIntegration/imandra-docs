<!DOCTYPE html>
<html>
    <head><meta charset="utf-8" />
        <meta content="width=device-width, initial-scale=1.0" name="viewport">
        <title>Imandra Documentation - Verification Simplification</title>
        <meta property="og:url" content="https://docs.imandra.ai/imandra-docs/notebooks/verification-simplification/">
        <meta property="og:type" content="website">
        <meta property="og:title" content="Imandra Documentation - Verification Simplification">
        <meta property="og:description" content="A description of Imandra's Simplification strategy">
        <meta property="og:image" content="https://storage.googleapis.com/imandra-assets/images/og_image_default_i78.jpg">


        
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116937440-6"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-116937440-1');
        </script>
        <script type="text/javascript"> var sc_project=11767520; var sc_invisible=1; var sc_security="fa7e88d1"; </script>
        <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
        <noscript><div class="statcounter">
            <a title="Web Analytics" href="http://statcounter.com/" target="_blank">
                <img class="statcounter" src="//c.statcounter.com/11767520/0/fa7e88d1/1/" alt="Web Analytics"></a>
        </div></noscript>
        

        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:300,300i,400,400i%7CMerriweather:300,300i,400,400i%7CRoboto+Slab:300,300i,400,400i">

        <link rel="stylesheet" href="/imandra-docs/static/style/style.min.9ef6027e.css" type="text/css">
        <link rel="stylesheet" href="/imandra-docs/static/nbextensions/nbimandra/styles.b466ce6f.css" type="text/css">
        <link rel="stylesheet" href="/imandra-docs/static/docs-styles.86fc0481.css" type="text/css">
        
        <link rel="stylesheet" href="/imandra-docs/static/jekyll-styles.8c9c0088.css" type="text/css">
        

        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
        <script src="/imandra-docs/static/nbimandra-rjs-bundle.2469bcb7.js"></script>

        <style type="text/css">
         .highlight .hll { background-color: #ffffcc }
         .highlight  { background: #f8f8f8; }
         .highlight .c { color: #408080; font-style: italic } /* Comment */
         .highlight .err { border: 1px solid #FF0000 } /* Error */
         .highlight .k { color: #008000; font-weight: bold } /* Keyword */
         .highlight .o { color: #666666 } /* Operator */
         .highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
         .highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
         .highlight .cp { color: #BC7A00 } /* Comment.Preproc */
         .highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
         .highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
         .highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
         .highlight .gd { color: #A00000 } /* Generic.Deleted */
         .highlight .ge { font-style: italic } /* Generic.Emph */
         .highlight .gr { color: #FF0000 } /* Generic.Error */
         .highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
         .highlight .gi { color: #00A000 } /* Generic.Inserted */
         .highlight .go { color: #888888 } /* Generic.Output */
         .highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
         .highlight .gs { font-weight: bold } /* Generic.Strong */
         .highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
         .highlight .gt { color: #0044DD } /* Generic.Traceback */
         .highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
         .highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
         .highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
         .highlight .kp { color: #008000 } /* Keyword.Pseudo */
         .highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
         .highlight .kt { color: #B00040 } /* Keyword.Type */
         .highlight .m { color: #666666 } /* Literal.Number */
         .highlight .s { color: #BA2121 } /* Literal.String */
         .highlight .na { color: #7D9029 } /* Name.Attribute */
         .highlight .nb { color: #008000 } /* Name.Builtin */
         .highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
         .highlight .no { color: #880000 } /* Name.Constant */
         .highlight .nd { color: #AA22FF } /* Name.Decorator */
         .highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
         .highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
         .highlight .nf { color: #0000FF } /* Name.Function */
         .highlight .nl { color: #A0A000 } /* Name.Label */
         .highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
         .highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
         .highlight .nv { color: #19177C } /* Name.Variable */
         .highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
         .highlight .w { color: #bbbbbb } /* Text.Whitespace */
         .highlight .mb { color: #666666 } /* Literal.Number.Bin */
         .highlight .mf { color: #666666 } /* Literal.Number.Float */
         .highlight .mh { color: #666666 } /* Literal.Number.Hex */
         .highlight .mi { color: #666666 } /* Literal.Number.Integer */
         .highlight .mo { color: #666666 } /* Literal.Number.Oct */
         .highlight .sa { color: #BA2121 } /* Literal.String.Affix */
         .highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
         .highlight .sc { color: #BA2121 } /* Literal.String.Char */
         .highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
         .highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
         .highlight .s2 { color: #BA2121 } /* Literal.String.Double */
         .highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
         .highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
         .highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
         .highlight .sx { color: #008000 } /* Literal.String.Other */
         .highlight .sr { color: #BB6688 } /* Literal.String.Regex */
         .highlight .s1 { color: #BA2121 } /* Literal.String.Single */
         .highlight .ss { color: #19177C } /* Literal.String.Symbol */
         .highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
         .highlight .fm { color: #0000FF } /* Name.Function.Magic */
         .highlight .vc { color: #19177C } /* Name.Variable.Class */
         .highlight .vg { color: #19177C } /* Name.Variable.Global */
         .highlight .vi { color: #19177C } /* Name.Variable.Instance */
         .highlight .vm { color: #19177C } /* Name.Variable.Magic */
         .highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
        </style>

        <!-- Loading mathjax macro -->
        <!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    <!-- End of mathjax configuration --><script>
  function handleCopyClick() {
      var el = this;
      var terminal = el.closest('.terminal');
      var highlight = terminal.getElementsByClassName('highlight')[0];
      copyToClipboardMsg(highlight);

      terminal.classList.add('terminal--hide');
      setTimeout(function () {
          terminal.classList.remove('terminal--hide');
      }, 2000);


      function copyToClipboardMsg(elem) {
          var succeed = copyToClipboard(elem);
          var msg;
          if (!succeed) {
              msg = 'Error!';
          } else {
              msg = 'Copied!';
          }

          var msgElem = terminal.querySelector('.terminal__copy-msg');
          msgElem.innerHTML = msg;
          setTimeout(function () {
              msgElem.innerHTML = 'You rock!';
          }, 1000);
      }

      function copyToClipboard(elem) {
          // create hidden text element, if it doesn't already exist
          var targetId = '_hiddenCopyText_';
          var isInput = elem.tagName === 'INPUT' || elem.tagName === 'TEXTAREA';
          var origSelectionStart, origSelectionEnd;
          if (isInput) {
              // can just use the original source element for the selection and copy
              target = elem;
              origSelectionStart = elem.selectionStart;
              origSelectionEnd = elem.selectionEnd;
          } else {
              // must use a temporary form element for the selection and copy
              target = terminal.querySelector('#' + targetId);
              if (!target) {
                  var target = document.createElement('textarea');
                  // target.style.display = 'flex';
                  // target.style.position = 'absolute';
                  // target.style.left = '-1000%';
                  target.id = targetId;
                 elem.appendChild(target);
              }
              target.textContent = elem.textContent.trim();
          }

          // select the content
          var currentFocus = document.activeElement;
          target.focus();
          target.setSelectionRange(0, target.value.length);

          // copy the selection
          var succeed;
          try {
              succeed = document.execCommand('copy');
          } catch (e) {
              succeed = false;
          }
          // restore original focus
          if (currentFocus && typeof currentFocus.focus === 'function') {
              currentFocus.focus();
          }

          if (isInput) {
              // restore prior selection
              elem.setSelectionRange(origSelectionStart, origSelectionEnd);
          } else {
              // clear temporary content
              elem.removeChild(target);
          }
          return succeed;
      }
  }
</script>
    </head>
    <body>
        <div class="background">
        </div>
        <div class="page-container">
            <main class="main-content-column">
                <!-- Jupyter (Imandra core docs) version -->
<header class="header">
    <div class="top-row-container">
        <div class="top-row">

            <div id="toggler--left" class="side__left-menu-toggler">
                <div class="side__toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
                <p class="side__toggle-text">Docs</p>
            </div>

            <div class="side__logo-container">
                <a class="side__logo-link" href="/">
                    <img class="side__logo " src = "/imandra-docs/jekyll-resources/assets/img/imandra-gradient-logo-docs.svg">
                </a>
            </div>

            <div id="toggler--right" class="side__right-menu-toggler">
                <p class="side__toggle-text">Pages</p>
                <div class="side__toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>

            <nav class="side__nav-container side__nav-container--hidden">

                <ul class="side__nav-list">
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link" href="/">Documentation Home</a>
                        
                    </li>
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link side__nav-link--active" href="/imandra-docs">Imandra</a>
                        
                        <ul class="side__nav-list--sub-level-1">
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/welcome">A Quick Tour</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" target="_blank" rel="noopener noreferrer" href="/imandra-docs/odoc/imandra-base/Imandra_prelude/">Standard Library</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" target="_blank" rel="noopener noreferrer" href="/imandra-docs/odoc/">API Docs</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/installation">Installation</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/installation-simple">Installer</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/installation-docker">Docker Image</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/installation-vscode">VSCode</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/installation-jupyter">Jupyter</a>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/logic-and-program-modes">Logic and Program Modes</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/verification-commands">Verification</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification-commands">Commands</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification-attributes">Attributes</a>
                                        
                                        <ul class="side__nav-list--sub-level-3">
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-attributes/#Verification-Hints">Verification Hints</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-attributes/#Rule-Classes">Rule Classes</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification-unrolling">Unrolling</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link side__nav-link--active" href="/imandra-docs/notebooks/verification-simplification">Simplification</a>
                                        
                                        <ul class="side__nav-list--sub-level-3">
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-simplification/#Rewrite-Rules">Rewrite Rules</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-simplification/#Forward-chaining-Rules">Forward-chaining Rules</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification-blast">Blast</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification-induction">Induction</a>
                                        
                                        <ul class="side__nav-list--sub-level-3">
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-induction/#Functional-Induction">Functional Induction</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-induction/#Structural-Induction">Structural Induction</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification-waterfall">Waterfall</a>
                                        
                                        <ul class="side__nav-list--sub-level-3">
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-waterfall/#Simplification">Simplification</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-waterfall/#Unrolling-check">Unrolling check</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-waterfall/#Destructor-Elimination">Destructor Elimination</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-waterfall/#Fertilization">Fertilization</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-waterfall/#Generalization">Generalization</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification-waterfall/#Induction">Induction</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/proving-program-termination">Proving Program Termination</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                Region Decomposition
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/decomposition-flags">Decomposition Flags</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/imandra-tools-intro">Imandra Tools Introduction</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/idf">Iterative Decomposition Framework</a>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/extracting-ocaml-modules-with-imandra-extract">Extracting OCaml modules with imandra-extract</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/examples">Examples</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/recursion-induction-and-rewriting">Recursion, Induction and Rewriting</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verifying-merge-sort">Verifying Merge Sort in Imandra</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/ubs-case-study">Analysing the UBS ATS Dark Pool</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/six-swiss-exchange-pricing">Region Decomposition - Exchange Pricing</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/webservice-auth-logic">Analysing Web-app Authentication Logic</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/simple-vehicle-controller">Simple Vehicle Controller</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/simple-stoplight-model">Simple Car Intersection model</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/ripple-carry-adder">Verifying a Ripple Carry Adder</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verifying-an-ros-node">Creating and Verifying a ROS Node</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/reasonml-tic-tac-toe">Tic Tac Toe with ReasonML</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/probabilistic-reasoning-in-reasonml">Probabilistic Reasoning in ReasonML</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/sudoku">Solving Sudoku with Imandra</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/crossing-river-safely">Crossing the River Safely</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/reasonml-facetime-state-machines">Exploring The Apple FaceTime Bug with ReasonML State Machines</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/key-pair-security">Key Pair Security in Imandra</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/a-comparison-with-tla-plus">A comparison with TLA+</a>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                        </ul>
                        
                    </li>
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link" href="/ipl">Imandra Protocol Language</a>
                        
                    </li>
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link" href="/fix-engine">FIX Engine</a>
                        
                    </li>
                    
                </ul>
            </nav>
        </div>
    </div>

    <div class="background">
    </div>

    <div class="template-header">
        <div class="top-bar">
            <nav class="top-bar__nav-container">
                <a href="#" class="top-bar__toggle">≡</a>
                <ul class="top-bar__nav-list top-bar__nav-list--hidden">
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/">Home</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://try.imandra.ai/">Try</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://medium.com/imandra">Blog</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/research">Research</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://docs.imandra.ai/">Docs</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/media">Media</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/about">About AI</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/careers">CAREERS</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/contact">CONTACT</a></li>
                </ul>
            </nav>
        </div>

        <div class="template-header__image-container template-header__image-container--jupyter">
            <div class="template-header__image" href ="/imandra-docs">
                <img class="site-specific-image" src="/imandra-docs/static/img/site_specific_image_v_2.svg">
            </div>
        </div>
        
    </div>

    <script>
        document.getElementById('toggler--left').addEventListener('click', function () {
            document.querySelector('.side__right-menu-toggler .side__toggle').classList.remove('side__toggle--active');
            document.querySelector('.side__left-menu-toggler .side__toggle').classList.toggle('side__toggle--active');
            document.getElementsByClassName('side__nav-container')[0].classList.toggle('side__nav-container--hidden');
            document.getElementsByClassName('top-bar__nav-list')[0].classList.add('top-bar__nav-list--hidden');
        });

        document.getElementById('toggler--right').addEventListener('click', function () {
            document.querySelector('.side__left-menu-toggler .side__toggle').classList.remove('side__toggle--active');
            document.querySelector('.side__right-menu-toggler .side__toggle').classList.toggle('side__toggle--active');
            document.getElementsByClassName('side__nav-container')[0].classList.add('side__nav-container--hidden');
            document.getElementsByClassName('top-bar__nav-list')[0].classList.toggle('top-bar__nav-list--hidden');
        });

    </script>
</header>
                <article class="article__container article__container--notebooks">
                    <div class="main-content main-content--jupyter">
                        
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h1 id="Simplification">Simplification<a class="anchor-link" href="#Simplification">&#182;</a></h1><p>At the heart of Imandra is a powerful symbolic simplifier and <a href="https://en.wikipedia.org/wiki/Partial_evaluation">partial
evaluator</a>. The simplifier is
integrated with the <a href="/imandra-docs/notebooks/verification-waterfall/">inductive waterfall</a> (e.g., <code>[@@auto]</code>),
and is the main way in which previously proved lemmas are used during proofs,
through the automatic application of rules. The simplifier
can also be used as a pre-processing step before unrolling, via the <code>[@@simp]</code>
attribute.</p>
<p>As the name suggests, simplification is a process that attempts to transform a
formula into a "simpler" form, bringing the salient features of a formula or
conjecture to the surface. Simplification can also prove goals by reducing them
to <code>true</code>, and refute them by reducing them to <code>false</code>.</p>
<p>Notably, because the symbolic evaluation semantics of the simplifier operate on
a compact <a href="https://en.wikipedia.org/wiki/Directed_graph">digraph</a> representation
of formulas and function definitions, simplification can be thought as having
<a href="https://en.wikipedia.org/wiki/Memoization">memoized</a> semantics for free.</p>
<p>We can see an example of this by using the following naive recursive version of
the fibonacci function:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-2" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">fib</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">then</span>
    <span class="mi">1</span>
  <span class="k">else</span>
    <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[1]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val fib : int -&gt; Z.t = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-fold panel panel-default" id="fold-76de4497-0404-4224-8de6-a7790280aa1b"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>termination proof</span></div></div><div class="panel-body collapse"><div><h3>Termination proof</h3><p></p><div class="imandra-fold panel panel-default" id="fold-dac4bed4-c425-4e9b-ba91-fab815437dbb"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>call `fib (n - 1)` from `fib n`</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-3c47f589-fe6c-485a-91b3-aab108a6e52a"><table><tr><td><b>original</b></td><td>fib n</td></tr><tr><td><b>sub</b></td><td>fib (n - 1)</td></tr><tr><td><b>original ordinal</b></td><td>Ordinal.Int (if n &gt;= 0 then n else 0)</td></tr><tr><td><b>sub ordinal</b></td><td>Ordinal.Int (if (n - 1) &gt;= 0 then n - 1 else 0)</td></tr><tr><td><b>path</b></td><td>[not (n &lt;= 1)]</td></tr><tr><td><b>proof</b></td><td><div class="imandra-fold panel panel-default" id="fold-d9d21f96-8dda-4f2a-8c33-93b497ad9d5c"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>detailed proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-2058ca17-3d07-455d-aeba-496ae6763704"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-c4667506-bda6-4afe-95f7-f142d201de98"><table><tr><td><b>ground_instances</b></td><td>1</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.010s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-daca45eb-9388-4fff-99f9-02fffc8d2fae"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-fbf96838-cd02-443f-8106-26370fff88ab"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-84aafaa7-9c91-48cc-b7c8-ea5974d8c868"><table><tr><td><b>num checks</b></td><td>3</td></tr><tr><td><b>arith assert lower</b></td><td>8</td></tr><tr><td><b>arith pivots</b></td><td>2</td></tr><tr><td><b>rlimit count</b></td><td>2058</td></tr><tr><td><b>mk clause</b></td><td>5</td></tr><tr><td><b>datatype occurs check</b></td><td>2</td></tr><tr><td><b>mk bool var</b></td><td>20</td></tr><tr><td><b>arith assert upper</b></td><td>3</td></tr><tr><td><b>decisions</b></td><td>2</td></tr><tr><td><b>arith add rows</b></td><td>3</td></tr><tr><td><b>propagations</b></td><td>2</td></tr><tr><td><b>conflicts</b></td><td>2</td></tr><tr><td><b>arith fixed eqs</b></td><td>2</td></tr><tr><td><b>datatype accessor ax</b></td><td>2</td></tr><tr><td><b>arith conflicts</b></td><td>1</td></tr><tr><td><b>num allocs</b></td><td>958754687</td></tr><tr><td><b>final checks</b></td><td>1</td></tr><tr><td><b>added eqs</b></td><td>6</td></tr><tr><td><b>del clause</b></td><td>5</td></tr><tr><td><b>arith eq adapter</b></td><td>2</td></tr><tr><td><b>memory</b></td><td>17.960000</td></tr><tr><td><b>max memory</b></td><td>17.960000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-daca45eb-9388-4fff-99f9-02fffc8d2fae';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-fad21a62-b13f-4b57-91be-71a764498061"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.010s]
  not (n &lt;= 1)
  &amp;&amp; (if n &gt;= 0 then n else 0) &gt;= 0
     &amp;&amp; (if (n - 1) &gt;= 0 then n - 1 else 0) &gt;= 0
  ==&gt; (n - 1) &lt;= 1 &amp;&amp; (n - 1) &lt;= 1
      || Ordinal.&lt;&lt; (Ordinal.Int (if (n - 1) &gt;= 0 then n - 1 else 0))
         (Ordinal.Int (if n &gt;= 0 then n else 0))</pre></li><li><div><h5>simplify</h5><div class="imandra-table" id="table-54f930b2-29f2-45b5-8146-6e2b79c73a58"><table><tr><td><b>into</b></td><td><pre>(not
 ((not (n &lt;= 1) &amp;&amp; (if n &gt;= 0 then n else 0) &gt;= 0)
  &amp;&amp; (if n &gt;= 1 then -1 + n else 0) &gt;= 0)
 || n &lt;= 2)
|| Ordinal.&lt;&lt; (Ordinal.Int (if n &gt;= 1 then -1 + n else 0))
   (Ordinal.Int (if n &gt;= 0 then n else 0))</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-b1e8584f-c1fa-4864-9915-c8a1c27df029"><table><tr><td><b>expr</b></td><td><pre>(|Ordinal.&lt;&lt;_116| (|Ordinal.Int_107| (ite (&gt;= n_1470 1) (+ (- 1) n_1470) 0))
                  (|Ord…</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div><h5>unsat</h5><pre>(let ((a!1 (not (= n_1470 (ite (&gt;= n_1470 0) n_1470 0))))
      (a!2 (+ n_1470 (* (- 1) (ite (&gt;= n_1…</pre></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-fad21a62-b13f-4b57-91be-71a764498061';
  fold.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-2058ca17-3d07-455d-aeba-496ae6763704';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-d9d21f96-8dda-4f2a-8c33-93b497ad9d5c';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-dac4bed4-c425-4e9b-ba91-fab815437dbb';
  fold.hydrate(target);
});
</script></div><p></p><div class="imandra-fold panel panel-default" id="fold-5970ff87-2b9b-428c-a54e-a1ac0d35a98d"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>call `fib (n - 2)` from `fib n`</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-b272237d-2292-45ac-add8-77134cd38ef4"><table><tr><td><b>original</b></td><td>fib n</td></tr><tr><td><b>sub</b></td><td>fib (n - 2)</td></tr><tr><td><b>original ordinal</b></td><td>Ordinal.Int (if n &gt;= 0 then n else 0)</td></tr><tr><td><b>sub ordinal</b></td><td>Ordinal.Int (if (n - 2) &gt;= 0 then n - 2 else 0)</td></tr><tr><td><b>path</b></td><td>[not (n &lt;= 1)]</td></tr><tr><td><b>proof</b></td><td><div class="imandra-fold panel panel-default" id="fold-a16b2d7b-60f5-4c8e-b7e4-d2f9551f34c1"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>detailed proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-7d7f2be0-3f4f-43a6-863f-348d705ce78d"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-0d6b0a4f-049c-4b7d-8ef6-5eaf85ac8ea1"><table><tr><td><b>ground_instances</b></td><td>1</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.012s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-412c1638-8db9-48a5-be23-f59943fc5227"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-e823255a-25cd-4b56-8643-2d99c948f191"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-cb02485c-85ea-4726-a08a-e5b189a0762b"><table><tr><td><b>num checks</b></td><td>3</td></tr><tr><td><b>arith assert lower</b></td><td>8</td></tr><tr><td><b>arith pivots</b></td><td>2</td></tr><tr><td><b>rlimit count</b></td><td>1029</td></tr><tr><td><b>mk clause</b></td><td>5</td></tr><tr><td><b>datatype occurs check</b></td><td>2</td></tr><tr><td><b>mk bool var</b></td><td>20</td></tr><tr><td><b>arith assert upper</b></td><td>3</td></tr><tr><td><b>decisions</b></td><td>2</td></tr><tr><td><b>arith add rows</b></td><td>3</td></tr><tr><td><b>propagations</b></td><td>2</td></tr><tr><td><b>conflicts</b></td><td>2</td></tr><tr><td><b>arith fixed eqs</b></td><td>2</td></tr><tr><td><b>datatype accessor ax</b></td><td>2</td></tr><tr><td><b>arith conflicts</b></td><td>1</td></tr><tr><td><b>num allocs</b></td><td>930100930</td></tr><tr><td><b>final checks</b></td><td>1</td></tr><tr><td><b>added eqs</b></td><td>6</td></tr><tr><td><b>del clause</b></td><td>5</td></tr><tr><td><b>arith eq adapter</b></td><td>2</td></tr><tr><td><b>memory</b></td><td>15.040000</td></tr><tr><td><b>max memory</b></td><td>17.870000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-412c1638-8db9-48a5-be23-f59943fc5227';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-d9fd0dd0-213f-41e6-a4e9-0c34b3ea4a6f"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.012s]
  not (n &lt;= 1)
  &amp;&amp; (if n &gt;= 0 then n else 0) &gt;= 0
     &amp;&amp; (if (n - 2) &gt;= 0 then n - 2 else 0) &gt;= 0
  ==&gt; (n - 2) &lt;= 1 &amp;&amp; (n - 2) &lt;= 1
      || Ordinal.&lt;&lt; (Ordinal.Int (if (n - 2) &gt;= 0 then n - 2 else 0))
         (Ordinal.Int (if n &gt;= 0 then n else 0))</pre></li><li><div><h5>simplify</h5><div class="imandra-table" id="table-01870041-951f-4130-8ea7-63b05d9a34ae"><table><tr><td><b>into</b></td><td><pre>(not
 ((not (n &lt;= 1) &amp;&amp; (if n &gt;= 0 then n else 0) &gt;= 0)
  &amp;&amp; (if n &gt;= 2 then -2 + n else 0) &gt;= 0)
 || n &lt;= 3)
|| Ordinal.&lt;&lt; (Ordinal.Int (if n &gt;= 2 then -2 + n else 0))
   (Ordinal.Int (if n &gt;= 0 then n else 0))</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-e2a9049c-ed10-4ea0-92a2-8157e6727c6d"><table><tr><td><b>expr</b></td><td><pre>(|Ordinal.&lt;&lt;_116| (|Ordinal.Int_107| (ite (&gt;= n_1470 2) (+ (- 2) n_1470) 0))
                  (|Ord…</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div><h5>unsat</h5><pre>(let ((a!1 (not (= n_1470 (ite (&gt;= n_1470 0) n_1470 0))))
      (a!2 (+ n_1470 (* (- 1) (ite (&gt;= n_1…</pre></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-d9fd0dd0-213f-41e6-a4e9-0c34b3ea4a6f';
  fold.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-7d7f2be0-3f4f-43a6-863f-348d705ce78d';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-a16b2d7b-60f5-4c8e-b7e4-d2f9551f34c1';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-5970ff87-2b9b-428c-a54e-a1ac0d35a98d';
  fold.hydrate(target);
});
</script></div><p></p></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-76de4497-0404-4224-8de6-a7790280aa1b';
  fold.hydrate(target);
});
</script></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If we try to use Imandra's simplification to search for a solution for <code>fib 200</code>,
Imandra comes back to us with a solution immediately:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-4" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="o">#</span><span class="n">check_models</span> <span class="bp">false</span><span class="o">;;</span>
<span class="n">instance</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fib</span> <span class="mi">200</span><span class="o">)</span> <span class="o">[@@</span><span class="n">simp</span><span class="o">];;</span>
<span class="o">#</span><span class="n">check_models</span> <span class="bp">true</span><span class="o">;;</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[2]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : Z.t -&gt; bool = &lt;fun&gt;
module CX : sig val x : int end
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><pre>Instance (after 0 steps, 0.046s):
 let (x : int) = 453973694165307953197296969697410619233826
</pre></div>

</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Instance</span></div><div><div class="imandra-alternatives" id="alt-47b3976c-fb83-49d7-a5cc-60dadb94dbbc"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>call graph</a></li><li class="" data-toggle="tab"><a>proof</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-graphviz" id="graphviz-54f249f4-23f6-4f8f-9d80-b22306287473"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;x = 453973694165307953197296969697410619233826&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-54f249f4-23f6-4f8f-9d80-b22306287473';
  graphviz.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-889a7c9b-a200-4b8d-9905-671a64ac00ee"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof attempt</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-a4e9f52b-a91f-4732-9c74-802478a0c2ea"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-9d04cb8c-8fe5-46f1-9fc9-fc191d85d371"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>201</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.046s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-4a1e9b38-892c-44ce-89b6-3b409f872558"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-6184c4e9-b36f-418e-867d-7051cf4fddfd"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-53042709-f103-43de-9e6e-2362e85234ba"><table><tr><td><b>eliminated vars</b></td><td>1</td></tr><tr><td><b>rlimit count</b></td><td>7759</td></tr><tr><td><b>mk bool var</b></td><td>5</td></tr><tr><td><b>num allocs</b></td><td>1115600901</td></tr><tr><td><b>memory</b></td><td>15.810000</td></tr><tr><td><b>max memory</b></td><td>17.960000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-4a1e9b38-892c-44ce-89b6-3b409f872558';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-dafa67a7-504d-405d-a92a-086cc0de8d7a"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.046s] :var_0: = fib 200</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-320fb5c6-ae36-4a86-9b5b-153ef0c602e9"><table><tr><td><b>into</b></td><td><pre>x = 453973694165307953197296969697410619233826</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib, fib,
 fib, fib, fib, fib, fib, fib]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li>Sat (Some  let (x : int) = 453973694165307953197296969697410619233826
)</li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-dafa67a7-504d-405d-a92a-086cc0de8d7a';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-079f4d7c-4d8a-4d05-9301-2329e35dfdb0"><textarea style="display: none">digraph &quot;proof&quot; {
p_249 [label=&quot;Start (:var_0: = fib 200 :time 0.046s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_249 -&gt; p_248 [label=&quot;&quot;];
p_248 [label=&quot;Simplify (x = 453973694165307953197296969697410619233826\l          :expansions [fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib;\l                       fib]\l          :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_248 -&gt; p_247 [label=&quot;&quot;];
p_247 [label=&quot;Sat (Some  let (x : int) = 453973694165307953197296969697410619233826\l)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-079f4d7c-4d8a-4d05-9301-2329e35dfdb0';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-a4e9f52b-a91f-4732-9c74-802478a0c2ea';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-889a7c9b-a200-4b8d-9905-671a64ac00ee';
  fold.hydrate(target);
});
</script></div></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-47b3976c-fb83-49d7-a5cc-60dadb94dbbc';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If, however, we tried to use normal OCaml evaluation to compute <code>fib 200</code>, OCaml
would take over 10 minutes in order to come back with a response (the
<code>#check_models false</code> command here is used to tell Imandra not to check the
instance Imandra computed using OCaml evaluation, as that requires the expensive
computation of <code>fib 200</code> via standard OCaml evaluation, which is not memoized).</p>
<!-- TODO mention SMT decision procedures? -->

<p>Now that we know what simplification does, let's learn about how to influence it
using rewrite and forward chaining rules.</p>
<h2 id="Rewrite-Rules">Rewrite Rules<a class="anchor-link" href="#Rewrite-Rules">&#182;</a></h2><p>A rewrite rule is a theorem of the form</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<pre><code>h_1 &amp;&amp; ... &amp;&amp; h_k ==&gt; lhs = rhs</code></pre>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>which Imandra can use in further proofs to replace terms that match with <code>lhs</code>
(the "left hand side") with the appropriate instantiation of <code>rhs</code> (the "right
hand side"), provided that the instantiations of the hypotheses can be
established. Observe that rewrite rules are both <em>conditional</em> (requiring in
general the establishment of hypotheses) and <em>directed</em> (replacing <code>lhs</code> with
<code>rhs</code>). The <code>lhs</code> is also called the "pattern" of the rule.</p>
<p>An enabled rewrite rule causes Imandra to look for matches of the <code>lhs</code>,
replacing the matched term with the (suitably instantiated) <code>rhs</code>, provided that
Imandra can establish ("relieve") the (suitably instantiated) hypotheses of the
rule.</p>
<p>For example, consider the lemma <code>rev_len</code> below. This lemma expresses the fact
that the length of a list <code>x</code> is equal to the length of <code>List.rev x</code>, i.e., if
we reverse a list, we end up with a list of the same length. This rule is
unconditional: it has no hypotheses. Thus, it will always be able to fire on
terms that match its left-hand side. Notice that Imandra uses a previously
defined rewrite rule in order to prove this lemma! The lemma <code>rev_len</code> would
make an excellent rewrite rule, so we use the <code>[@@rw]</code> annotation to install it:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-8" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">rev_len</span> <span class="n">x</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">x</span><span class="o">)</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">x</span>
<span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">rw</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[3]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val rev_len : &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

List.length (List.rev x) = List.length x.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

|---------------------------------------------------------------------------
 List.length (List.rev x) = List.length x


Must try induction.

The recursive terms in the conjecture suggest 2 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">List.length</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (x = [] ==&gt; φ x) &amp;&amp; (not (x = []) &amp;&amp; φ (List.tl x) ==&gt; φ x).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. x = []
|---------------------------------------------------------------------------
 List.length (List.rev x) = List.length x

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.length
</span>and<span class="ansi-blue-intense-fg ansi-bold"> List.rev</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (x = [])
 H1. List.length (List.rev (List.tl x)) = List.length (List.tl x)
|---------------------------------------------------------------------------
 List.length (List.rev x) = List.length x

This simplifies, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.length </span>and<span class="ansi-blue-intense-fg ansi-bold"> List.rev</span> to:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;</span>:

 H0. x &lt;&gt; []
 H1. List.length (List.rev (List.tl x)) = List.length (List.tl x)
|---------------------------------------------------------------------------
 List.length (List.append (List.rev (List.tl x)) [List.hd x]) =
 1 + List.length (List.tl x)


We can eliminate destructors by the following substitution:
 x -&gt; x1 :: x2

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;</span>:

 H0. List.length (List.rev x2) = List.length x2
|---------------------------------------------------------------------------
 List.length (List.append (List.rev x2) [x1]) = 1 + List.length x2


Cross-fertilizing with:

 List.length (List.rev x2) = List.length x2

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;</span>:

|---------------------------------------------------------------------------
 List.length (List.append (List.rev x2) [x1]) = 1 + List.length (List.rev x2)


Candidates for generalization:

 List.rev x2

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;&#39;</span>:

|---------------------------------------------------------------------------
 List.length (List.append gen_1 [x1]) = 1 + List.length gen_1


Must try induction.

The recursive terms in the conjecture suggest 2 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">List.append</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (gen_1 = [] ==&gt; φ gen_1 x1)
 &amp;&amp; (not (gen_1 = []) &amp;&amp; φ (List.tl gen_1) x1 ==&gt; φ gen_1 x1).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;&#39;.2</span>:

 H0. gen_1 = []
|---------------------------------------------------------------------------
 List.length (List.append gen_1 [x1]) = 1 + List.length gen_1

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.append
</span>and<span class="ansi-blue-intense-fg ansi-bold"> List.length</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;&#39;.1</span>:

 H0. not (gen_1 = [])
 H1. List.length (List.append (List.tl gen_1) [x1]) =
     1 + List.length (List.tl gen_1)
|---------------------------------------------------------------------------
 List.length (List.append gen_1 [x1]) = 1 + List.length gen_1

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.append
</span>and<span class="ansi-blue-intense-fg ansi-bold"> List.length</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def List.append)
    (:def List.length)
    (:def List.rev)
    (:fc List.len_nonnegative)
    (:induct List.append)
    (:induct List.length)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-cc9fd337-bb53-41eb-adf8-7d59467b6d77"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-9fc30ea4-93ca-4547-8af6-f14154ac2850"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-8b4dc547-e6e3-4e70-b099-04b648d0c3ab"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>11</td></tr><tr><td><b>inductions</b></td><td>2</td></tr><tr><td><b>search_time</b></td><td><pre>0.540s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-3132d56e-96ee-4a5b-9304-d27e344e59d4"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.540s, &quot;Goal&quot;] List.length (List.rev :var_0:) = List.length :var_0:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-a6504de1-3071-415a-876a-c67802256000"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>List.length (List.rev x) = List.length x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.539s, &quot;1&quot;] List.length (List.rev x) = List.length x</pre></li><li><pre>induction on (functional )
:scheme (x = [] ==&gt; φ x) &amp;&amp; (not (x = []) &amp;&amp; φ (List.tl x) ==&gt; φ x)</pre></li><li><div><pre>Split ((not (x = []) || List.length (List.rev x) = List.length x)
       &amp;&amp; (not
           (not (x = [])
            &amp;&amp; List.length (List.rev (List.tl x)) = List.length (List.tl x))
           || List.length (List.rev x) = List.length x)
       :cases [not (x = []) || List.length (List.rev x) = List.length x;
               (x = []
                || not
                   (List.length (List.rev (List.tl x)) =
                    List.length (List.tl x)))
               || List.length (List.rev x) = List.length x])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-17665cd7-17f3-43f5-b552-156c95a58c7a"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(x = [] || not (List.length (List.rev (List.tl x)) = List.length (List.tl x)))
|| List.length (List.rev x) = List.length x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.485s, &quot;1.1&quot;]
  (x = []
   || not (List.length (List.rev (List.tl x)) = List.length (List.tl x)))
  || List.length (List.rev x) = List.length x</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-2b5a5215-55a7-4f0e-9397-043ce17de57e"><table><tr><td><b>into</b></td><td><pre>(x = [] || not (List.length (List.rev (List.tl x)) = List.length (List.tl x)))
|| List.length (List.append (List.rev (List.tl x)) [List.hd x]) =
   1 + List.length (List.tl x)</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[List.length, List.rev]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li></ul></td></tr></table></div></div></li><li><pre>Elim_destructor (:cstor :: :replace x1 :: x2 :context [])</pre></li><li><pre>Generalize (List.length (List.append (List.rev x2) [x1]) =
            1 + List.length (List.rev x2) :as (gen_1 : sko_ty_0 list))</pre></li><li><pre>induction on (functional )
:scheme (gen_1 = [] ==&gt; φ gen_1 x1)
        &amp;&amp; (not (gen_1 = []) &amp;&amp; φ (List.tl gen_1) x1 ==&gt; φ gen_1 x1)</pre></li><li><div><pre>Split ((not (gen_1 = [])
        || List.length (List.append gen_1 [x1]) = 1 + List.length gen_1)
       &amp;&amp; (not
           (not (gen_1 = [])
            &amp;&amp; List.length (List.append (List.tl gen_1) [x1]) =
               1 + List.length (List.tl gen_1))
           || List.length (List.append gen_1 [x1]) = 1 + List.length gen_1)
       :cases [not (gen_1 = [])
               || List.length (List.append gen_1 [x1]) =
                  1 + List.length gen_1;
               (gen_1 = []
                || not
                   (List.length (List.append (List.tl gen_1) [x1]) =
                    1 + List.length (List.tl gen_1)))
               || List.length (List.append gen_1 [x1]) =
                  1 + List.length gen_1])</pre><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-17665cd7-17f3-43f5-b552-156c95a58c7a';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-5ee33c36-38b5-4db8-b420-c6c3f31ad08e"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>not (x = []) || List.length (List.rev x) = List.length x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.485s, &quot;1.2&quot;] not (x = []) || List.length (List.rev x) = List.length x</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-b4642b8f-dd16-4197-baa2-91f2827a34e6"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[List.length, List.length, List.rev]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-5ee33c36-38b5-4db8-b420-c6c3f31ad08e';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-a6504de1-3071-415a-876a-c67802256000';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-3132d56e-96ee-4a5b-9304-d27e344e59d4';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-2de1b2b5-cf3a-482c-98bd-7ef047a265aa"><textarea style="display: none">digraph &quot;proof&quot; {
p_337 [label=&quot;Start (List.length (List.rev :var_0:) = List.length :var_0: :name \&quot;Goal\&quot;\l       :time 0.540s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_337 -&gt; p_335 [label=&quot;&quot;];
subgraph cluster_336 {
  color=blue;
p_335 [label=&quot;Start (List.length (List.rev x) = List.length x :name \&quot;1\&quot; :time 0.539s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_335 -&gt; p_334 [label=&quot;&quot;];
p_334 [label=&quot;Induct ((functional ),\l        :scheme (x = [] ==\&gt; φ x)\l                &amp;&amp; (not (x = []) &amp;&amp; φ (List.tl x) ==\&gt; φ x))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_334 -&gt; p_333 [label=&quot;&quot;];
p_333 [label=&quot;Split ((not (x = []) \|\| List.length (List.rev x) = List.length x)\l       &amp;&amp; (not\l           (not (x = [])\l            &amp;&amp; List.length (List.rev (List.tl x)) = List.length (List.tl x))\l           \|\| List.length (List.rev x) = List.length x)\l       :cases [not (x = []) \|\| List.length (List.rev x) = List.length x;\l               (x = []\l                \|\| not\l                   (List.length (List.rev (List.tl x)) =\l                    List.length (List.tl x)))\l               \|\| List.length (List.rev x) = List.length x])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_333 -&gt; p_328 [label=&quot;&quot;];
subgraph cluster_329 {
  color=blue;
p_328 [label=&quot;Start ((x = []\l        \|\| not (List.length (List.rev (List.tl x)) = List.length (List.tl x)))\l       \|\| List.length (List.rev x) = List.length x :name \&quot;1.1\&quot; :time 0.485s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_328 -&gt; p_327 [label=&quot;&quot;];
p_327 [label=&quot;Simplify ((x = []\l           \|\| not\l              (List.length (List.rev (List.tl x)) = List.length (List.tl x)))\l          \|\| List.length (List.append (List.rev (List.tl x)) [List.hd x]) =\l             1 + List.length (List.tl x)\l          :expansions [List.length; List.rev] :rw []\l          :fc [List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_327 -&gt; p_326 [label=&quot;&quot;];
p_326 [label=&quot;Elim_destructor (:cstor :: :replace x1 :: x2 :context [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_326 -&gt; p_325 [label=&quot;&quot;];
p_325 [label=&quot;Generalize (List.length (List.append (List.rev x2) [x1]) =\l            1 + List.length (List.rev x2) :as (gen_1 : sko_ty_0 list))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_325 -&gt; p_324 [label=&quot;&quot;];
p_324 [label=&quot;Induct ((functional ),\l        :scheme (gen_1 = [] ==\&gt; φ gen_1 x1)\l                &amp;&amp; (not (gen_1 = []) &amp;&amp; φ (List.tl gen_1) x1 ==\&gt; φ gen_1 x1))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_324 -&gt; p_323 [label=&quot;&quot;];
p_323 [label=&quot;Split ((not (gen_1 = [])\l        \|\| List.length (List.append gen_1 [x1]) = 1 + List.length gen_1)\l       &amp;&amp; (not\l           (not (gen_1 = [])\l            &amp;&amp; List.length (List.append (List.tl gen_1) [x1]) =\l               1 + List.length (List.tl gen_1))\l           \|\| List.length (List.append gen_1 [x1]) = 1 + List.length gen_1)\l       :cases [not (gen_1 = [])\l               \|\| List.length (List.append gen_1 [x1]) =\l                  1 + List.length gen_1;\l               (gen_1 = []\l                \|\| not\l                   (List.length (List.append (List.tl gen_1) [x1]) =\l                    1 + List.length (List.tl gen_1)))\l               \|\| List.length (List.append gen_1 [x1]) =\l                  1 + List.length gen_1])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_323 -&gt; p_318 [label=&quot;&quot;];
subgraph cluster_319 {
  color=blue;
p_318 [label=&quot;Start ((gen_1 = []\l        \|\| not\l           (List.length (List.append (List.tl gen_1) [x1]) =\l            1 + List.length (List.tl gen_1)))\l       \|\| List.length (List.append gen_1 [x1]) = 1 + List.length gen_1\l       :name \&quot;1.1''''.1\&quot; :time 0.006s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_318 -&gt; p_317 [label=&quot;&quot;];
p_317 [label=&quot;Simplify (true :expansions [List.length; List.length; List.append] :rw []\l          :fc [List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative;\l               List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_323 -&gt; p_321 [label=&quot;&quot;];
subgraph cluster_322 {
  color=blue;
p_321 [label=&quot;Start (not (gen_1 = [])\l       \|\| List.length (List.append gen_1 [x1]) = 1 + List.length gen_1\l       :name \&quot;1.1''''.2\&quot; :time 0.006s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_321 -&gt; p_320 [label=&quot;&quot;];
p_320 [label=&quot;Simplify (true :expansions [List.length; List.length; List.append] :rw []\l          :fc [List.len_nonnegative; List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
p_333 -&gt; p_331 [label=&quot;&quot;];
subgraph cluster_332 {
  color=blue;
p_331 [label=&quot;Start (not (x = []) \|\| List.length (List.rev x) = List.length x :name \&quot;1.2\&quot;\l       :time 0.485s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_331 -&gt; p_330 [label=&quot;&quot;];
p_330 [label=&quot;Simplify (true :expansions [List.length; List.length; List.rev] :rw []\l          :fc [List.len_nonnegative; List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-2de1b2b5-cf3a-482c-98bd-7ef047a265aa';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-9fc30ea4-93ca-4547-8af6-f14154ac2850';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-cc9fd337-bb53-41eb-adf8-7d59467b6d77';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>With this rule installed and enabled, if Imandra's simplifier encounters a term
of the form <code>List.length (List.rev &lt;term&gt;)</code>, it will replace it with the simpler
form <code>List.length &lt;term&gt;</code>.</p>
<p>Both the hypotheses and <code>rhs</code> can be omitted, in which case Imandra will default
them to <code>true</code>. That is, <code>h_1 &amp;&amp; ... &amp;&amp; h_k ==&gt; lhs</code> is equivalent to
<code>h_1 &amp;&amp; h_k ==&gt; lhs = true</code> and <code>lhs = rhs</code> is equal to <code>true ==&gt; lhs = rhs</code>.</p>
<p>Imandra's rewriting is:</p>
<ul>
<li><p>conditional: rewrite rules may contain conditions (hypotheses), and eligible
rules are only applied when their hypotheses are established. Once the pattern
of a rule has been matched, Imandra uses backward-chaining ("backchaining") to
relieve the rule's hypotheses, recursively attempting to simplify them to
<code>true</code> modulo the current simplification context. This is important to keep in
mind when developing your theories: rewrite rules will not fire unless Imandra
can simplify their instantiated hypotheses to <code>true</code>.</p>
</li>
<li><p>oriented: given a rule whose conclusion is of the form <code>lhs = rhs</code>, rewriting
happens by replacing the (instantiated) <code>lhs</code> with the (instantiated) <code>rhs</code>.</p>
</li>
</ul>
<p>When adding a new rewrite rule, users should take care to orient the equality so
that <code>rhs</code> is <em>simpler</em> or <em>more canonical</em> than <code>lhs</code>. If it's not clear what
it means for an <code>rhs</code> to be "better" than the <code>lhs</code>, e.g., in the case of the
proof for the associativity of append <code>x @ (y @ z) = (x @ y) @ z</code>, a <em>canonical</em>
form should typically be chosen (e.g., associating to the left in this case)
and kept in mind for further rules.</p>
<p>By default, the <code>lhs</code> must contain all the top-level variables of the theorem
(i.e. the arguments to the <em>lambda term</em> representing the goal). There is an
exception to this rule: if the <code>lhs</code> does not contain all the variables of the
theorem but the rule hypotheses have subterms containing the remaining free
variables, these terms can be annotated with <code>[@trigger rw]</code>, signaling Imandra
that the annotated terms should be used to complete the matching.</p>
<p>It's helpful to see an example where the use of <code>[@trigger rw]</code> is necessary.
Let's first define a <code>subset</code> function on lists:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-10" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">subset</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">true</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span> <span class="n">subset</span> <span class="n">xs</span> <span class="n">y</span>
    <span class="k">else</span> <span class="bp">false</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[4]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val subset : &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-fold panel panel-default" id="fold-5caaac24-0d8d-4704-933e-b1d34b3a60a2"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>termination proof</span></div></div><div class="panel-body collapse"><div><h3>Termination proof</h3><p></p><div class="imandra-fold panel panel-default" id="fold-44c3c590-528d-410c-8536-6cd64140226c"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>call `subset (List.tl x) y` from `subset x y`</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-2262b4b5-bd74-4b9f-b070-b8c9b53ecdc4"><table><tr><td><b>original</b></td><td>subset x y</td></tr><tr><td><b>sub</b></td><td>subset (List.tl x) y</td></tr><tr><td><b>original ordinal</b></td><td>Ordinal.Int (Ordinal.count x)</td></tr><tr><td><b>sub ordinal</b></td><td>Ordinal.Int (Ordinal.count (List.tl x))</td></tr><tr><td><b>path</b></td><td>[List.mem (List.hd x) y &amp;&amp; not (x = [])]</td></tr><tr><td><b>proof</b></td><td><div class="imandra-fold panel panel-default" id="fold-5fbd0513-aaca-4540-ac6c-b28a54349a4f"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>detailed proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-d6611ae7-18f9-4f49-b3f9-98b7787b01ef"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-47e988be-bf52-4a28-a45b-b2491b3191a4"><table><tr><td><b>ground_instances</b></td><td>4</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.013s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-d78093b4-906a-4c3f-8ab8-98d5298b6b81"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-56002f6e-b7b0-4c19-b046-be000a6c9f6b"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-cf1a6696-ca9d-4968-a208-16668eadd20f"><table><tr><td><b>num checks</b></td><td>9</td></tr><tr><td><b>arith assert lower</b></td><td>9</td></tr><tr><td><b>arith pivots</b></td><td>5</td></tr><tr><td><b>rlimit count</b></td><td>2487</td></tr><tr><td><b>mk clause</b></td><td>10</td></tr><tr><td><b>datatype occurs check</b></td><td>35</td></tr><tr><td><b>mk bool var</b></td><td>78</td></tr><tr><td><b>arith assert upper</b></td><td>6</td></tr><tr><td><b>datatype splits</b></td><td>6</td></tr><tr><td><b>decisions</b></td><td>18</td></tr><tr><td><b>arith add rows</b></td><td>7</td></tr><tr><td><b>arith bound prop</b></td><td>1</td></tr><tr><td><b>propagations</b></td><td>9</td></tr><tr><td><b>conflicts</b></td><td>10</td></tr><tr><td><b>arith fixed eqs</b></td><td>5</td></tr><tr><td><b>datatype accessor ax</b></td><td>6</td></tr><tr><td><b>arith conflicts</b></td><td>1</td></tr><tr><td><b>arith assert diseq</b></td><td>1</td></tr><tr><td><b>datatype constructor ax</b></td><td>14</td></tr><tr><td><b>num allocs</b></td><td>2410415158</td></tr><tr><td><b>final checks</b></td><td>9</td></tr><tr><td><b>added eqs</b></td><td>48</td></tr><tr><td><b>del clause</b></td><td>4</td></tr><tr><td><b>arith eq adapter</b></td><td>5</td></tr><tr><td><b>memory</b></td><td>20.350000</td></tr><tr><td><b>max memory</b></td><td>35.200000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-d78093b4-906a-4c3f-8ab8-98d5298b6b81';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-ce6e2ef3-8ce6-4618-8f24-47809f025be1"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.013s]
  List.mem (List.hd x) y
  &amp;&amp; not (x = []) &amp;&amp; Ordinal.count x &gt;= 0 &amp;&amp; Ordinal.count (List.tl x) &gt;= 0
  ==&gt; not (List.mem (List.hd (List.tl x)) y &amp;&amp; not (List.tl x = []))
      || Ordinal.&lt;&lt; (Ordinal.Int (Ordinal.count (List.tl x)))
         (Ordinal.Int (Ordinal.count x))</pre></li><li><div><h5>simplify</h5><div class="imandra-table" id="table-0b2d0a65-b81f-46f6-9a8b-b3544392b4ab"><table><tr><td><b>into</b></td><td><pre>(not
 (((List.mem (List.hd x) y &amp;&amp; not (x = [])) &amp;&amp; Ordinal.count x &gt;= 0)
  &amp;&amp; Ordinal.count (List.tl x) &gt;= 0)
 || not (List.mem (List.hd (List.tl x)) y &amp;&amp; not (List.tl x = [])))
|| Ordinal.&lt;&lt; (Ordinal.Int (Ordinal.count (List.tl x)))
   (Ordinal.Int (Ordinal.count x))</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-7386ef04-93b7-48d2-9cca-6be7773c3172"><table><tr><td><b>expr</b></td><td><pre>(|Ordinal.&lt;&lt;_116| (|Ordinal.Int_107|
                    (|count_`ty_0 list`_1698| (|get.::.1_1676| …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-da918b4c-f667-471c-a4b1-7d2794ad3a5d"><table><tr><td><b>expr</b></td><td><pre>(|List.mem_1682| (|get.::.0_1675| (|get.::.1_1676| x_1687)) y_1688)</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-2abaaa95-0dbc-427b-90f5-61f091f872ac"><table><tr><td><b>expr</b></td><td><pre>(|count_`ty_0 list`_1698| (|get.::.1_1676| x_1687))</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-ed2ee6c7-3b16-4bcc-9ff5-bef39cf28087"><table><tr><td><b>expr</b></td><td><pre>(|count_`ty_0 list`_1698| x_1687)</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div><h5>unsat</h5><pre>(let ((a!1 (= (|count_`ty_0 list`_1698| x_1687)
              (+ 1 (|count_`ty_0 list`_1698| (|get.:…</pre></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-ce6e2ef3-8ce6-4618-8f24-47809f025be1';
  fold.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-d6611ae7-18f9-4f49-b3f9-98b7787b01ef';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-5fbd0513-aaca-4540-ac6c-b28a54349a4f';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-44c3c590-528d-410c-8536-6cd64140226c';
  fold.hydrate(target);
});
</script></div><p></p></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-5caaac24-0d8d-4704-933e-b1d34b3a60a2';
  fold.hydrate(target);
});
</script></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let's now suppose that we want to verify the transitivity of <code>subset</code>:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-12" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="o">#</span><span class="n">max_induct</span> <span class="mi">1</span><span class="o">;;</span>
<span class="n">verify</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="n">subset</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">subset</span> <span class="n">y</span> <span class="n">z</span> <span class="o">==&gt;</span> <span class="n">subset</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">[@@</span><span class="n">auto</span><span class="o">]</span>
<span class="o">#</span><span class="n">max_induct</span> <span class="mi">3</span><span class="o">;;</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[5]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : &#39;a list -&gt; &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

subset x y &amp;&amp; subset y z ==&gt; subset x z.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. subset x y
 H1. subset y z
|---------------------------------------------------------------------------
 subset x z


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 2.

Only 1 of those schemes are unflawed.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (not (List.mem (List.hd x) y &amp;&amp; not (x = [])) ==&gt; φ z y x)
 &amp;&amp; (not (x = []) &amp;&amp; List.mem (List.hd x) y &amp;&amp; φ z y (List.tl x)
     ==&gt; φ z y x).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. subset x y
 H1. subset y z
|---------------------------------------------------------------------------
 C0. List.mem (List.hd x) y &amp;&amp; not (x = [])
 C1. subset x z

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span> to the following 2 subgoals:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.2</span>:

 H0. x = []
 H1. subset y z
|---------------------------------------------------------------------------
 C0. List.mem (List.hd x) y
 C1. subset x z

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.1</span>:

 H0. subset y z
 H1. x = []
 H2. List.mem (List.hd x) y
|---------------------------------------------------------------------------
 subset x z

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (x = [])
 H1. List.mem (List.hd x) y
 H2. subset (List.tl x) y &amp;&amp; subset y z ==&gt; subset (List.tl x) z
 H3. subset x y
 H4. subset y z
|---------------------------------------------------------------------------
 subset x z

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span> to:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;</span>:

 H0. x &lt;&gt; []
 H1. List.mem (List.hd x) y
 H2. subset (List.tl x) z
 H3. subset (List.tl x) y
 H4. subset y z
|---------------------------------------------------------------------------
 List.mem (List.hd x) z


We can eliminate destructors by the following substitution:
 x -&gt; x1 :: x2

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;</span>:

 H0. List.mem x1 y
 H1. subset x2 z
 H2. subset x2 y
 H3. subset y z
|---------------------------------------------------------------------------
 List.mem x1 z


Must try induction.

<span class="ansi-red-intense-fg ansi-bold"> ⚠ </span> Aborting proof attempt for <span class="ansi-white-intense-fg ansi-bold">_verify_target</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def subset)
    (:induct subset)

<span class="ansi-cyan-intense-fg ansi-bold">Checkpoints</span>:

 H0. List.mem x1 y
 H1. subset x2 z
 H2. subset x2 y
 H3. subset y z
<span class="ansi-white-fg">|---------------------------------------------------------------------------</span>
 List.mem x1 z

<span class="ansi-red-intense-fg ansi-bold">Error</span>[/server]: Maximum induction depth reached (1). You can set this with #max_induct.
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>It looks like Imandra needs an additional lemma in order to prove this. By
inspecting the checkpoint, it looks like all we need is a rule relating <code>subset</code>
and <code>List.mem</code>. Let's attempt to prove it:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-14" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">mem_subset</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">subset</span> <span class="n">y</span> <span class="n">z</span> <span class="o">==&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">z</span>
<span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">rewrite</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[6]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val mem_subset : &#39;a -&gt; &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

List.mem x y &amp;&amp; subset y z ==&gt; List.mem x z.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. List.mem x y
 H1. subset y z
|---------------------------------------------------------------------------
 List.mem x z


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">List.mem</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (y = [] ==&gt; φ z y x) &amp;&amp; (not (y = []) &amp;&amp; φ z (List.tl y) x ==&gt; φ z y x).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. y = []
 H1. List.mem x y
 H2. subset y z
|---------------------------------------------------------------------------
 List.mem x z

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (y = [])
 H1. List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z ==&gt; List.mem x z
 H2. List.mem x y
 H3. subset y z
|---------------------------------------------------------------------------
 List.mem x z

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def List.mem)
    (:def subset)
    (:induct List.mem)

File &#34;jupyter cell 6&#34;, line 1, characters 6-91:
<span class="ansi-red-intense-fg ansi-bold">Error</span>: in rewrite rule,
variable (y : &#39;a list) does not occur in left-hand side of the rule
or in `[@trigger rw]` terms
See https://docs.imandra.ai/imandra-docs/notebooks/verification-simplification/#Rewrite-Rules
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-f2eaf854-c69b-40aa-ac90-39e7e1f93670"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-0b9d531b-b7f3-4e8b-ac9f-e6d4ba338989"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-7c9a16dc-9fe1-4210-8af9-7f35bdf46a2f"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>4</td></tr><tr><td><b>inductions</b></td><td>1</td></tr><tr><td><b>search_time</b></td><td><pre>0.148s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-14fd5ebd-bbe2-41f4-96e8-2d694f31bb04"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.148s, &quot;Goal&quot;]
  List.mem :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:
  ==&gt; List.mem :var_0: :var_2:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-dc82e563-ea80-4142-a7e2-5a04057e0384"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(not (List.mem x y) || not (subset y z)) || List.mem x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.148s, &quot;1&quot;] (not (List.mem x y) || not (subset y z)) || List.mem x z</pre></li><li><pre>induction on (functional )
:scheme (y = [] ==&gt; φ z y x)
        &amp;&amp; (not (y = []) &amp;&amp; φ z (List.tl y) x ==&gt; φ z y x)</pre></li><li><div><pre>Split ((((not (y = []) || not (List.mem x y)) || not (subset y z))
        || List.mem x z)
       &amp;&amp; (((not
             (not (y = [])
              &amp;&amp; ((not (List.mem x (List.tl y)) || not (subset (List.tl y) z))
                  || List.mem x z))
             || not (List.mem x y))
            || not (subset y z))
           || List.mem x z)
       :cases [((not (y = []) || not (List.mem x y)) || not (subset y z))
               || List.mem x z;
               (((y = []
                  || not
                     (not (List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z)
                      || List.mem x z))
                 || not (List.mem x y))
                || not (subset y z))
               || List.mem x z])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-e24cb4b1-b261-4a24-afd9-bac8f190e2fc"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(((y = []
   || not
      (not (List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z) || List.mem x z))
  || not (List.mem x y))
 || not (subset y z))
|| List.mem x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.083s, &quot;1.1&quot;]
  (((y = []
     || not
        (not (List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z) || List.mem x z))
    || not (List.mem x y))
   || not (subset y z))
  || List.mem x z</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-e8f9ee93-d533-41be-bdfa-6a7173e7ad82"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[List.mem, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-e24cb4b1-b261-4a24-afd9-bac8f190e2fc';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-0c58eab8-a752-4c5b-b8c8-a667c0b44b98"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((not (y = []) || not (List.mem x y)) || not (subset y z)) || List.mem x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.083s, &quot;1.2&quot;]
  ((not (y = []) || not (List.mem x y)) || not (subset y z)) || List.mem x z</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-2eb2148b-1ad6-4386-a1de-7f48c79ee424"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[List.mem, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-0c58eab8-a752-4c5b-b8c8-a667c0b44b98';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-dc82e563-ea80-4142-a7e2-5a04057e0384';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-14fd5ebd-bbe2-41f4-96e8-2d694f31bb04';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-f35dfd65-7f5c-4671-aa2b-9fbcee8ebde7"><textarea style="display: none">digraph &quot;proof&quot; {
p_403 [label=&quot;Start (List.mem :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:\l       ==\&gt; List.mem :var_0: :var_2: :name \&quot;Goal\&quot; :time 0.148s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_403 -&gt; p_401 [label=&quot;&quot;];
subgraph cluster_402 {
  color=blue;
p_401 [label=&quot;Start ((not (List.mem x y) \|\| not (subset y z)) \|\| List.mem x z :name \&quot;1\&quot;\l       :time 0.148s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_401 -&gt; p_400 [label=&quot;&quot;];
p_400 [label=&quot;Induct ((functional ),\l        :scheme (y = [] ==\&gt; φ z y x)\l                &amp;&amp; (not (y = []) &amp;&amp; φ z (List.tl y) x ==\&gt; φ z y x))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_400 -&gt; p_399 [label=&quot;&quot;];
p_399 [label=&quot;Split ((((not (y = []) \|\| not (List.mem x y)) \|\| not (subset y z))\l        \|\| List.mem x z)\l       &amp;&amp; (((not\l             (not (y = [])\l              &amp;&amp; ((not (List.mem x (List.tl y)) \|\| not (subset (List.tl y) z))\l                  \|\| List.mem x z))\l             \|\| not (List.mem x y))\l            \|\| not (subset y z))\l           \|\| List.mem x z)\l       :cases [((not (y = []) \|\| not (List.mem x y)) \|\| not (subset y z))\l               \|\| List.mem x z;\l               (((y = []\l                  \|\| not\l                     (not (List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z)\l                      \|\| List.mem x z))\l                 \|\| not (List.mem x y))\l                \|\| not (subset y z))\l               \|\| List.mem x z])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_399 -&gt; p_394 [label=&quot;&quot;];
subgraph cluster_395 {
  color=blue;
p_394 [label=&quot;Start ((((y = []\l          \|\| not\l             (not (List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z)\l              \|\| List.mem x z))\l         \|\| not (List.mem x y))\l        \|\| not (subset y z))\l       \|\| List.mem x z :name \&quot;1.1\&quot; :time 0.083s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_394 -&gt; p_393 [label=&quot;&quot;];
p_393 [label=&quot;Simplify (true :expansions [List.mem; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_399 -&gt; p_397 [label=&quot;&quot;];
subgraph cluster_398 {
  color=blue;
p_397 [label=&quot;Start (((not (y = []) \|\| not (List.mem x y)) \|\| not (subset y z))\l       \|\| List.mem x z :name \&quot;1.2\&quot; :time 0.083s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_397 -&gt; p_396 [label=&quot;&quot;];
p_396 [label=&quot;Simplify (true :expansions [List.mem; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-f35dfd65-7f5c-4671-aa2b-9fbcee8ebde7';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-0b9d531b-b7f3-4e8b-ac9f-e6d4ba338989';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-f2eaf854-c69b-40aa-ac90-39e7e1f93670';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>While Imandra was successful in proving this lemma, it raised an error while
trying to turn this lemma into a rewrite rule. As Imandra tells us, this is
because the free variable <code>y</code> does not appear in the <code>lhs</code> term <code>List.mem x z</code>.
If we, however, annotate the <code>subset y z</code> term with the appropriate <code>[@trigger
rw]</code> attribute, Imandra can then successfully turn this term into a valid
rewrite rule:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-16" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">mem_subset</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">subset</span> <span class="n">y</span> <span class="n">z</span> <span class="o">[@</span><span class="n">trigger</span> <span class="n">rw</span><span class="o">])</span> <span class="o">==&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">z</span>
<span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">rewrite</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[7]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val mem_subset : &#39;a -&gt; &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

List.mem x y &amp;&amp; subset y z ==&gt; List.mem x z.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. List.mem x y
 H1. subset y z
|---------------------------------------------------------------------------
 List.mem x z


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 2.

However, scheme scoring gives us a clear winner.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">List.mem</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (y = [] ==&gt; φ z y x) &amp;&amp; (not (y = []) &amp;&amp; φ z (List.tl y) x ==&gt; φ z y x).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. y = []
 H1. List.mem x y
 H2. subset y z
|---------------------------------------------------------------------------
 List.mem x z

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (y = [])
 H1. List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z ==&gt; List.mem x z
 H2. List.mem x y
 H3. subset y z
|---------------------------------------------------------------------------
 List.mem x z

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.mem
</span>and<span class="ansi-blue-intense-fg ansi-bold"> subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def List.mem)
    (:def subset)
    (:induct List.mem)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-7f834d0c-3a70-4fb8-b8b9-a9deb03b8ab6"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-3b520b43-9679-4999-bb76-e4bec9b31265"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-454bc096-8f2b-4a73-9688-31b52622f674"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>4</td></tr><tr><td><b>inductions</b></td><td>1</td></tr><tr><td><b>search_time</b></td><td><pre>0.170s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-b9952bad-37eb-4467-9dd6-4b1b68717faa"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.170s, &quot;Goal&quot;]
  List.mem :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:
  ==&gt; List.mem :var_0: :var_2:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-c84dfbe1-142d-4e4f-8599-963cf2929c15"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(not (List.mem x y) || not (subset y z)) || List.mem x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.170s, &quot;1&quot;] (not (List.mem x y) || not (subset y z)) || List.mem x z</pre></li><li><pre>induction on (functional )
:scheme (y = [] ==&gt; φ z y x)
        &amp;&amp; (not (y = []) &amp;&amp; φ z (List.tl y) x ==&gt; φ z y x)</pre></li><li><div><pre>Split ((((not (y = []) || not (List.mem x y)) || not (subset y z))
        || List.mem x z)
       &amp;&amp; (((not
             (not (y = [])
              &amp;&amp; ((not (List.mem x (List.tl y)) || not (subset (List.tl y) z))
                  || List.mem x z))
             || not (List.mem x y))
            || not (subset y z))
           || List.mem x z)
       :cases [((not (y = []) || not (List.mem x y)) || not (subset y z))
               || List.mem x z;
               (((y = []
                  || not
                     (not (List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z)
                      || List.mem x z))
                 || not (List.mem x y))
                || not (subset y z))
               || List.mem x z])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-17691ec0-5e9e-4f03-a8e8-64781cebfab9"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(((y = []
   || not
      (not (List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z) || List.mem x z))
  || not (List.mem x y))
 || not (subset y z))
|| List.mem x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.105s, &quot;1.1&quot;]
  (((y = []
     || not
        (not (List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z) || List.mem x z))
    || not (List.mem x y))
   || not (subset y z))
  || List.mem x z</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-46d73fb2-f3c2-4b20-a28d-0929c4549684"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[List.mem, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-17691ec0-5e9e-4f03-a8e8-64781cebfab9';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-959feca1-43d8-4f65-bca0-dd58960e7a94"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((not (y = []) || not (List.mem x y)) || not (subset y z)) || List.mem x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.105s, &quot;1.2&quot;]
  ((not (y = []) || not (List.mem x y)) || not (subset y z)) || List.mem x z</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-8dd3b911-438c-455c-9030-fe000ecd7516"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[List.mem, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-959feca1-43d8-4f65-bca0-dd58960e7a94';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-c84dfbe1-142d-4e4f-8599-963cf2929c15';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-b9952bad-37eb-4467-9dd6-4b1b68717faa';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-660aa79f-0323-4b44-be3b-ef5304fd1034"><textarea style="display: none">digraph &quot;proof&quot; {
p_426 [label=&quot;Start (List.mem :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:\l       ==\&gt; List.mem :var_0: :var_2: :name \&quot;Goal\&quot; :time 0.170s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_426 -&gt; p_424 [label=&quot;&quot;];
subgraph cluster_425 {
  color=blue;
p_424 [label=&quot;Start ((not (List.mem x y) \|\| not (subset y z)) \|\| List.mem x z :name \&quot;1\&quot;\l       :time 0.170s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_424 -&gt; p_423 [label=&quot;&quot;];
p_423 [label=&quot;Induct ((functional ),\l        :scheme (y = [] ==\&gt; φ z y x)\l                &amp;&amp; (not (y = []) &amp;&amp; φ z (List.tl y) x ==\&gt; φ z y x))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_423 -&gt; p_422 [label=&quot;&quot;];
p_422 [label=&quot;Split ((((not (y = []) \|\| not (List.mem x y)) \|\| not (subset y z))\l        \|\| List.mem x z)\l       &amp;&amp; (((not\l             (not (y = [])\l              &amp;&amp; ((not (List.mem x (List.tl y)) \|\| not (subset (List.tl y) z))\l                  \|\| List.mem x z))\l             \|\| not (List.mem x y))\l            \|\| not (subset y z))\l           \|\| List.mem x z)\l       :cases [((not (y = []) \|\| not (List.mem x y)) \|\| not (subset y z))\l               \|\| List.mem x z;\l               (((y = []\l                  \|\| not\l                     (not (List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z)\l                      \|\| List.mem x z))\l                 \|\| not (List.mem x y))\l                \|\| not (subset y z))\l               \|\| List.mem x z])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_422 -&gt; p_417 [label=&quot;&quot;];
subgraph cluster_418 {
  color=blue;
p_417 [label=&quot;Start ((((y = []\l          \|\| not\l             (not (List.mem x (List.tl y) &amp;&amp; subset (List.tl y) z)\l              \|\| List.mem x z))\l         \|\| not (List.mem x y))\l        \|\| not (subset y z))\l       \|\| List.mem x z :name \&quot;1.1\&quot; :time 0.105s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_417 -&gt; p_416 [label=&quot;&quot;];
p_416 [label=&quot;Simplify (true :expansions [List.mem; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_422 -&gt; p_420 [label=&quot;&quot;];
subgraph cluster_421 {
  color=blue;
p_420 [label=&quot;Start (((not (y = []) \|\| not (List.mem x y)) \|\| not (subset y z))\l       \|\| List.mem x z :name \&quot;1.2\&quot; :time 0.105s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_420 -&gt; p_419 [label=&quot;&quot;];
p_419 [label=&quot;Simplify (true :expansions [List.mem; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-660aa79f-0323-4b44-be3b-ef5304fd1034';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-3b520b43-9679-4999-bb76-e4bec9b31265';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-7f834d0c-3a70-4fb8-b8b9-a9deb03b8ab6';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>And finally, let's verify that the rewrite rule can indeed match as we expect:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-18" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[8]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">verify</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">-&gt;</span> <span class="n">subset</span> <span class="n">x</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">subset</span> <span class="n">y</span> <span class="n">z</span> <span class="o">==&gt;</span> <span class="n">subset</span> <span class="n">x</span> <span class="n">z</span><span class="o">)</span> <span class="o">[@@</span><span class="n">auto</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[8]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : &#39;a list -&gt; &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

subset x y &amp;&amp; subset y z ==&gt; subset x z.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. subset x y
 H1. subset y z
|---------------------------------------------------------------------------
 subset x z


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 2.

Only 1 of those schemes are unflawed.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (not (List.mem (List.hd x) y &amp;&amp; not (x = [])) ==&gt; φ z y x)
 &amp;&amp; (not (x = []) &amp;&amp; List.mem (List.hd x) y &amp;&amp; φ z y (List.tl x)
     ==&gt; φ z y x).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. subset x y
 H1. subset y z
|---------------------------------------------------------------------------
 C0. List.mem (List.hd x) y &amp;&amp; not (x = [])
 C1. subset x z

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span> to the following 2 subgoals:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.2</span>:

 H0. x = []
 H1. subset y z
|---------------------------------------------------------------------------
 C0. List.mem (List.hd x) y
 C1. subset x z

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.1</span>:

 H0. subset y z
 H1. x = []
 H2. List.mem (List.hd x) y
|---------------------------------------------------------------------------
 subset x z

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (x = [])
 H1. List.mem (List.hd x) y
 H2. subset (List.tl x) y &amp;&amp; subset y z ==&gt; subset (List.tl x) z
 H3. subset x y
 H4. subset y z
|---------------------------------------------------------------------------
 subset x z

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span>, and
the rewrite rule <span class="ansi-magenta-intense-fg ansi-bold">mem_subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def subset)
    (:rw mem_subset)
    (:induct subset)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-553cd6f8-3dc8-47ec-a345-dd42b3a1d3fd"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-d3413be2-3460-4399-85ca-5a077416bf37"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-d273eb26-81a1-47cc-96b1-8db4437b55d2"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>6</td></tr><tr><td><b>inductions</b></td><td>1</td></tr><tr><td><b>search_time</b></td><td><pre>0.261s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-404eb3ea-129a-4974-895f-1631dad689dd"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.261s, &quot;Goal&quot;]
  subset :var_0: :var_1: &amp;&amp; subset :var_1: :var_2: ==&gt; subset :var_0: :var_2:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-a2158cb5-2da1-4497-a346-94cf1dd577cc"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(not (subset x y) || not (subset y z)) || subset x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.261s, &quot;1&quot;] (not (subset x y) || not (subset y z)) || subset x z</pre></li><li><pre>induction on (functional )
:scheme (not (List.mem (List.hd x) y &amp;&amp; not (x = [])) ==&gt; φ z y x)
        &amp;&amp; (not (x = []) &amp;&amp; List.mem (List.hd x) y &amp;&amp; φ z y (List.tl x)
            ==&gt; φ z y x)</pre></li><li><div><pre>Split ((((List.mem (List.hd x) y &amp;&amp; not (x = []) || not (subset x y))
         || not (subset y z))
        || subset x z)
       &amp;&amp; (((not
             ((not (x = []) &amp;&amp; List.mem (List.hd x) y)
              &amp;&amp; ((not (subset (List.tl x) y) || not (subset y z))
                  || subset (List.tl x) z))
             || not (subset x y))
            || not (subset y z))
           || subset x z)
       :cases [((not (subset x y) || not (subset y z))
                || List.mem (List.hd x) y &amp;&amp; not (x = []))
               || subset x z;
               ((((x = [] || not (List.mem (List.hd x) y))
                  || not
                     (not (subset (List.tl x) y &amp;&amp; subset y z)
                      || subset (List.tl x) z))
                 || not (subset x y))
                || not (subset y z))
               || subset x z])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-990a39aa-fa94-4cd8-a495-b890666d9692"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((((x = [] || not (List.mem (List.hd x) y))
   || not (not (subset (List.tl x) y &amp;&amp; subset y z) || subset (List.tl x) z))
  || not (subset x y))
 || not (subset y z))
|| subset x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.172s, &quot;1.1&quot;]
  ((((x = [] || not (List.mem (List.hd x) y))
     || not
        (not (subset (List.tl x) y &amp;&amp; subset y z) || subset (List.tl x) z))
    || not (subset x y))
   || not (subset y z))
  || subset x z</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-3b6483dd-552e-4f28-bfa0-f6b2f7ba6067"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[subset, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><pre>mem_subset</pre></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-990a39aa-fa94-4cd8-a495-b890666d9692';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-31c1f8b2-4d86-474c-bceb-34d98322f32d"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((not (subset x y) || not (subset y z))
 || List.mem (List.hd x) y &amp;&amp; not (x = []))
|| subset x z</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.173s, &quot;1.2&quot;]
  ((not (subset x y) || not (subset y z))
   || List.mem (List.hd x) y &amp;&amp; not (x = []))
  || subset x z</pre></li><li><div><div><h6>simplify</h6><div class="imandra-table" id="table-a8cd370e-a303-4040-8d4d-abd0788ddc4e"><table><tr><td><b>into</b></td><td><pre>(((not (x = []) || not (subset y z)) || List.mem (List.hd x) y) || subset x z)
&amp;&amp; (((not (subset y z) || not (x = [])) || not (List.mem (List.hd x) y))
    || subset x z)</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[subset, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-31c1f8b2-4d86-474c-bceb-34d98322f32d';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-a2158cb5-2da1-4497-a346-94cf1dd577cc';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-404eb3ea-129a-4974-895f-1631dad689dd';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-64fc156e-5958-4455-ac2c-72f0f785a792"><textarea style="display: none">digraph &quot;proof&quot; {
p_455 [label=&quot;Start (subset :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:\l       ==\&gt; subset :var_0: :var_2: :name \&quot;Goal\&quot; :time 0.261s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_455 -&gt; p_453 [label=&quot;&quot;];
subgraph cluster_454 {
  color=blue;
p_453 [label=&quot;Start ((not (subset x y) \|\| not (subset y z)) \|\| subset x z :name \&quot;1\&quot;\l       :time 0.261s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_453 -&gt; p_452 [label=&quot;&quot;];
p_452 [label=&quot;Induct ((functional ),\l        :scheme (not (List.mem (List.hd x) y &amp;&amp; not (x = [])) ==\&gt; φ z y x)\l                &amp;&amp; (not (x = [])\l                    &amp;&amp; List.mem (List.hd x) y &amp;&amp; φ z y (List.tl x)\l                    ==\&gt; φ z y x))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_452 -&gt; p_451 [label=&quot;&quot;];
p_451 [label=&quot;Split ((((List.mem (List.hd x) y &amp;&amp; not (x = []) \|\| not (subset x y))\l         \|\| not (subset y z))\l        \|\| subset x z)\l       &amp;&amp; (((not\l             ((not (x = []) &amp;&amp; List.mem (List.hd x) y)\l              &amp;&amp; ((not (subset (List.tl x) y) \|\| not (subset y z))\l                  \|\| subset (List.tl x) z))\l             \|\| not (subset x y))\l            \|\| not (subset y z))\l           \|\| subset x z)\l       :cases [((not (subset x y) \|\| not (subset y z))\l                \|\| List.mem (List.hd x) y &amp;&amp; not (x = []))\l               \|\| subset x z;\l               ((((x = [] \|\| not (List.mem (List.hd x) y))\l                  \|\| not\l                     (not (subset (List.tl x) y &amp;&amp; subset y z)\l                      \|\| subset (List.tl x) z))\l                 \|\| not (subset x y))\l                \|\| not (subset y z))\l               \|\| subset x z])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_451 -&gt; p_440 [label=&quot;&quot;];
subgraph cluster_441 {
  color=blue;
p_440 [label=&quot;Start (((((x = [] \|\| not (List.mem (List.hd x) y))\l          \|\| not\l             (not (subset (List.tl x) y &amp;&amp; subset y z)\l              \|\| subset (List.tl x) z))\l         \|\| not (subset x y))\l        \|\| not (subset y z))\l       \|\| subset x z :name \&quot;1.1\&quot; :time 0.172s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_440 -&gt; p_439 [label=&quot;&quot;];
p_439 [label=&quot;Simplify (true :expansions [subset; subset] :rw [mem_subset] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_451 -&gt; p_449 [label=&quot;&quot;];
subgraph cluster_450 {
  color=blue;
p_449 [label=&quot;Start (((not (subset x y) \|\| not (subset y z))\l        \|\| List.mem (List.hd x) y &amp;&amp; not (x = []))\l       \|\| subset x z :name \&quot;1.2\&quot; :time 0.173s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_449 -&gt; p_448 [label=&quot;&quot;];
p_448 [label=&quot;Simplify ((((not (x = []) \|\| not (subset y z)) \|\| List.mem (List.hd x) y)\l           \|\| subset x z)\l          &amp;&amp; (((not (subset y z) \|\| not (x = []))\l               \|\| not (List.mem (List.hd x) y))\l              \|\| subset x z)\l          :expansions [subset; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_448 -&gt; p_443 [label=&quot;&quot;];
subgraph cluster_444 {
  color=blue;
p_443 [label=&quot;Start (((not (subset y z) \|\| not (x = [])) \|\| not (List.mem (List.hd x) y))\l       \|\| subset x z :name \&quot;1.2.1\&quot; :time 0.060s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_443 -&gt; p_442 [label=&quot;&quot;];
p_442 [label=&quot;Simplify (true :expansions [subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_448 -&gt; p_446 [label=&quot;&quot;];
subgraph cluster_447 {
  color=blue;
p_446 [label=&quot;Start (((not (x = []) \|\| not (subset y z)) \|\| List.mem (List.hd x) y)\l       \|\| subset x z :name \&quot;1.2.2\&quot; :time 0.060s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_446 -&gt; p_445 [label=&quot;&quot;];
p_445 [label=&quot;Simplify (true :expansions [subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-64fc156e-5958-4455-ac2c-72f0f785a792';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-d3413be2-3460-4399-85ca-5a077416bf37';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-553cd6f8-3dc8-47ec-a345-dd42b3a1d3fd';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Permutative-Restriction">Permutative Restriction<a class="anchor-link" href="#Permutative-Restriction">&#182;</a></h3><p>The <code>@@permutative</code> annotation applies only to rewrite rules and is used to
restrict the rule so that it will only apply if the instantiated <code>rhs</code> is
lexicographically smaller than the matched <code>lhs</code>. This restriction can be
particularly useful in order to break out of infinite rewrite loops while trying
to "canonicalize" a form, for example distributing the "simplest" terms to the
left.</p>
<p>Let's say we want to prove the commutativity of <code>Peano_nat.plus</code> and install it as
a rewrite rule:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-20" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[9]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">comm_plus</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
  <span class="nn">Peano_nat</span><span class="p">.</span><span class="o">(</span><span class="n">plus</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">plus</span> <span class="n">y</span> <span class="n">x</span><span class="o">)</span>
 <span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">rw</span><span class="o">]</span> <span class="o">[@@</span><span class="n">permutative</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[9]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val comm_plus : Peano_nat.t -&gt; Peano_nat.t -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

Peano_nat.= (Peano_nat.plus x y) (Peano_nat.plus y x).

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

|---------------------------------------------------------------------------
 Peano_nat.plus x y = Peano_nat.plus y x


Must try induction.

The recursive terms in the conjecture suggest 2 inductions.

We shall break ties using a complexity heuristic.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (y = Peano_nat.Z ==&gt; φ y x)
 &amp;&amp; (not (y = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, y)) x ==&gt; φ y x).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. y = Peano_nat.Z
|---------------------------------------------------------------------------
 Peano_nat.plus x y = Peano_nat.plus y x

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span> to:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2&#39;</span>:

|---------------------------------------------------------------------------
 Peano_nat.plus x Peano_nat.Z = x


Must try induction.

We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (x = Peano_nat.Z ==&gt; φ x)
 &amp;&amp; (not (x = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, x)) ==&gt; φ x).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2&#39;.2</span>:

 H0. x = Peano_nat.Z
|---------------------------------------------------------------------------
 Peano_nat.plus x Peano_nat.Z = x

But simplification reduces this to true, using the definition of
<span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2&#39;.1</span>:

 H0. not (x = Peano_nat.Z)
 H1. Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) Peano_nat.Z =
     Destruct(Peano_nat.S, 0, x)
|---------------------------------------------------------------------------
 Peano_nat.plus x Peano_nat.Z = x

But simplification reduces this to true, using the definition of
<span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (y = Peano_nat.Z)
 H1. Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =
     Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x
|---------------------------------------------------------------------------
 Peano_nat.plus x y = Peano_nat.plus y x

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span> to:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;</span>:

 H0. Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =
     Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x
|---------------------------------------------------------------------------
 C0. y = Peano_nat.Z
 C1. Peano_nat.plus x y =
     Peano_nat.S (Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x)


We can eliminate destructors by the following
substitution:
 y -&gt; Peano_nat.S y1

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;</span>:

 H0. Peano_nat.plus x y1 = Peano_nat.plus y1 x
|---------------------------------------------------------------------------
 Peano_nat.plus x (Peano_nat.S y1) = Peano_nat.S (Peano_nat.plus y1 x)


Cross-fertilizing with:

 Peano_nat.plus x y1 = Peano_nat.plus y1 x

This produces the modified subgoal:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;</span>:

|---------------------------------------------------------------------------
 Peano_nat.plus x (Peano_nat.S y1) = Peano_nat.S (Peano_nat.plus x y1)


Must try induction.

The recursive terms in the conjecture suggest 2 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (x = Peano_nat.Z ==&gt; φ x y1)
 &amp;&amp; (not (x = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, x)) y1 ==&gt; φ x y1).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;.2</span>:

 H0. x = Peano_nat.Z
|---------------------------------------------------------------------------
 Peano_nat.plus x (Peano_nat.S y1) = Peano_nat.S (Peano_nat.plus x y1)

But simplification reduces this to true, using the definition of
<span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1&#39;&#39;&#39;.1</span>:

 H0. not (x = Peano_nat.Z)
 H1. Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) (Peano_nat.S y1) =
     Peano_nat.S (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) y1)
|---------------------------------------------------------------------------
 Peano_nat.plus x (Peano_nat.S y1) = Peano_nat.S (Peano_nat.plus x y1)

But simplification reduces this to true, using the definition of
<span class="ansi-blue-intense-fg ansi-bold">Peano_nat.plus</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def Peano_nat.plus)
    (:induct Peano_nat.plus)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-f09bd675-bf34-43d2-a55b-d9a7702e5e90"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-6ae2fcb9-7c87-48c5-bb75-93fb568bb2be"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-73ab959a-1c75-4f70-898d-80a71f2e7181"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>8</td></tr><tr><td><b>inductions</b></td><td>3</td></tr><tr><td><b>search_time</b></td><td><pre>0.683s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-47c31c3f-7ebd-479c-a88f-454b78a1e47d"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.683s, &quot;Goal&quot;]
  Peano_nat.plus :var_0: :var_1: = Peano_nat.plus :var_1: :var_0:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-9b52d0ce-d5a6-43d9-960c-446cfa9f25ba"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Peano_nat.plus x y = Peano_nat.plus y x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.683s, &quot;1&quot;] Peano_nat.plus x y = Peano_nat.plus y x</pre></li><li><pre>induction on (functional )
:scheme (y = Peano_nat.Z ==&gt; φ y x)
        &amp;&amp; (not (y = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, y)) x
            ==&gt; φ y x)</pre></li><li><div><pre>Split ((not (y = Peano_nat.Z) || Peano_nat.plus x y = Peano_nat.plus y x)
       &amp;&amp; (not
           (not (y = Peano_nat.Z)
            &amp;&amp; Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =
               Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x)
           || Peano_nat.plus x y = Peano_nat.plus y x)
       :cases [not (y = Peano_nat.Z)
               || Peano_nat.plus x y = Peano_nat.plus y x;
               (y = Peano_nat.Z
                || not
                   (Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =
                    Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x))
               || Peano_nat.plus x y = Peano_nat.plus y x])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-2098e88e-994c-4fae-a1f4-110e1403de81"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(y = Peano_nat.Z
 || not
    (Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =
     Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x))
|| Peano_nat.plus x y = Peano_nat.plus y x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.608s, &quot;1.1&quot;]
  (y = Peano_nat.Z
   || not
      (Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =
       Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x))
  || Peano_nat.plus x y = Peano_nat.plus y x</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-f52d38b3-5820-4362-b1b5-43a6f3a0671b"><table><tr><td><b>into</b></td><td><pre>(y = Peano_nat.Z
 || not
    (Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =
     Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x))
|| Peano_nat.plus x y =
   Peano_nat.S (Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x)</pre></td></tr><tr><td><b>expansions</b></td><td><pre>Peano_nat.plus</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><pre>Elim_destructor (:cstor Peano_nat.S :replace Peano_nat.S y1 :context [])</pre></li><li><pre>induction on (functional )
:scheme (x = Peano_nat.Z ==&gt; φ x y1)
        &amp;&amp; (not (x = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, x)) y1
            ==&gt; φ x y1)</pre></li><li><div><pre>Split ((not (x = Peano_nat.Z)
        || Peano_nat.plus x (Peano_nat.S y1) =
           Peano_nat.S (Peano_nat.plus x y1))
       &amp;&amp; (not
           (not (x = Peano_nat.Z)
            &amp;&amp; Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) (Peano_nat.S y1)
               =
               Peano_nat.S (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) y1))
           || Peano_nat.plus x (Peano_nat.S y1) =
              Peano_nat.S (Peano_nat.plus x y1))
       :cases [not (x = Peano_nat.Z)
               || Peano_nat.plus x (Peano_nat.S y1) =
                  Peano_nat.S (Peano_nat.plus x y1);
               (x = Peano_nat.Z
                || not
                   (Peano_nat.plus (Destruct(Peano_nat.S, 0, x))
                    (Peano_nat.S y1) =
                    Peano_nat.S
                    (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) y1)))
               || Peano_nat.plus x (Peano_nat.S y1) =
                  Peano_nat.S (Peano_nat.plus x y1)])</pre><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-2098e88e-994c-4fae-a1f4-110e1403de81';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-7cd51d08-3e22-4d38-865b-403caf712f66"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>not (y = Peano_nat.Z) || Peano_nat.plus x y = Peano_nat.plus y x</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.608s, &quot;1.2&quot;]
  not (y = Peano_nat.Z) || Peano_nat.plus x y = Peano_nat.plus y x</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-806b10ce-ed2f-4f18-8d1c-897ebc30dd75"><table><tr><td><b>into</b></td><td><pre>Peano_nat.plus x Peano_nat.Z = x</pre></td></tr><tr><td><b>expansions</b></td><td><pre>Peano_nat.plus</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><pre>induction on (functional )
:scheme (x = Peano_nat.Z ==&gt; φ x)
        &amp;&amp; (not (x = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, x))
            ==&gt; φ x)</pre></li><li><div><pre>Split ((not (x = Peano_nat.Z) || Peano_nat.plus x Peano_nat.Z = x)
       &amp;&amp; (not
           (not (x = Peano_nat.Z)
            &amp;&amp; Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) Peano_nat.Z =
               Destruct(Peano_nat.S, 0, x))
           || Peano_nat.plus x Peano_nat.Z = x)
       :cases [not (x = Peano_nat.Z) || Peano_nat.plus x Peano_nat.Z = x;
               (x = Peano_nat.Z
                || not
                   (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) Peano_nat.Z
                    = Destruct(Peano_nat.S, 0, x)))
               || Peano_nat.plus x Peano_nat.Z = x])</pre><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-7cd51d08-3e22-4d38-865b-403caf712f66';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-9b52d0ce-d5a6-43d9-960c-446cfa9f25ba';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-47c31c3f-7ebd-479c-a88f-454b78a1e47d';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-c6fd81c9-a3ee-49b1-a080-d704b7c7c6ce"><textarea style="display: none">digraph &quot;proof&quot; {
p_539 [label=&quot;Start (Peano_nat.plus :var_0: :var_1: = Peano_nat.plus :var_1: :var_0:\l       :name \&quot;Goal\&quot; :time 0.683s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_539 -&gt; p_537 [label=&quot;&quot;];
subgraph cluster_538 {
  color=blue;
p_537 [label=&quot;Start (Peano_nat.plus x y = Peano_nat.plus y x :name \&quot;1\&quot; :time 0.683s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_537 -&gt; p_536 [label=&quot;&quot;];
p_536 [label=&quot;Induct ((functional ),\l        :scheme (y = Peano_nat.Z ==\&gt; φ y x)\l                &amp;&amp; (not (y = Peano_nat.Z)\l                    &amp;&amp; φ (Destruct(Peano_nat.S, 0, y)) x ==\&gt; φ y x))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_536 -&gt; p_535 [label=&quot;&quot;];
p_535 [label=&quot;Split ((not (y = Peano_nat.Z) \|\| Peano_nat.plus x y = Peano_nat.plus y x)\l       &amp;&amp; (not\l           (not (y = Peano_nat.Z)\l            &amp;&amp; Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =\l               Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x)\l           \|\| Peano_nat.plus x y = Peano_nat.plus y x)\l       :cases [not (y = Peano_nat.Z)\l               \|\| Peano_nat.plus x y = Peano_nat.plus y x;\l               (y = Peano_nat.Z\l                \|\| not\l                   (Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =\l                    Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x))\l               \|\| Peano_nat.plus x y = Peano_nat.plus y x])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_535 -&gt; p_522 [label=&quot;&quot;];
subgraph cluster_523 {
  color=blue;
p_522 [label=&quot;Start ((y = Peano_nat.Z\l        \|\| not\l           (Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =\l            Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x))\l       \|\| Peano_nat.plus x y = Peano_nat.plus y x :name \&quot;1.1\&quot; :time 0.608s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_522 -&gt; p_521 [label=&quot;&quot;];
p_521 [label=&quot;Simplify ((y = Peano_nat.Z\l           \|\| not\l              (Peano_nat.plus x (Destruct(Peano_nat.S, 0, y)) =\l               Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x))\l          \|\| Peano_nat.plus x y =\l             Peano_nat.S (Peano_nat.plus (Destruct(Peano_nat.S, 0, y)) x)\l          :expansions [Peano_nat.plus] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_521 -&gt; p_520 [label=&quot;&quot;];
p_520 [label=&quot;Elim_destructor (:cstor Peano_nat.S :replace Peano_nat.S y1 :context [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_520 -&gt; p_519 [label=&quot;&quot;];
p_519 [label=&quot;Induct ((functional ),\l        :scheme (x = Peano_nat.Z ==\&gt; φ x y1)\l                &amp;&amp; (not (x = Peano_nat.Z)\l                    &amp;&amp; φ (Destruct(Peano_nat.S, 0, x)) y1 ==\&gt; φ x y1))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_519 -&gt; p_518 [label=&quot;&quot;];
p_518 [label=&quot;Split ((not (x = Peano_nat.Z)\l        \|\| Peano_nat.plus x (Peano_nat.S y1) =\l           Peano_nat.S (Peano_nat.plus x y1))\l       &amp;&amp; (not\l           (not (x = Peano_nat.Z)\l            &amp;&amp; Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) (Peano_nat.S y1)\l               =\l               Peano_nat.S (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) y1))\l           \|\| Peano_nat.plus x (Peano_nat.S y1) =\l              Peano_nat.S (Peano_nat.plus x y1))\l       :cases [not (x = Peano_nat.Z)\l               \|\| Peano_nat.plus x (Peano_nat.S y1) =\l                  Peano_nat.S (Peano_nat.plus x y1);\l               (x = Peano_nat.Z\l                \|\| not\l                   (Peano_nat.plus (Destruct(Peano_nat.S, 0, x))\l                    (Peano_nat.S y1) =\l                    Peano_nat.S\l                    (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) y1)))\l               \|\| Peano_nat.plus x (Peano_nat.S y1) =\l                  Peano_nat.S (Peano_nat.plus x y1)])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_518 -&gt; p_513 [label=&quot;&quot;];
subgraph cluster_514 {
  color=blue;
p_513 [label=&quot;Start ((x = Peano_nat.Z\l        \|\| not\l           (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) (Peano_nat.S y1) =\l            Peano_nat.S (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) y1)))\l       \|\| Peano_nat.plus x (Peano_nat.S y1) =\l          Peano_nat.S (Peano_nat.plus x y1)\l       :name \&quot;1.1'''.1\&quot; :time 0.018s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_513 -&gt; p_512 [label=&quot;&quot;];
p_512 [label=&quot;Simplify (true :expansions [Peano_nat.plus; Peano_nat.plus] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_518 -&gt; p_516 [label=&quot;&quot;];
subgraph cluster_517 {
  color=blue;
p_516 [label=&quot;Start (not (x = Peano_nat.Z)\l       \|\| Peano_nat.plus x (Peano_nat.S y1) =\l          Peano_nat.S (Peano_nat.plus x y1)\l       :name \&quot;1.1'''.2\&quot; :time 0.018s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_516 -&gt; p_515 [label=&quot;&quot;];
p_515 [label=&quot;Simplify (true :expansions [Peano_nat.plus; Peano_nat.plus] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
p_535 -&gt; p_533 [label=&quot;&quot;];
subgraph cluster_534 {
  color=blue;
p_533 [label=&quot;Start (not (y = Peano_nat.Z) \|\| Peano_nat.plus x y = Peano_nat.plus y x\l       :name \&quot;1.2\&quot; :time 0.608s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_533 -&gt; p_532 [label=&quot;&quot;];
p_532 [label=&quot;Simplify (Peano_nat.plus x Peano_nat.Z = x :expansions [Peano_nat.plus]\l          :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_532 -&gt; p_531 [label=&quot;&quot;];
p_531 [label=&quot;Induct ((functional ),\l        :scheme (x = Peano_nat.Z ==\&gt; φ x)\l                &amp;&amp; (not (x = Peano_nat.Z) &amp;&amp; φ (Destruct(Peano_nat.S, 0, x))\l                    ==\&gt; φ x))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_531 -&gt; p_530 [label=&quot;&quot;];
p_530 [label=&quot;Split ((not (x = Peano_nat.Z) \|\| Peano_nat.plus x Peano_nat.Z = x)\l       &amp;&amp; (not\l           (not (x = Peano_nat.Z)\l            &amp;&amp; Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) Peano_nat.Z =\l               Destruct(Peano_nat.S, 0, x))\l           \|\| Peano_nat.plus x Peano_nat.Z = x)\l       :cases [not (x = Peano_nat.Z) \|\| Peano_nat.plus x Peano_nat.Z = x;\l               (x = Peano_nat.Z\l                \|\| not\l                   (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) Peano_nat.Z\l                    = Destruct(Peano_nat.S, 0, x)))\l               \|\| Peano_nat.plus x Peano_nat.Z = x])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_530 -&gt; p_525 [label=&quot;&quot;];
subgraph cluster_526 {
  color=blue;
p_525 [label=&quot;Start ((x = Peano_nat.Z\l        \|\| not\l           (Peano_nat.plus (Destruct(Peano_nat.S, 0, x)) Peano_nat.Z =\l            Destruct(Peano_nat.S, 0, x)))\l       \|\| Peano_nat.plus x Peano_nat.Z = x :name \&quot;1.2'.1\&quot; :time 0.470s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_525 -&gt; p_524 [label=&quot;&quot;];
p_524 [label=&quot;Simplify (true :expansions [Peano_nat.plus] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_530 -&gt; p_528 [label=&quot;&quot;];
subgraph cluster_529 {
  color=blue;
p_528 [label=&quot;Start (not (x = Peano_nat.Z) \|\| Peano_nat.plus x Peano_nat.Z = x\l       :name \&quot;1.2'.2\&quot; :time 0.470s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_528 -&gt; p_527 [label=&quot;&quot;];
p_527 [label=&quot;Simplify (true :expansions [Peano_nat.plus] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-c6fd81c9-a3ee-49b1-a080-d704b7c7c6ce';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-6ae2fcb9-7c87-48c5-bb75-93fb568bb2be';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-f09bd675-bf34-43d2-a55b-d9a7702e5e90';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Had we not restricted <code>comm_plus</code> as a permutative rule, the simplifier would have
entered a rewrite loop every time it encountered a term matching <code>plus &lt;x&gt; &lt;y&gt;</code>,
while with the permutative restriction in place, this has the effect of directing
all the "simplest" terms to the left of <code>plus</code>, which will help with making
further rewrite rules applicable and with simplification in general.</p>
<h2 id="Forward-chaining-Rules">Forward-chaining Rules<a class="anchor-link" href="#Forward-chaining-Rules">&#182;</a></h2><p>Forward chaining is the second type of rule that Imandra allows us to register
and participate automatically in proofs.</p>
<p>A forward chaining rule is a theorem containing a collection of <em>trigger</em> terms
which must include all free variables of the theorem. If Imandra can
appropriately match the triggers with terms in the goal, then an instantiation
of the rule is added to the <em>context</em>. The context of a goal is not displayed in
the goal itself (i.e., when the goal is printed), but is rather used in the
background to aid the simplifier in closing branches, relieving hypotheses of
rewrite rules during backchaining, and so on.</p>
<p>For example, let us prove the following theorem and install it as a
forward-chaining rule:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-22" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[10]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">len_nonnegative</span> <span class="n">x</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">x</span> <span class="o">[@</span><span class="n">trigger</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="o">[@@</span><span class="n">simp</span><span class="o">]</span> <span class="o">[@@</span><span class="n">fc</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[10]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val len_nonnegative : &#39;a list -&gt; bool = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-alternatives" id="alt-fdc9b0ce-9887-4b9a-bfb6-d93fd35252e0"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>proof</a></li><li class="" data-toggle="tab"><a>call graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-9bec091b-b0e4-4d10-918a-fcf557063841"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-edb5b53a-d9d5-4816-a832-a069a24663c2"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-d01c3e27-4540-4675-bd49-bc7d07becf39"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.079s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-10f04fdb-5b93-44ac-9148-ada9636b4e8c"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-6b2e2753-cd1e-4c5d-aa6a-a568343d1d63"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-82ef07b9-b42a-411f-b90e-1cf187d3bff0"><table><tr><td><b>rlimit count</b></td><td>229</td></tr><tr><td><b>mk bool var</b></td><td>5</td></tr><tr><td><b>memory</b></td><td>23.650000</td></tr><tr><td><b>max memory</b></td><td>53.880000</td></tr><tr><td><b>num allocs</b></td><td>14910673774.000000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-10f04fdb-5b93-44ac-9148-ada9636b4e8c';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-b3c8127a-3bf0-4810-91e0-ae38977389a4"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.079s] List.length :var_0: &gt;= 0</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-96f6960f-da76-4e8a-b664-de21b06e14dc"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><pre>List.len_nonnegative</pre></td></tr></table></div></div></li><li><div><h4>unsat</h4><pre>(mp (asserted (not true)) (rewrite (= (not true) false)) false)</pre></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-b3c8127a-3bf0-4810-91e0-ae38977389a4';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-28083a24-e2e2-4d5a-ab27-369ec31b4994"><textarea style="display: none">digraph &quot;proof&quot; {
p_542 [label=&quot;Start (List.length :var_0: \&gt;= 0 :time 0.079s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_542 -&gt; p_541 [label=&quot;&quot;];
p_541 [label=&quot;Simplify (true :expansions [] :rw [] :fc [List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_541 -&gt; p_540 [label=&quot;&quot;];
p_540 -&gt; p_z3_90 [label=&quot;&quot;,fontname=&quot;courier&quot;,fontsize=14];
p_z3_90 [label=&quot;(mp (asserted (not true)) (rewrite (= (not true) false)) false)&quot;,shape=box,fontname=&quot;courier&quot;,fontsize=14];p_540 [label=&quot;unsat&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-28083a24-e2e2-4d5a-ab27-369ec31b4994';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-edb5b53a-d9d5-4816-a832-a069a24663c2';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-9bec091b-b0e4-4d10-918a-fcf557063841';
  fold.hydrate(target);
});
</script></div></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-3bb90f07-0250-45d6-ac7d-5160e51c92a5"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;not true&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-3bb90f07-0250-45d6-ac7d-5160e51c92a5';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-fdc9b0ce-9887-4b9a-bfb6-d93fd35252e0';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Now when Imandra encounters a term of the form <code>List.length &lt;term&gt;</code>, the formula
<code>List.length &lt;term&gt; &gt;= 0</code> will be added to the <em>context</em> of the goal under
focus. In other words, a forward chaining rule allows Imandra to extend the
database of background logical facts it knows about a goal. These facts are made
available to the simplifier, and can thus be used to enhance simplification by
closing branches and relieving hypotheses of conditional rewrite rules.</p>
<p>A forward chaining rule can contain multiple <em>disjoint</em> triggers. In this case, if
<em>either</em> of the triggers matches, the forward chaining rule fires. For example,
the following forward chaining version of the <code>rev_len</code> rewrite rule we added
above will fire if either <code>List.length x</code> or <code>List.length (List.rev x)</code>
matches.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-24" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[11]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">rev_len_fc</span> <span class="n">x</span> <span class="o">=</span>
   <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">x</span> <span class="o">[@</span><span class="n">trigger</span><span class="o">]</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">x</span><span class="o">)</span> <span class="o">[@</span><span class="n">trigger</span><span class="o">]</span>
<span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">fc</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[11]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val rev_len_fc : &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

List.length x = List.length (List.rev x).

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

|---------------------------------------------------------------------------
 List.length x = List.length (List.rev x)

But simplification reduces this to true, using the rewrite rule <span class="ansi-magenta-intense-fg ansi-bold">rev_len</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:rw rev_len)
    (:fc List.len_nonnegative)
    (:fc len_nonnegative)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-f1d67a71-00ca-4349-89dd-d5c5755b2714"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-900c3435-29a5-4814-b323-ee83a51f3db2"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-83e0ecdc-76fb-43ae-a279-603ae63f905c"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.018s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-6bf2a9ef-a4db-4edb-96ee-048c9245ba71"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.018s, &quot;Goal&quot;] List.length :var_0: = List.length (List.rev :var_0:)</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-6f6d82d8-c487-4bfa-9000-26f32898050c"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>List.length x = List.length (List.rev x)</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.018s, &quot;1&quot;] List.length x = List.length (List.rev x)</pre></li><li><div><h5>simplify</h5><div class="imandra-table" id="table-65cf70ee-77da-40fc-a6b4-29941e5f9765"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><pre>rev_len</pre></td></tr><tr><td><b>forward_chaining</b></td><td><ul><li><pre>List.len_nonnegative</pre></li><li><pre>len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li><li><pre>len_nonnegative</pre></li></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-6f6d82d8-c487-4bfa-9000-26f32898050c';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-6bf2a9ef-a4db-4edb-96ee-048c9245ba71';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-9945b9fc-e695-461a-b6cb-8d03b1eb0226"><textarea style="display: none">digraph &quot;proof&quot; {
p_546 [label=&quot;Start (List.length :var_0: = List.length (List.rev :var_0:) :name \&quot;Goal\&quot;\l       :time 0.018s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_546 -&gt; p_544 [label=&quot;&quot;];
subgraph cluster_545 {
  color=blue;
p_544 [label=&quot;Start (List.length x = List.length (List.rev x) :name \&quot;1\&quot; :time 0.018s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_544 -&gt; p_543 [label=&quot;&quot;];
p_543 [label=&quot;Simplify (true :expansions [] :rw [rev_len]\l          :fc [List.len_nonnegative;\l               len_nonnegative;\l               List.len_nonnegative;\l               len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-9945b9fc-e695-461a-b6cb-8d03b1eb0226';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-900c3435-29a5-4814-b323-ee83a51f3db2';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-f1d67a71-00ca-4349-89dd-d5c5755b2714';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Additionally, a forward chaining rule can contain multiple <em>conjoined</em> triggers,
forming a <em>trigger cluster</em>. In this case, <em>all</em> the triggers must match in
order for the forward chaining rule to apply.</p>
<p>To create a trigger cluster multiple terms must be annotated with
<code>[@trigger &lt;x&gt;i]</code>, where <code>&lt;x&gt;</code> is a numeric identifier common to all
the triggers in the cluster. For example:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Verification%20-%20Simplification.ipynb%23try-cell-26" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[12]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">theorem</span> <span class="n">subset_trans</span> <span class="n">l1</span> <span class="n">l2</span> <span class="n">l3</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">subset</span> <span class="n">l1</span> <span class="n">l2</span> <span class="o">[@</span><span class="n">trigger</span> <span class="mi">0</span><span class="n">i</span><span class="o">])</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">subset</span> <span class="n">l2</span> <span class="n">l3</span> <span class="o">[@</span><span class="n">trigger</span> <span class="mi">0</span><span class="n">i</span><span class="o">])</span>
  <span class="o">==&gt;</span>
  <span class="n">subset</span> <span class="n">l1</span> <span class="n">l3</span>
 <span class="o">[@@</span><span class="n">auto</span><span class="o">]</span> <span class="o">[@@</span><span class="n">forward_chaining</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[12]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val subset_trans : &#39;a list -&gt; &#39;a list -&gt; &#39;a list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

subset l1 l2 &amp;&amp; subset l2 l3 ==&gt; subset l1 l3.

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. subset l1 l2
 H1. subset l2 l3
|---------------------------------------------------------------------------
 subset l1 l3


Must try induction.

The recursive terms in the conjecture suggest 3 inductions.
Subsumption and merging reduces this to 2.

Only 1 of those schemes are unflawed.
We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (not (List.mem (List.hd l1) l2 &amp;&amp; not (l1 = [])) ==&gt; φ l3 l2 l1)
 &amp;&amp; (not (l1 = []) &amp;&amp; List.mem (List.hd l1) l2 &amp;&amp; φ l3 l2 (List.tl l1)
     ==&gt; φ l3 l2 l1).

2 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. subset l1 l2
 H1. subset l2 l3
|---------------------------------------------------------------------------
 C0. List.mem (List.hd l1) l2 &amp;&amp; not (l1 = [])
 C1. subset l1 l3

This simplifies, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span> to the following 2 subgoals:

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.2</span>:

 H0. l1 = []
 H1. subset l2 l3
|---------------------------------------------------------------------------
 C0. List.mem (List.hd l1) l2
 C1. subset l1 l3

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2.1</span>:

 H0. subset l2 l3
 H1. l1 = []
 H2. List.mem (List.hd l1) l2
|---------------------------------------------------------------------------
 subset l1 l3

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (l1 = [])
 H1. List.mem (List.hd l1) l2
 H2. subset (List.tl l1) l2 &amp;&amp; subset l2 l3 ==&gt; subset (List.tl l1) l3
 H3. subset l1 l2
 H4. subset l2 l3
|---------------------------------------------------------------------------
 subset l1 l3

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">subset</span>, and
the rewrite rule <span class="ansi-magenta-intense-fg ansi-bold">mem_subset</span>.

<span class="ansi-cyan-intense-fg ansi-bold"> ⓘ </span> Rules:
    (:def subset)
    (:rw mem_subset)
    (:induct subset)

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div style="font-size: 1.2em; padding: 0.5em; border-top: 1px solid green; border-bottom: 1px solid green"><i class="fa fa-check-circle" style="margin-right: 0.5em; color: green"></i><span>Proved</span></div><div><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-9fa4f9c1-8494-4722-908c-569cf93fc79a"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-542897cb-d33a-419f-9625-09a0e0881167"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-ed07351d-e419-4a88-8676-a48311ef7961"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>6</td></tr><tr><td><b>inductions</b></td><td>1</td></tr><tr><td><b>search_time</b></td><td><pre>0.268s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-6a6776d1-c84b-43c2-9120-fcd62ef3dceb"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.268s, &quot;Goal&quot;]
  subset :var_0: :var_1: &amp;&amp; subset :var_1: :var_2: ==&gt; subset :var_0: :var_2:</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-bc8db746-619d-45dc-a89f-9feda1fcb328"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(not (subset l1 l2) || not (subset l2 l3)) || subset l1 l3</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.268s, &quot;1&quot;] (not (subset l1 l2) || not (subset l2 l3)) || subset l1 l3</pre></li><li><pre>induction on (functional )
:scheme (not (List.mem (List.hd l1) l2 &amp;&amp; not (l1 = [])) ==&gt; φ l3 l2 l1)
        &amp;&amp; (not (l1 = [])
            &amp;&amp; List.mem (List.hd l1) l2 &amp;&amp; φ l3 l2 (List.tl l1)
            ==&gt; φ l3 l2 l1)</pre></li><li><div><pre>Split ((((List.mem (List.hd l1) l2 &amp;&amp; not (l1 = []) || not (subset l1 l2))
         || not (subset l2 l3))
        || subset l1 l3)
       &amp;&amp; (((not
             ((not (l1 = []) &amp;&amp; List.mem (List.hd l1) l2)
              &amp;&amp; ((not (subset (List.tl l1) l2) || not (subset l2 l3))
                  || subset (List.tl l1) l3))
             || not (subset l1 l2))
            || not (subset l2 l3))
           || subset l1 l3)
       :cases [((not (subset l1 l2) || not (subset l2 l3))
                || List.mem (List.hd l1) l2 &amp;&amp; not (l1 = []))
               || subset l1 l3;
               ((((l1 = [] || not (List.mem (List.hd l1) l2))
                  || not
                     (not (subset (List.tl l1) l2 &amp;&amp; subset l2 l3)
                      || subset (List.tl l1) l3))
                 || not (subset l1 l2))
                || not (subset l2 l3))
               || subset l1 l3])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-06a3aeb1-6513-491e-b169-71cd698b07f3"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((((l1 = [] || not (List.mem (List.hd l1) l2))
   || not
      (not (subset (List.tl l1) l2 &amp;&amp; subset l2 l3) || subset (List.tl l1) l3))
  || not (subset l1 l2))
 || not (subset l2 l3))
|| subset l1 l3</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.187s, &quot;1.1&quot;]
  ((((l1 = [] || not (List.mem (List.hd l1) l2))
     || not
        (not (subset (List.tl l1) l2 &amp;&amp; subset l2 l3)
         || subset (List.tl l1) l3))
    || not (subset l1 l2))
   || not (subset l2 l3))
  || subset l1 l3</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-16a557d6-a33e-4e62-b4ea-2912cc6fdba3"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[subset, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><pre>mem_subset</pre></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-06a3aeb1-6513-491e-b169-71cd698b07f3';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-4e210c2c-1a78-4444-896d-eb92e1389291"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((not (subset l1 l2) || not (subset l2 l3))
 || List.mem (List.hd l1) l2 &amp;&amp; not (l1 = []))
|| subset l1 l3</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.187s, &quot;1.2&quot;]
  ((not (subset l1 l2) || not (subset l2 l3))
   || List.mem (List.hd l1) l2 &amp;&amp; not (l1 = []))
  || subset l1 l3</pre></li><li><div><div><h6>simplify</h6><div class="imandra-table" id="table-b1ebf9b3-7307-4a59-a8f4-addcfcd9b659"><table><tr><td><b>into</b></td><td><pre>(((not (l1 = []) || not (subset l2 l3)) || List.mem (List.hd l1) l2)
 || subset l1 l3)
&amp;&amp; (((not (subset l2 l3) || not (l1 = [])) || not (List.mem (List.hd l1) l2))
    || subset l1 l3)</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[subset, subset]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div><ul><li><pre>Subproof</pre></li><li><pre>Subproof</pre></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-4e210c2c-1a78-4444-896d-eb92e1389291';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-bc8db746-619d-45dc-a89f-9feda1fcb328';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-6a6776d1-c84b-43c2-9120-fcd62ef3dceb';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-b9db522c-3c88-4c92-91b9-5c6e237348c5"><textarea style="display: none">digraph &quot;proof&quot; {
p_575 [label=&quot;Start (subset :var_0: :var_1: &amp;&amp; subset :var_1: :var_2:\l       ==\&gt; subset :var_0: :var_2: :name \&quot;Goal\&quot; :time 0.268s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_575 -&gt; p_573 [label=&quot;&quot;];
subgraph cluster_574 {
  color=blue;
p_573 [label=&quot;Start ((not (subset l1 l2) \|\| not (subset l2 l3)) \|\| subset l1 l3 :name \&quot;1\&quot;\l       :time 0.268s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_573 -&gt; p_572 [label=&quot;&quot;];
p_572 [label=&quot;Induct ((functional ),\l        :scheme (not (List.mem (List.hd l1) l2 &amp;&amp; not (l1 = []))\l                 ==\&gt; φ l3 l2 l1)\l                &amp;&amp; (not (l1 = [])\l                    &amp;&amp; List.mem (List.hd l1) l2 &amp;&amp; φ l3 l2 (List.tl l1)\l                    ==\&gt; φ l3 l2 l1))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_572 -&gt; p_571 [label=&quot;&quot;];
p_571 [label=&quot;Split ((((List.mem (List.hd l1) l2 &amp;&amp; not (l1 = []) \|\| not (subset l1 l2))\l         \|\| not (subset l2 l3))\l        \|\| subset l1 l3)\l       &amp;&amp; (((not\l             ((not (l1 = []) &amp;&amp; List.mem (List.hd l1) l2)\l              &amp;&amp; ((not (subset (List.tl l1) l2) \|\| not (subset l2 l3))\l                  \|\| subset (List.tl l1) l3))\l             \|\| not (subset l1 l2))\l            \|\| not (subset l2 l3))\l           \|\| subset l1 l3)\l       :cases [((not (subset l1 l2) \|\| not (subset l2 l3))\l                \|\| List.mem (List.hd l1) l2 &amp;&amp; not (l1 = []))\l               \|\| subset l1 l3;\l               ((((l1 = [] \|\| not (List.mem (List.hd l1) l2))\l                  \|\| not\l                     (not (subset (List.tl l1) l2 &amp;&amp; subset l2 l3)\l                      \|\| subset (List.tl l1) l3))\l                 \|\| not (subset l1 l2))\l                \|\| not (subset l2 l3))\l               \|\| subset l1 l3])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_571 -&gt; p_560 [label=&quot;&quot;];
subgraph cluster_561 {
  color=blue;
p_560 [label=&quot;Start (((((l1 = [] \|\| not (List.mem (List.hd l1) l2))\l          \|\| not\l             (not (subset (List.tl l1) l2 &amp;&amp; subset l2 l3)\l              \|\| subset (List.tl l1) l3))\l         \|\| not (subset l1 l2))\l        \|\| not (subset l2 l3))\l       \|\| subset l1 l3 :name \&quot;1.1\&quot; :time 0.187s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_560 -&gt; p_559 [label=&quot;&quot;];
p_559 [label=&quot;Simplify (true :expansions [subset; subset] :rw [mem_subset] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_571 -&gt; p_569 [label=&quot;&quot;];
subgraph cluster_570 {
  color=blue;
p_569 [label=&quot;Start (((not (subset l1 l2) \|\| not (subset l2 l3))\l        \|\| List.mem (List.hd l1) l2 &amp;&amp; not (l1 = []))\l       \|\| subset l1 l3 :name \&quot;1.2\&quot; :time 0.187s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_569 -&gt; p_568 [label=&quot;&quot;];
p_568 [label=&quot;Simplify ((((not (l1 = []) \|\| not (subset l2 l3)) \|\| List.mem (List.hd l1) l2)\l           \|\| subset l1 l3)\l          &amp;&amp; (((not (subset l2 l3) \|\| not (l1 = []))\l               \|\| not (List.mem (List.hd l1) l2))\l              \|\| subset l1 l3)\l          :expansions [subset; subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_568 -&gt; p_563 [label=&quot;&quot;];
subgraph cluster_564 {
  color=blue;
p_563 [label=&quot;Start (((not (subset l2 l3) \|\| not (l1 = []))\l        \|\| not (List.mem (List.hd l1) l2))\l       \|\| subset l1 l3 :name \&quot;1.2.1\&quot; :time 0.076s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_563 -&gt; p_562 [label=&quot;&quot;];
p_562 [label=&quot;Simplify (true :expansions [subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_568 -&gt; p_566 [label=&quot;&quot;];
subgraph cluster_567 {
  color=blue;
p_566 [label=&quot;Start (((not (l1 = []) \|\| not (subset l2 l3)) \|\| List.mem (List.hd l1) l2)\l       \|\| subset l1 l3 :name \&quot;1.2.2\&quot; :time 0.076s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_566 -&gt; p_565 [label=&quot;&quot;];
p_565 [label=&quot;Simplify (true :expansions [subset] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-b9db522c-3c88-4c92-91b9-5c6e237348c5';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-542897cb-d33a-419f-9625-09a0e0881167';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-9fa4f9c1-8494-4722-908c-569cf93fc79a';
  fold.hydrate(target);
});
</script></div></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This forward chaining rule will match only if a goal contains terms that match
<em>both</em> <code>subset l1 l2</code> and <code>subset l2 l3</code>.</p>
<p>It should be noted that Imandra supports <em>automatic trigger selection</em>, meaning
it's often not necessary to annotate the trigger terms manually. Imandra can
typically infer for us both simple triggers and trigger clusters. In fact for
both the single trigger examples above, we could have omitted the trigger
annotations altogether, and Imandra would have found some for us automatically.</p>
</div>
</div>
</div>
                    </div>

                    <div class="sidebar-right">
                        <div class="sidebar-right__menu">
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h1" href="#Simplification">Simplification</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h2" href="#Rewrite-Rules">Rewrite Rules</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h3" href="#Permutative-Restriction">Permutative Restriction</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h2" href="#Forward-chaining-Rules">Forward-chaining Rules</a>
                            
                        </div>
                    </div></article>
            </main>
            <footer class="footer">
                <a class="copyrights"href="http://imandra.ai">&#9400; 2018 - 2019 Imandra Inc. All rights reserved.</a>
            </footer>
        </div>
    
 


    </body>
</html>
