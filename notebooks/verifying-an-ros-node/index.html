<!DOCTYPE html>
<html>
    <head><meta charset="utf-8" />
        <meta content="width=device-width, initial-scale=1.0" name="viewport">
        <title>Imandra Documentation - Creating and Verifying a ROS Node</title>
        <meta property="og:url" content="https://docs.imandra.ai/imandra-docs/notebooks/verifying-an-ros-node/">
        <meta property="og:type" content="website">
        <meta property="og:title" content="Imandra Documentation - Creating and Verifying a ROS Node">
        <meta property="og:description" content="In this notebook we look at verifying a Robotic Operating System (ROS) node.">
        <meta property="og:image" content="https://storage.googleapis.com/imandra-assets/images/og_image_default_i78.jpg">

        
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116937440-6"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-116937440-6');
        </script>
        <script type="text/javascript"> var sc_project=11767520; var sc_invisible=1; var sc_security="fa7e88d1"; </script>
        <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
        <noscript><div class="statcounter">
            <a title="Web Analytics" href="http://statcounter.com/" target="_blank">
                <img class="statcounter" src="//c.statcounter.com/11767520/0/fa7e88d1/1/" alt="Web Analytics"></a>
        </div></noscript>
        

        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:300,300i,400,400i%7CMerriweather:300,300i,400,400i%7CRoboto+Slab:300,300i,400,400i">

        <link rel="stylesheet" href="/imandra-docs/static/style/style.min.9ef6027e.css" type="text/css">
        <link rel="stylesheet" href="/imandra-docs/static/nbextensions/nbimandra/styles.c7ed3d1a.css" type="text/css">
        <link rel="stylesheet" href="/imandra-docs/static/docs-styles.86fc0481.css" type="text/css">
        
        <link rel="stylesheet" href="/imandra-docs/static/jekyll-styles.0d588486.css" type="text/css">
        

        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
        <script src="/imandra-docs/static/nbimandra-rjs-bundle.2469bcb7.js"></script>

        <style type="text/css">
         .highlight .hll { background-color: #ffffcc }
         .highlight  { background: #f8f8f8; }
         .highlight .c { color: #408080; font-style: italic } /* Comment */
         .highlight .err { border: 1px solid #FF0000 } /* Error */
         .highlight .k { color: #008000; font-weight: bold } /* Keyword */
         .highlight .o { color: #666666 } /* Operator */
         .highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
         .highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
         .highlight .cp { color: #BC7A00 } /* Comment.Preproc */
         .highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
         .highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
         .highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
         .highlight .gd { color: #A00000 } /* Generic.Deleted */
         .highlight .ge { font-style: italic } /* Generic.Emph */
         .highlight .gr { color: #FF0000 } /* Generic.Error */
         .highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
         .highlight .gi { color: #00A000 } /* Generic.Inserted */
         .highlight .go { color: #888888 } /* Generic.Output */
         .highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
         .highlight .gs { font-weight: bold } /* Generic.Strong */
         .highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
         .highlight .gt { color: #0044DD } /* Generic.Traceback */
         .highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
         .highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
         .highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
         .highlight .kp { color: #008000 } /* Keyword.Pseudo */
         .highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
         .highlight .kt { color: #B00040 } /* Keyword.Type */
         .highlight .m { color: #666666 } /* Literal.Number */
         .highlight .s { color: #BA2121 } /* Literal.String */
         .highlight .na { color: #7D9029 } /* Name.Attribute */
         .highlight .nb { color: #008000 } /* Name.Builtin */
         .highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
         .highlight .no { color: #880000 } /* Name.Constant */
         .highlight .nd { color: #AA22FF } /* Name.Decorator */
         .highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
         .highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
         .highlight .nf { color: #0000FF } /* Name.Function */
         .highlight .nl { color: #A0A000 } /* Name.Label */
         .highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
         .highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
         .highlight .nv { color: #19177C } /* Name.Variable */
         .highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
         .highlight .w { color: #bbbbbb } /* Text.Whitespace */
         .highlight .mb { color: #666666 } /* Literal.Number.Bin */
         .highlight .mf { color: #666666 } /* Literal.Number.Float */
         .highlight .mh { color: #666666 } /* Literal.Number.Hex */
         .highlight .mi { color: #666666 } /* Literal.Number.Integer */
         .highlight .mo { color: #666666 } /* Literal.Number.Oct */
         .highlight .sa { color: #BA2121 } /* Literal.String.Affix */
         .highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
         .highlight .sc { color: #BA2121 } /* Literal.String.Char */
         .highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
         .highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
         .highlight .s2 { color: #BA2121 } /* Literal.String.Double */
         .highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
         .highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
         .highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
         .highlight .sx { color: #008000 } /* Literal.String.Other */
         .highlight .sr { color: #BB6688 } /* Literal.String.Regex */
         .highlight .s1 { color: #BA2121 } /* Literal.String.Single */
         .highlight .ss { color: #19177C } /* Literal.String.Symbol */
         .highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
         .highlight .fm { color: #0000FF } /* Name.Function.Magic */
         .highlight .vc { color: #19177C } /* Name.Variable.Class */
         .highlight .vg { color: #19177C } /* Name.Variable.Global */
         .highlight .vi { color: #19177C } /* Name.Variable.Instance */
         .highlight .vm { color: #19177C } /* Name.Variable.Magic */
         .highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
        </style>

        <!-- Loading mathjax macro -->
        <!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    <!-- End of mathjax configuration --></head>
    <body>
        <div class="background">
        </div>
        <div class="page-container">
            <main class="main-content-column">
                <!-- Jupyter (Imandra core docs) version -->
<header class="header">
    <div class="top-row-container">
        <div class="top-row">
            <div id="toggler--left" class="side__left-menu-toggler"><a href="#" class="side__toggle">≡ <span class="side__toggle-text">Docs</span></a></div>
            <div class="side__logo-container">
                <a class="side__logo-link" href="/">
                    <img class="side__logo " src = "/imandra-docs/jekyll-resources/assets/img/ai_logo_green.svg">
                </a>
            </div>
            <div id="toggler--right" class="side__right-menu-toggler"><a href="#" class="side__toggle"><span class="side__toggle-text">Pages</span> ≡</a></div>

            <nav class="side__nav-container side__nav-container--hidden">

                <ul class="side__nav-list">
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link" href="/">Home</a>
                        
                    </li>
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link side__nav-link--active" href="/imandra-docs">Imandra</a>
                        
                        <ul class="side__nav-list--sub-level-1">
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/welcome">A Quick Tour</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/installation">Installation</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/installation-simple">Simple</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/installation-manual-opam">Manual (opam)</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/installation-docker">Docker</a>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/logic-and-program-modes">Logic and Program Modes</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/verification">Verification</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification#Bounded-Solving">Bounded Solving</a>
                                        
                                        <ul class="side__nav-list--sub-level-3">
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification#Unrolling">Unrolling</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification#Blast">Blast</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification#Simplification">Simplification</a>
                                        
                                        <ul class="side__nav-list--sub-level-3">
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification#Rewrite-Rule">Rewrite Rule</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification#Forward-Chaining">Forward Chaining</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification#Induction">Induction</a>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                Features
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verifying-merge-sort">Verifying Merge Sort in Imandra</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/recursion-induction-and-rewriting">Recursion, Induction and Rewriting</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/proving-program-termination">Proving Program Termination with Imandra</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/decomposition-flags">Imandra Decomposition Flags</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/imandra-tools-intro">Imandra Tools Introduction</a>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                Examples
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/ubs-case-study">Analysing the UBS ATS Dark Pool</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/webservice-auth-logic">Analysing Web-app Authentication Logic</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/simple-vehicle-controller">Simple Vehicle Controller</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/ripple-carry-adder">Verifying a Ripple Carry Adder</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link side__nav-link--active" href="/imandra-docs/notebooks/verifying-an-ros-node">Creating and Verifying a ROS Node</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/reasonml-tic-tac-toe">Tic Tac Toe with ReasonML</a>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                        </ul>
                        
                    </li>
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link" href="/ipl">Imandra Protocol Language</a>
                        
                    </li>
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link" href="/fix-engine">FIX Engine</a>
                        
                    </li>
                    
                </ul>
            </nav>
        </div>
    </div>

    <div class="background">
    </div>

    <div class="template-header">
        <div class="top-bar">
            <nav class="top-bar__nav-container">
                <a href="#" class="top-bar__toggle">≡</a>
                <ul class="top-bar__nav-list top-bar__nav-list--hidden">
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://imandra.ai/">Home</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://imandra.ai/">Imandra</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://try.imandra.ai/">Try</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://medium.com/">Blog</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://imandra.ai/">Research</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://docs.imandra.ai/">Docs</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://imandra.ai/media">Media</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://imandra.ai/#about-ai">About AI</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://imandra.ai/careers">CAREERS</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://imandra.ai/#contact">CONTACT</a></li>
                </ul>
            </nav>
        </div>
        <div class="template-header__image-container template-header__image-container--jupyter">
            <div class="template-header__image" href ="/imandra-docs">
                <img class="SiteSpecificImage" src="/imandra-docs/static/img/site_specific_image_v_2.svg">
            </div>
        </div>
    </div>
    <script>
     document.getElementById('toggler--left').addEventListener('click', function () {
         document.getElementsByClassName('side__nav-container')[0].classList.toggle('side__nav-container--hidden');
         document.getElementsByClassName('top-bar__nav-list')[0].classList.add('top-bar__nav-list--hidden');
     });
     document.getElementById('toggler--right').addEventListener('click', function () {
         document.getElementsByClassName('side__nav-container')[0].classList.add('side__nav-container--hidden');
         document.getElementsByClassName('top-bar__nav-list')[0].classList.toggle('top-bar__nav-list--hidden');
     });
    </script>
</header>
                <article class="ArticleContainer">
                    <div class="main-content main-content--jupyter">
                        
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Creating-and-Verifying-a-ROS-Node">Creating and Verifying a ROS Node<a class="anchor-link" href="#Creating-and-Verifying-a-ROS-Node">&#182;</a></h1><p><img src="https://storage.googleapis.com/imandra-notebook-assets/ros/kostya_ros_medium_1.png" alt="Imandrabot"></p>
<p><em>At AI, we've been working on an IML (Imandra Modelling Language) interface to ROS, allowing one to develop ROS nodes and use Imandra to verify their properties. In this notebook, we will go through creation and verification of a Robotic Operating System (ROS) node in Imandra. We will make a robot control node that controls the motion of a simple 2-wheeler bot:</em></p>
<p><img src="https://storage.googleapis.com/imandra-notebook-assets/ros/Imandrabot.png" alt="Imandrabot"></p>
<p>We'll create a controller that uses the laser scanner to avoid obstacles and drive around the scene. The Imandra ML code can be compiled in OCaml and plugged into the ROS system - the behaviour of the bot can be observed in the Gazebo simulator.</p>
<p>Then we'll illustrate how to use Imandra to formally verify various statements about the model and how to find bugs and corner cases by exploring the Imandra-generated counterexamples for false conjectures.</p>
<h1 id="1.-ROS-message-OCaml-types">1. ROS message OCaml types<a class="anchor-link" href="#1.-ROS-message-OCaml-types">&#182;</a></h1><p>For our Imandra-ROS project we’ve processed all the standard ROS messages with our code generation tool creating a collection of strongly-typed IML/OCaml bindings for them. But, in order to keep this notebook self-contained we'll define the necessary messaging modules here.</p>
<p>First, we'll need to declare the message type that will control our robot. This is typically done with a <code>Twist</code> message from the <code>geometry_msgs</code> standard ROS package. We want to mimic ROS messaging nomenclauture as close as possible, so we'll create an OCaml/Imadra <code>module</code> with the same name as the package and will place the necessary type/message declaraions inside:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-2" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">module</span> <span class="nc">Geometry_msgs</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">vector3</span> <span class="o">=</span> 
    <span class="o">{</span> <span class="n">vector3_x</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="o">;</span> <span class="n">vector3_y</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="o">;</span> <span class="n">vector3_z</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="o">}</span>
  <span class="k">type</span> <span class="n">twist</span> <span class="o">=</span> 
    <span class="o">{</span> <span class="n">twist_linear</span>  <span class="o">:</span> <span class="n">vector3</span>
    <span class="o">;</span> <span class="n">twist_angular</span> <span class="o">:</span> <span class="n">vector3</span>
    <span class="o">}</span>    
<span class="k">end</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[1]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>module Geometry_msgs :
  sig
    type vector3 = { vector3_x : int; vector3_y : int; vector3_z : int; }
    type twist = { twist_linear : vector3; twist_angular : vector3; }
  end
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You might have noticed that we've replaced floating point values for vector coordinates with integers. In this context, it is more straight-forward for Imandra to reason about integers, so we assume that there is a common factor of 100,000 multiplying all the incoming floating point values and divides all the outgoing integers. (That effectively makes our unit of measurement of length to be 10 micrometres).</p>
<p>Let's move on and declare the incoming messages:</p>
<ul>
<li><code>LaserScan</code> sensor input message from the <code>sensor_msgs</code> ROS package</li>
<li>and the <code>Clock</code> message from the <code>Rosgraph_msg</code> ROS package  </li>
</ul>
<p>We define the wrapping modules for both messages and declare their datatypes:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-4" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">module</span> <span class="nc">Sensor_msgs</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">laserScan</span> <span class="o">=</span> 
    <span class="o">{</span> <span class="n">laserScan_range_min</span> <span class="o">:</span> <span class="kt">int</span> 
    <span class="o">;</span> <span class="n">laserScan_range_max</span> <span class="o">:</span> <span class="kt">int</span> 
    <span class="o">;</span> <span class="n">laserScan_ranges</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> 
    <span class="o">}</span>
<span class="k">end</span>
<span class="k">module</span> <span class="nc">Rosgraph_msgs</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">time</span> <span class="o">=</span> 
    <span class="o">{</span> <span class="n">seconds</span>     <span class="o">:</span> <span class="kt">int</span>
    <span class="o">;</span> <span class="n">nanoseconds</span> <span class="o">:</span> <span class="kt">int</span>
    <span class="o">}</span>
  <span class="k">type</span> <span class="n">clock</span> <span class="o">=</span> <span class="o">{</span> <span class="n">clock</span> <span class="o">:</span> <span class="n">time</span> <span class="o">}</span>
<span class="k">end</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[2]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>module Sensor_msgs :
  sig
    type laserScan = {
      laserScan_range_min : int;
      laserScan_range_max : int;
      laserScan_ranges : int list;
    }
  end
module Rosgraph_msgs :
  sig
    type time = { seconds : int; nanoseconds : int; }
    type clock = { clock : time; }
  end
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Robotics OS middleware will communicate with our node via messages of these three types. The code that we'll write for of our node will represent the formal mathematical model of the controller algorithm - we can use Imandra to reason and verify various statements about the code. Since IML is valid OCaml, we'll leverage its compiler to create an executable from the verified IML code.</p>
<h1 id="2.-Creating-a-simple-ROS-Node-model">2. Creating a simple ROS Node model<a class="anchor-link" href="#2.-Creating-a-simple-ROS-Node-model">&#182;</a></h1><p>We want to create some simple but non-trivial robot controller that makes our bot drive around avoiding the obstacles. The bot is going to drive forward until one of the laser scanner ranges becomes too low, meaning that we've gotten too close to some obstacle - in that case, we want the bot to stop and turn until the scanner tells us that the road ahead is clear. To make the model a bit more complicated, we'd like to implement the ability to choose the turning direction depending on the laser scanner ranges.</p>
<p>One might try to make a "naive" controller that doesn't have any memory about its previous states and observations - such a bot reacts to the currently observed scanner values and decides its actions based solely on that information. Such an approach will quickly lead to the bot being "stuck" in infinite oscillatory loops. E.g. here is a bot that decides which side to turn depending on the first value in the <code>ranges</code> array:</p>
<p><img src="https://storage.googleapis.com/imandra-notebook-assets/ros/Stuck.gif" alt="Imandrabot"></p>
<p>To avoid this kind of oscillations we need the model to have some memory of its previous states. The idea is to introduce two modes of model's operation: driving forward and turning in one place. The bot is in the "driving" mode by default, but it can transition to the turning mode if it gets dangerously close to surrounding objects.</p>
<p>The turning direction is calculated using the direction of the minimum of the distances that the scanner returns. While the robot is turning in one place, it stores the minimal range that the scanner has detected at that location. If at some point the scanner detects a range that is lower than the stored one - the turning direction gets recalculated, and the minimal range gets updated.</p>
<h2 id="2.1-State-datatype">2.1 State datatype<a class="anchor-link" href="#2.1-State-datatype">&#182;</a></h2><p>Working with Imandra we’ve adopted a standard way to construct formal models of message-driven systems. At the top of the model we have a single OCaml datatype that holds all the data needed to describe the system at a given moment, including incoming and outgoing messages. We call this record type <code>state</code>. Together with this <code>state</code> type we define a <code>one_step</code> transition <code>state -&gt; state</code> function, which performs a single logically isolated step of the simulation and returns the new <code>state</code> after the transition.</p>
<p>As an example, consider an IML/OCaml type declaration for a simple ROS node that is able to accept <code>rosgraph_msgs/Clock</code> and <code>sensor_msgs/LaserScan</code> standard ROS messages. We also want the state to store three values:</p>
<ul>
<li>the current mode of the bot -- whether we are driving forward or turning in a preferred direction</li>
<li>the latest minimal value of the ranges that the laser sensor returns</li>
<li>the preferred side for the robot to turn -- either clockwise (<code>CW</code>) or counter-clockwise (<code>CCW</code>) </li>
</ul>
<p>Finally, we want the node to be able to send <code>geometry_msgs/Twist</code> ROS message depending on the stored <code>min_range</code> data:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-6" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">type</span> <span class="n">incoming_msg</span> <span class="o">=</span> 
  <span class="o">|</span> <span class="nc">Clock</span>  <span class="k">of</span> <span class="nn">Rosgraph_msgs</span><span class="p">.</span><span class="n">clock</span>
  <span class="o">|</span> <span class="nc">Sensor</span> <span class="k">of</span> <span class="nn">Sensor_msgs</span><span class="p">.</span><span class="n">laserScan</span>
  
<span class="k">type</span> <span class="n">outgoing_msg</span> <span class="o">=</span>
  <span class="o">|</span> <span class="nc">Twist</span> <span class="k">of</span> <span class="nn">Geometry_msgs</span><span class="p">.</span><span class="n">twist</span>

<span class="k">type</span> <span class="n">direction</span> <span class="o">=</span> <span class="nc">CW</span> <span class="o">|</span> <span class="nc">CCW</span> 

<span class="k">type</span> <span class="n">mode</span> <span class="o">=</span> <span class="nc">Driving</span> <span class="o">|</span> <span class="nc">Turning</span>

<span class="k">type</span> <span class="n">state</span> <span class="o">=</span>
  <span class="o">{</span> <span class="n">mode</span> <span class="o">:</span> <span class="n">mode</span>
  <span class="o">;</span> <span class="n">min_range</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">option</span>
  <span class="o">;</span> <span class="n">direction</span> <span class="o">:</span> <span class="n">direction</span> <span class="n">option</span>
  <span class="o">;</span> <span class="n">incoming</span>  <span class="o">:</span> <span class="n">incoming_msg</span> <span class="n">option</span>
  <span class="o">;</span> <span class="n">outgoing</span>  <span class="o">:</span> <span class="n">outgoing_msg</span> <span class="n">option</span> 
  <span class="o">}</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[3]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>type incoming_msg =
    Clock of Rosgraph_msgs.clock
  | Sensor of Sensor_msgs.laserScan
type outgoing_msg = Twist of Geometry_msgs.twist
type direction = CW | CCW
type mode = Driving | Turning
type state = {
  mode : mode;
  min_range : int option;
  direction : direction option;
  incoming : incoming_msg option;
  outgoing : outgoing_msg option;
}
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="2.2-State-transition-one_step-function">2.2 State transition <code>one_step</code> function<a class="anchor-link" href="#2.2-State-transition-one_step-function">&#182;</a></h2><p>To implement our node, we'll need a function that scans through a list of values and returns the minimum value and its index. We'll make a generic function <code>foldi</code> that does an indexed version of the <code>List.fold_right</code>:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-8" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">foldi</span> <span class="o">~</span><span class="n">base</span> <span class="o">?(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">)</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">l</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">base</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">::</span> <span class="n">tail</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">i</span> <span class="n">x</span> <span class="o">(</span> <span class="n">foldi</span> <span class="n">f</span> <span class="o">~</span><span class="n">base</span> <span class="o">~</span><span class="n">i</span><span class="o">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">tail</span> <span class="o">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[4]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val foldi : base:&#39;a -&gt; ?i:Z.t -&gt; (Z.t -&gt; &#39;b -&gt; &#39;a -&gt; &#39;a) -&gt; &#39;b list -&gt; &#39;a =
  &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-fold panel panel-default" id="fold-2dd44a87-1033-4a51-a700-7887e36d8623"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>termination proof</span></div></div><div class="panel-body collapse"><div><h3>Termination proof</h3><p></p><div class="imandra-fold panel panel-default" id="fold-e8a7c0ef-6d8d-4009-bdc3-40ee189f9291"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>call `foldi base (Some ((if Is_a(Some, *opt*) then Option.get *opt* else 0) + 1))
f_2 (List.tl l)` from `foldi base *opt* f_2 l`</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-0991ff3a-f14d-44e6-b94b-2ec2f5a1aee5"><table><tr><td><b>original</b></td><td>foldi base *opt* f_2 l</td></tr><tr><td><b>sub</b></td><td>foldi base (Some ((if Is_a(Some, *opt*) then Option.get *opt* else 0) + 1))
f_2 (List.tl l)</td></tr><tr><td><b>original ordinal</b></td><td>Ordinal.Int (Ordinal.count l)</td></tr><tr><td><b>sub ordinal</b></td><td>Ordinal.Int (Ordinal.count (List.tl l))</td></tr><tr><td><b>path</b></td><td>[not (l = [])]</td></tr><tr><td><b>proof</b></td><td><div class="imandra-fold panel panel-default" id="fold-39a1d038-736c-4cb6-b765-b207b6db5447"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>detailed proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-ba499275-074b-4574-b696-8dcda4dd9843"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-7e99bd5d-d34c-49d0-898b-3e0ab21be5ef"><table><tr><td><b>ground_instances</b></td><td>3</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.019s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-27303150-814d-46c7-ad17-1ac0e39faac1"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-369e3a46-180d-456e-b129-eed97069c8a1"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-e3485329-2907-4be1-9e93-96496bef8080"><table><tr><td><b>num checks</b></td><td>7</td></tr><tr><td><b>arith assert lower</b></td><td>7</td></tr><tr><td><b>arith pivots</b></td><td>5</td></tr><tr><td><b>rlimit count</b></td><td>1908</td></tr><tr><td><b>mk clause</b></td><td>3</td></tr><tr><td><b>datatype occurs check</b></td><td>43</td></tr><tr><td><b>mk bool var</b></td><td>54</td></tr><tr><td><b>arith assert upper</b></td><td>5</td></tr><tr><td><b>datatype splits</b></td><td>3</td></tr><tr><td><b>decisions</b></td><td>7</td></tr><tr><td><b>arith add rows</b></td><td>15</td></tr><tr><td><b>propagations</b></td><td>2</td></tr><tr><td><b>conflicts</b></td><td>7</td></tr><tr><td><b>arith fixed eqs</b></td><td>5</td></tr><tr><td><b>datatype accessor ax</b></td><td>5</td></tr><tr><td><b>arith conflicts</b></td><td>1</td></tr><tr><td><b>datatype constructor ax</b></td><td>8</td></tr><tr><td><b>num allocs</b></td><td>863369800</td></tr><tr><td><b>final checks</b></td><td>6</td></tr><tr><td><b>added eqs</b></td><td>34</td></tr><tr><td><b>del clause</b></td><td>1</td></tr><tr><td><b>arith eq adapter</b></td><td>4</td></tr><tr><td><b>memory</b></td><td>16.850000</td></tr><tr><td><b>max memory</b></td><td>19.240000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-27303150-814d-46c7-ad17-1ac0e39faac1';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-0c7ee139-e67b-41c1-aa3f-c6609e10a3be"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.019s]
  not (l = []) &amp;&amp; Ordinal.count l &gt;= 0 &amp;&amp; Ordinal.count (List.tl l) &gt;= 0
  ==&gt; List.tl l = []
      || Ordinal.Int (Ordinal.count (List.tl l)) Ordinal.&lt;&lt;
         Ordinal.Int (Ordinal.count l)</pre></li><li><div><h5>simplify</h5><div class="imandra-table" id="table-d2bb278c-1bce-479a-97e8-0aa9b93049fa"><table><tr><td><b>into</b></td><td><pre>(not
 ((not (l = []) &amp;&amp; Ordinal.count l &gt;= 0) &amp;&amp; Ordinal.count (List.tl l) &gt;= 0)
 || List.tl l = [])
|| Ordinal.Int (Ordinal.count (List.tl l)) Ordinal.&lt;&lt;
   Ordinal.Int (Ordinal.count l)</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-7602ee0a-2e2a-42b9-964e-2732726b9832"><table><tr><td><b>expr</b></td><td><pre>(|\|Ordinal.&lt;&lt;_121\||
  (|\|Ordinal.Int_112\||
    (|\|count_`ty_1 list`_2408\|| (|\|get.::.1_2386\|…</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-2b810613-3189-481d-820e-0624e7330043"><table><tr><td><b>expr</b></td><td><pre>(|\|count_`ty_1 list`_2408\|| (|\|get.::.1_2386\|| l_2397))</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-b75426c8-ae6d-4a88-9c18-850b0d5c7494"><table><tr><td><b>expr</b></td><td><pre>(|\|count_`ty_1 list`_2408\|| l_2397)</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div><h5>unsat</h5><pre>(let ((a!1 (ite (&gt;= (|\|count_`ty_1 list`_2408\|| (|\|get.::.1_2386\|| l_2397))
                    …</pre></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-0c7ee139-e67b-41c1-aa3f-c6609e10a3be';
  fold.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-ba499275-074b-4574-b696-8dcda4dd9843';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-39a1d038-736c-4cb6-b765-b207b6db5447';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-e8a7c0ef-6d8d-4009-bdc3-40ee189f9291';
  fold.hydrate(target);
});
</script></div><p></p></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-2dd44a87-1033-4a51-a700-7887e36d8623';
  fold.hydrate(target);
});
</script></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>When accepting this function, Imandra constructs its "termination proof" - that means that Imandra managed to prove that recursive calls in this function will not end up in an infinite loop. Imandra proves such things using inductive reasoning and is able to prove further statements about other properties of such functions.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-10" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="n">get_min_range</span> <span class="n">max</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="o">~</span><span class="n">base</span><span class="o">:</span><span class="n">max</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="k">then</span> <span class="n">x</span> <span class="k">else</span> <span class="n">a</span><span class="o">)</span> <span class="n">lst</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[5]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val get_min_range : int -&gt; int list -&gt; int = &lt;fun&gt;
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On an incoming <code>Clock</code> tick we are simply sending out a <code>Twist</code> message which tells the robot to either move forward or turn, depending on the mode that it is currently in. We encode it by introducing the <code>make_twist_message</code> helper function and the <code>process_clock_message : state -&gt; state</code> function.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-12" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="n">make_twist_message</span> <span class="n">v</span> <span class="n">omega</span><span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Geometry_msgs</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">mkvector</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span>  <span class="o">{</span> <span class="n">vector3_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span> <span class="n">vector3_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span> <span class="n">vector3_z</span> <span class="o">=</span> <span class="n">z</span>   <span class="o">}</span> <span class="k">in</span> 
  <span class="nc">Twist</span> <span class="o">{</span> <span class="n">twist_linear</span>  <span class="o">=</span> <span class="n">mkvector</span> <span class="n">v</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">twist_angular</span> <span class="o">=</span> <span class="n">mkvector</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">omega</span> <span class="o">}</span>

<span class="k">let</span> <span class="n">process_clock_message</span> <span class="n">state</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">state</span><span class="o">.</span><span class="n">mode</span> <span class="k">with</span> 
  <span class="o">|</span> <span class="nc">Driving</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">make_twist_message</span> <span class="mi">10000</span> <span class="mi">0</span><span class="o">)</span> <span class="o">}</span> 
  <span class="o">|</span> <span class="nc">Turning</span> <span class="o">-&gt;</span> <span class="k">begin</span>
  <span class="k">match</span> <span class="n">state</span><span class="o">.</span><span class="n">direction</span> <span class="k">with</span> 
    <span class="o">|</span> <span class="nc">None</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span> <span class="nc">CW</span> <span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">make_twist_message</span> <span class="mi">0</span>   <span class="mi">10000</span><span class="o">)</span> <span class="o">}</span> 
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nc">CCW</span> <span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">make_twist_message</span> <span class="mi">0</span> <span class="o">(-</span><span class="mi">10000</span><span class="o">))}</span> 
  <span class="k">end</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[6]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val make_twist_message : int -&gt; int -&gt; outgoing_msg = &lt;fun&gt;
val process_clock_message : state -&gt; state = &lt;fun&gt;
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>On incoming <code>Scan</code> message, we want to find the minimum of the received ranges and the index of that minimum in the list. Depending on the index, we decide in which direction to turn. To implement this, we create another helper function and the <code>process_sensor_message</code> one:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-14" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="n">get_min_and_direction</span> <span class="n">msg</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">max</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="nn">Sensor_msgs</span><span class="p">.</span><span class="n">laserScan_range_max</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">lst</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="nn">Sensor_msgs</span><span class="p">.</span><span class="n">laserScan_ranges</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">min_range</span> <span class="o">=</span> <span class="n">get_min_range</span> <span class="n">max</span> <span class="n">lst</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">mini</span> <span class="o">=</span> <span class="n">foldi</span> <span class="o">~</span><span class="n">base</span><span class="o">:(</span><span class="n">max</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">fst</span> <span class="n">b</span> <span class="k">then</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">i</span><span class="o">)</span> <span class="k">else</span> <span class="n">b</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="o">_</span> <span class="o">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">mini</span> <span class="n">lst</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">lst</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">then</span> <span class="n">min_range</span><span class="o">,</span> <span class="nc">CW</span> <span class="k">else</span> <span class="n">min_range</span><span class="o">,</span> <span class="nc">CCW</span>

<span class="k">let</span> <span class="n">process_sensor_message</span> <span class="n">state</span> <span class="n">min_range</span> <span class="n">min_direction</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">dirving_state</span> <span class="o">=</span> 
    <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> <span class="n">mode</span> <span class="o">=</span> <span class="nc">Driving</span><span class="o">;</span> <span class="n">min_range</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">direction</span> <span class="o">=</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">turning_state</span> <span class="o">=</span> 
    <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> 
      <span class="n">mode</span>      <span class="o">=</span> <span class="nc">Turning</span>
    <span class="o">;</span> <span class="n">direction</span> <span class="o">=</span> <span class="nc">Some</span> <span class="n">min_direction</span>
    <span class="o">;</span> <span class="n">min_range</span> <span class="o">=</span> <span class="nc">Some</span> <span class="n">min_range</span> 
    <span class="o">}</span> <span class="k">in</span>  
  <span class="k">match</span> <span class="n">state</span><span class="o">.</span><span class="n">mode</span> <span class="o">,</span> <span class="n">state</span><span class="o">.</span><span class="n">min_range</span> <span class="k">with</span> 
  <span class="o">|</span> <span class="nc">Driving</span> <span class="o">,</span> <span class="o">_</span>    <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">min_range</span> <span class="o">&lt;</span> <span class="mi">20000</span> <span class="k">then</span> <span class="n">turning_state</span> <span class="k">else</span> <span class="n">dirving_state</span>
  <span class="o">|</span> <span class="nc">Turning</span> <span class="o">,</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">min_range</span> <span class="o">&gt;</span> <span class="mi">25000</span> <span class="k">then</span> <span class="n">dirving_state</span> <span class="k">else</span> <span class="n">turning_state</span>
  <span class="o">|</span> <span class="nc">Turning</span> <span class="o">,</span> <span class="nc">Some</span> <span class="n">old_range</span> <span class="o">-&gt;</span> 
    <span class="k">if</span> <span class="n">min_range</span> <span class="o">&gt;</span> <span class="mi">25000</span> <span class="k">then</span> <span class="n">dirving_state</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">min_range</span> <span class="o">&gt;</span> <span class="n">old_range</span> <span class="k">then</span> <span class="n">state</span> <span class="k">else</span> <span class="n">turning_state</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[7]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val get_min_and_direction : Sensor_msgs.laserScan -&gt; int * direction = &lt;fun&gt;
val process_sensor_message : state -&gt; int -&gt; direction -&gt; state = &lt;fun&gt;
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With the help of these functions, we can create our <code>one_step</code> transition function, which just dispatches the messages to the appropriate helper function above.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-16" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[8]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="n">one_step</span> <span class="n">state</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">state</span><span class="o">.</span><span class="n">incoming</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">state</span> <span class="o">|</span> <span class="nc">Some</span> <span class="n">in_msg</span> <span class="o">-&gt;</span>
  <span class="k">let</span> <span class="n">state</span> <span class="o">=</span> <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> <span class="n">incoming</span> <span class="o">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">outgoing</span> <span class="o">=</span> <span class="nc">None</span> <span class="o">}</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">in_msg</span> <span class="k">with</span> 
  <span class="o">|</span> <span class="nc">Sensor</span> <span class="n">laserScan</span> <span class="o">-&gt;</span> 
    <span class="k">let</span> <span class="n">min_range</span><span class="o">,</span> <span class="n">min_direction</span> <span class="o">=</span> <span class="n">get_min_and_direction</span> <span class="n">laserScan</span> <span class="k">in</span>
    <span class="n">process_sensor_message</span> <span class="n">state</span> <span class="n">min_range</span> <span class="n">min_direction</span>
  <span class="o">|</span> <span class="nc">Clock</span>  <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">process_clock_message</span> <span class="n">state</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[8]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val one_step : state -&gt; state = &lt;fun&gt;
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="2.3-Running-the-model-as-a-ROS-node">2.3 Running the model as a ROS node<a class="anchor-link" href="#2.3-Running-the-model-as-a-ROS-node">&#182;</a></h2><p>Now that we have an early model, let's compile it with our ROS node wrapper into an executable. Here is the model, controlling our "imandrabot" in the Gazebo simulation environment:</p>
<p><img src="https://storage.googleapis.com/imandra-notebook-assets/ros/Imandra_Demo.gif" alt="Imandrabot"></p>
<h1 id="3.-Verifying-the-ROS-node-model">3. Verifying the ROS node model<a class="anchor-link" href="#3.-Verifying-the-ROS-node-model">&#182;</a></h1><p>Formal verification is the process of reasoning mathematically about the correctness of computer programs. We'll use Imandra to formally verify some properties of the ROS node model we've created.</p>
<h2 id="3.1-Verifying-outgoing-Twist-message-at-Clock-ticks">3.1 Verifying outgoing <code>Twist</code> message at <code>Clock</code> ticks<a class="anchor-link" href="#3.1-Verifying-outgoing-Twist-message-at-Clock-ticks">&#182;</a></h2><p>Our model is designed in such a way that it updates its state parameters upon <code>LaserScan</code> messages and sends out <code>Twist</code> control messages in response to <code>Clock</code> messages. Let's verify a simple theorem that on every incoming <code>Clock</code> message, there is an outgoing <code>Twist</code> message.</p>
<p>We can formally write this statement down as:</p>
<p>$$ \forall s. IsClock(IncomingMessage(s)) \,\Rightarrow\, IsTwist(OutgoingMessage(OneStep(s))) $$</p>
<p>eaning that for every state $s$, if the state contains an incoming message and this message is a <code>Clock</code> message, then the state's <code>outgoing</code> message is a <code>Twist</code> after we've called <code>one_step</code> on it.</p>
<p>We can almost literally encode this formal expression as an Imandra <code>theorem</code>:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-18" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[9]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="n">is_clock</span> <span class="n">msg</span> <span class="o">=</span> <span class="k">match</span> <span class="n">msg</span> <span class="k">with</span>  <span class="nc">Some</span> <span class="o">(</span> <span class="nc">Clock</span> <span class="o">_</span> <span class="o">)</span> <span class="o">-&gt;</span> <span class="bp">true</span> <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span> <span class="o">;;</span>
<span class="k">let</span> <span class="n">is_twist</span> <span class="n">msg</span> <span class="o">=</span> <span class="k">match</span> <span class="n">msg</span> <span class="k">with</span>  <span class="nc">Some</span> <span class="o">(</span> <span class="nc">Twist</span> <span class="o">_</span> <span class="o">)</span> <span class="o">-&gt;</span> <span class="bp">true</span> <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span> <span class="o">;;</span>

<span class="n">theorem</span> <span class="n">clock_creates_outbound</span> <span class="n">state</span> <span class="o">=</span>
  <span class="n">is_clock</span> <span class="n">state</span><span class="o">.</span><span class="n">incoming</span> <span class="o">==&gt;</span> <span class="n">is_twist</span> <span class="o">(</span><span class="n">one_step</span> <span class="n">state</span><span class="o">).</span><span class="n">outgoing</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[9]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val is_clock : incoming_msg option -&gt; bool = &lt;fun&gt;
val is_twist : outgoing_msg option -&gt; bool = &lt;fun&gt;
val clock_creates_outbound : state -&gt; bool = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-vr imandra-vr-proved"><i class="fa fa-check-circle"></i><span>Proved</span></div><div><div class="imandra-alternatives" id="alt-ca6d21e3-4b94-4eba-abcd-3972203cec47"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>proof</a></li><li class="" data-toggle="tab"><a>call graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-16f20980-0738-48ba-a0e8-57fa208095dc"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-3ef6f4ef-265a-4df3-a252-f2d720a47fbd"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-0cfdab3c-c40e-4dbb-8b5b-b0d6ace847d2"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.010s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-4798e40f-2d41-4527-8807-87e0ff7da595"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-db7f3e04-08a4-41e5-b663-b92ad65c4f51"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-7e105aa7-0401-4f96-a312-4cf19f17c228"><table><tr><td><b>num checks</b></td><td>2</td></tr><tr><td><b>arith assert lower</b></td><td>2</td></tr><tr><td><b>rlimit count</b></td><td>1801</td></tr><tr><td><b>mk clause</b></td><td>39</td></tr><tr><td><b>mk bool var</b></td><td>209</td></tr><tr><td><b>arith assert upper</b></td><td>2</td></tr><tr><td><b>datatype splits</b></td><td>26</td></tr><tr><td><b>decisions</b></td><td>17</td></tr><tr><td><b>propagations</b></td><td>35</td></tr><tr><td><b>conflicts</b></td><td>10</td></tr><tr><td><b>datatype accessor ax</b></td><td>47</td></tr><tr><td><b>datatype constructor ax</b></td><td>33</td></tr><tr><td><b>num allocs</b></td><td>909911854</td></tr><tr><td><b>added eqs</b></td><td>284</td></tr><tr><td><b>del clause</b></td><td>3</td></tr><tr><td><b>arith eq adapter</b></td><td>1</td></tr><tr><td><b>memory</b></td><td>17.400000</td></tr><tr><td><b>max memory</b></td><td>19.240000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-4798e40f-2d41-4527-8807-87e0ff7da595';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-1fbff7dd-d98c-4884-9c7c-c9e3a25b894f"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.010s]
  (if Is_a(Clock, Option.get :var_0:.incoming)
      &amp;&amp; Is_a(Some, :var_0:.incoming)
   then true else false)
  ==&gt; (if Is_a(Twist,
          Option.get
          (if :var_0:.incoming = None then :var_0: else …).outgoing)
          &amp;&amp; Is_a(Some,
             (if :var_0:.incoming = None then :var_0: else …).outgoing)
       then true else false)</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-818d5ad3-1b69-4bfe-b085-1a1a51fde12e"><table><tr><td><b>into</b></td><td><pre>not
(Is_a(Clock, Option.get :var_0:.incoming) &amp;&amp; Is_a(Some, :var_0:.incoming))
|| Is_a(Twist,
   Option.get (if :var_0:.incoming = None then :var_0: else …).outgoing)
   &amp;&amp; Is_a(Some, (if :var_0:.incoming = None then :var_0: else …).outgoing)</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div><h4>unsat</h4><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2534\||
          …</pre></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-1fbff7dd-d98c-4884-9c7c-c9e3a25b894f';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-01727983-e28b-4a82-9147-4fc68ab22802"><textarea style="display: none">digraph &quot;proof&quot; {
p_273 [label=&quot;Start ((if Is_a(Clock, Option.get :var_0:.incoming)\l           &amp;&amp; Is_a(Some, :var_0:.incoming)\l        then true else false)\l       ==\&gt; (if Is_a(Twist,\l               Option.get\l               (if :var_0:.incoming = None then :var_0: else …).outgoing)\l               &amp;&amp; Is_a(Some,\l                  (if :var_0:.incoming = None then :var_0: else …).outgoing)\l            then true else false)\l       :time 0.010s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_273 -&gt; p_272 [label=&quot;&quot;];
p_272 [label=&quot;Simplify (not\l          (Is_a(Clock, Option.get :var_0:.incoming)\l           &amp;&amp; Is_a(Some, :var_0:.incoming))\l          \|\| Is_a(Twist,\l             Option.get\l             (if :var_0:.incoming = None then :var_0: else …).outgoing)\l             &amp;&amp; Is_a(Some,\l                (if :var_0:.incoming = None then :var_0: else …).outgoing)\l          :expansions [] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_272 -&gt; p_271 [label=&quot;&quot;];
p_271 -&gt; p_z3_1031 [label=&quot;&quot;,fontname=&quot;courier&quot;,fontsize=14];
p_z3_1031 [label=&quot;(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2534\||
          …&quot;,shape=box,fontname=&quot;courier&quot;,fontsize=14];p_271 [label=&quot;unsat&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-01727983-e28b-4a82-9147-4fc68ab22802';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-3ef6f4ef-265a-4df3-a252-f2d720a47fbd';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-16f20980-0738-48ba-a0e8-57fa208095dc';
  fold.hydrate(target);
});
</script></div></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-9e9db671-939c-4547-8e7e-790b6add6490"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;not\l(not (Is_a(Clock, Option.get state.incoming) &amp;&amp; Is_a(Some, state.incoming))\l \|\| Is_a(Twist,\l    Option.get (if state.incoming = None then state else …).outgoing)\l    &amp;&amp; Is_a(Some, (if state.incoming = None then state else …).outgoing))&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_233 [label=&quot;List.length\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_233 [label=&quot;calls&quot;];
call_238 [label=&quot;foldi ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0) None\lanon_fun.get_min_and_direction.0\l(Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_238 [label=&quot;calls&quot;];
call_192 [label=&quot;List.fold_right anon_fun.get_min_range.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_192 [label=&quot;calls&quot;];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-9e9db671-939c-4547-8e7e-790b6add6490';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-ca6d21e3-4b94-4eba-abcd-3972203cec47';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>One can see that Imandra says that it "Proved" the theorem, meaning that Imandra has formally checked that this property holds for all possible input states.</p>
<h2 id="3.2-Verifying-that-we-never-drive-backwards">3.2 Verifying that we never drive backwards<a class="anchor-link" href="#3.2-Verifying-that-we-never-drive-backwards">&#182;</a></h2><p>As another example, let us check that, no matter what, the node will never send out a message with negative linear velocity.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-20" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[10]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="n">no_moving_back</span> <span class="n">msg</span> <span class="o">=</span> 
    <span class="k">let</span> <span class="k">open</span> <span class="nc">Geometry_msgs</span> <span class="k">in</span>
    <span class="k">match</span> <span class="n">msg</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">true</span> 
    <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nc">Twist</span> <span class="n">data</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">twist_linear</span><span class="o">.</span><span class="n">vector3_x</span> <span class="o">&gt;=</span> <span class="mi">0</span>
  
<span class="n">verify</span> <span class="o">(</span> <span class="k">fun</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="n">no_moving_back</span> <span class="o">(</span><span class="n">one_step</span> <span class="n">state</span><span class="o">).</span><span class="n">outgoing</span>  <span class="o">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[10]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val no_moving_back : outgoing_msg option -&gt; bool = &lt;fun&gt;
- : state -&gt; bool = &lt;fun&gt;
module CX : sig val state : state end
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><pre>Counterexample (after 3 steps, 0.022s):
 let state =
   {mode = Turning; min_range = (Some 2282); direction = None;
    incoming = None;
    outgoing =
     (Some
      (Twist
         ({Geometry_msgs.twist_linear =
            {Geometry_msgs.vector3_x = (-1); Geometry_msgs.vector3_y = 9;
             Geometry_msgs.vector3_z = 10};
           Geometry_msgs.twist_angular =
            {Geometry_msgs.vector3_x = 11; Geometry_msgs.vector3_y = 12;
             Geometry_msgs.vector3_z = 13}})))}
</pre></div>

</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-vr imandra-vr-refuted"><i class="fa fa-times-circle-o"></i><span>Refuted</span></div><div><div class="imandra-alternatives" id="alt-5bd79e0c-7220-4cdd-bd31-af4fd5954e8e"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>call graph</a></li><li class="" data-toggle="tab"><a>proof-attempt</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-graphviz" id="graphviz-72d5b424-e010-4689-8f4c-4a8c13e26ecc"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;not\l((if state.incoming = None then state\l  else\l  if Is_a(Sensor, Option.get state.incoming)\l  then if state.mode = Driving then … else …\l  else if state.mode = Driving then … else …).outgoing\l = None\l \|\| (Destruct(Twist, 0,\l              Option.get\l              (if state.incoming = None then state\l               else\l               if Is_a(Sensor, Option.get state.incoming)\l               then if state.mode = Driving then … else …\l               else if state.mode = Driving then … else …).outgoing)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x\l    \&gt;= 0)&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_175 [label=&quot;List.length\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_175 -&gt; expr_1349 [label=&quot;=&quot;];
expr_1349 [label=&quot;if (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\l   = []\lthen 0\lelse\l  1\l  + List.length\l    (List.tl\l     (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_175 [label=&quot;calls&quot;];
call_215 [label=&quot;foldi ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0) None\lanon_fun.get_min_and_direction.0\l(Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_215 -&gt; expr_1180 [label=&quot;=&quot;];
expr_1180 [label=&quot;if (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\l   = []\lthen\l  ((Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max,\l   0)\lelse\lif (foldi\l    ((Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max,\l     0)\l    (Some …) anon_fun.get_min_and_direction.0\l    (List.tl\l     (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)).0\l   \&lt;=\l   List.hd\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\lthen\l  foldi\l  ((Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max,\l   0)\l  (Some …) anon_fun.get_min_and_direction.0\l  (List.tl\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\lelse\l  (List.hd\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges,\l   if Is_a(Some, …) then … else 0)&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_215 [label=&quot;calls&quot;];
call_1174 [label=&quot;foldi ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0)\l(Some (1 + 0)) anon_fun.get_min_and_direction.0\l(List.tl (Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1180 -&gt; call_1174 [label=&quot;calls&quot;];
expr_1180 -&gt; call_1174 [label=&quot;calls&quot;];
call_1059 [label=&quot;List.fold_right anon_fun.get_min_range.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l(List.tl (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1064 -&gt; call_1059 [label=&quot;calls&quot;];
expr_1064 -&gt; call_1059 [label=&quot;calls&quot;];
call_198 [label=&quot;List.fold_right anon_fun.get_min_range.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_198 -&gt; expr_1064 [label=&quot;=&quot;];
expr_1064 [label=&quot;if (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\l   = []\lthen\l  (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max\lelse\lif List.fold_right anon_fun.get_min_range.0\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max\l   (List.tl\l    (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\l   \&lt;=\l   List.hd\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\lthen\l  List.fold_right anon_fun.get_min_range.0\l  (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max\l  (List.tl\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\lelse\l  List.hd\l  (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_198 [label=&quot;calls&quot;];
call_1347 [label=&quot;List.length\l(List.tl (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1349 -&gt; call_1347 [label=&quot;calls&quot;];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-72d5b424-e010-4689-8f4c-4a8c13e26ecc';
  graphviz.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-93f1c76d-ca41-4b18-a502-ebcdada22088"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof attempt</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-92e1ab60-2205-4500-9892-3bf9b0a3b55a"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-a9002324-16ea-4b36-ab0a-93e465a712f0"><table><tr><td><b>ground_instances</b></td><td>3</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.022s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-02ddd842-664c-4e83-9cc9-6cd7157cd1a4"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-e0dfbf6e-06fc-4f77-8c2f-ffab0f89fd72"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-1f51956f-15f3-4292-9a7c-12f7f4f096b9"><table><tr><td><b>arith offset eqs</b></td><td>2</td></tr><tr><td><b>num checks</b></td><td>7</td></tr><tr><td><b>arith assert lower</b></td><td>5</td></tr><tr><td><b>arith pivots</b></td><td>2</td></tr><tr><td><b>rlimit count</b></td><td>5645</td></tr><tr><td><b>mk clause</b></td><td>57</td></tr><tr><td><b>datatype occurs check</b></td><td>1326</td></tr><tr><td><b>mk bool var</b></td><td>477</td></tr><tr><td><b>arith assert upper</b></td><td>13</td></tr><tr><td><b>datatype splits</b></td><td>46</td></tr><tr><td><b>decisions</b></td><td>251</td></tr><tr><td><b>arith add rows</b></td><td>1</td></tr><tr><td><b>propagations</b></td><td>239</td></tr><tr><td><b>conflicts</b></td><td>13</td></tr><tr><td><b>datatype accessor ax</b></td><td>77</td></tr><tr><td><b>datatype constructor ax</b></td><td>218</td></tr><tr><td><b>num allocs</b></td><td>966631565</td></tr><tr><td><b>final checks</b></td><td>10</td></tr><tr><td><b>added eqs</b></td><td>1031</td></tr><tr><td><b>del clause</b></td><td>4</td></tr><tr><td><b>arith eq adapter</b></td><td>4</td></tr><tr><td><b>memory</b></td><td>18.470000</td></tr><tr><td><b>max memory</b></td><td>19.240000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-02ddd842-664c-4e83-9cc9-6cd7157cd1a4';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-e857c3f6-8f50-4223-9a03-0183d2e24efa"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.022s]
  if (if :var_0:.incoming = None then :var_0:
      else
      if Is_a(Sensor, Option.get :var_0:.incoming)
      then if ….mode = Driving then … else …
      else if ….mode = Driving then … else …).outgoing
     = None
  then true
  else
    (Destruct(Twist, 0, …)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x
    &gt;= 0</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-c70bd450-6842-4179-b9bf-1983e9516061"><table><tr><td><b>into</b></td><td><pre>(if :var_0:.incoming = None then :var_0:
 else
 if Is_a(Sensor, Option.get :var_0:.incoming)
 then if :var_0:.mode = Driving then … else …
 else if :var_0:.mode = Driving then … else …).outgoing
= None
|| (Destruct(Twist, 0,
             Option.get
             (if :var_0:.incoming = None then :var_0:
              else
              if Is_a(Sensor, Option.get :var_0:.incoming)
              then if :var_0:.mode = Driving then … else …
              else if :var_0:.mode = Driving then … else …).outgoing)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x
   &gt;= 0</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-1a0a0759-db71-4b31-92f1-5fbbf2bbe887"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_range_max_2309\||
             (|\|get.Sensor.0_2599\||
       …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-5b5f8af7-b25a-47ae-9404-40a9a7745231"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_range_max_2309\||
             (|\|get.Sensor.0_2599\||
       …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-fc08cc62-276e-4ee6-bbce-5932a094c07f"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2599\||
          …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li>Sat (Some  let state =
   {mode = Turning; min_range = (Some 2282); direction = None;
    incoming = None;
    outgoing =
     (Some
      (Twist
         ({Geometry_msgs.twist_linear =
            {Geometry_msgs.vector3_x = (-1); Geometry_msgs.vector3_y = 9;
             Geometry_msgs.vector3_z = 10};
           Geometry_msgs.twist_angular =
            {Geometry_msgs.vector3_x = 11; Geometry_msgs.vector3_y = 12;
             Geometry_msgs.vector3_z = 13}})))}
)</li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-e857c3f6-8f50-4223-9a03-0183d2e24efa';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-794871d0-e033-4cb2-ab62-34cd1d755432"><textarea style="display: none">digraph &quot;proof&quot; {
p_279 [label=&quot;Start (if (if :var_0:.incoming = None then :var_0:\l           else\l           if Is_a(Sensor, Option.get :var_0:.incoming)\l           then if ….mode = Driving then … else …\l           else if ….mode = Driving then … else …).outgoing\l          = None\l       then true\l       else\l         (Destruct(Twist, 0, …)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x\l         \&gt;= 0\l       :time 0.022s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_279 -&gt; p_278 [label=&quot;&quot;];
p_278 [label=&quot;Simplify ((if :var_0:.incoming = None then :var_0:\l           else\l           if Is_a(Sensor, Option.get :var_0:.incoming)\l           then if :var_0:.mode = Driving then … else …\l           else if :var_0:.mode = Driving then … else …).outgoing\l          = None\l          \|\| (Destruct(Twist, 0,\l                       Option.get\l                       (if :var_0:.incoming = None then :var_0:\l                        else\l                        if Is_a(Sensor, Option.get :var_0:.incoming)\l                        then if :var_0:.mode = Driving then … else …\l                        else if :var_0:.mode = Driving then … else …).outgoing)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x\l             \&gt;= 0\l          :expansions [] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_278 -&gt; p_277 [label=&quot;&quot;];
p_277 [label=&quot;Unroll ([List.fold_right anon_fun.get_min_range.0\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_277 -&gt; p_276 [label=&quot;&quot;];
p_276 [label=&quot;Unroll ([foldi\l         ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0) None\l         anon_fun.get_min_and_direction.0\l         (Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_276 -&gt; p_275 [label=&quot;&quot;];
p_275 [label=&quot;Unroll ([List.length\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_275 -&gt; p_274 [label=&quot;&quot;];
p_274 [label=&quot;Sat (Some  let state =\l   \{mode = Turning; min_range = (Some 2282); direction = None;\l    incoming = None;\l    outgoing =\l     (Some\l      (Twist\l         (\{Geometry_msgs.twist_linear =\l            \{Geometry_msgs.vector3_x = (-1); Geometry_msgs.vector3_y = 9;\l             Geometry_msgs.vector3_z = 10\};\l           Geometry_msgs.twist_angular =\l            \{Geometry_msgs.vector3_x = 11; Geometry_msgs.vector3_y = 12;\l             Geometry_msgs.vector3_z = 13\}\})))\}\l)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-794871d0-e033-4cb2-ab62-34cd1d755432';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-92e1ab60-2205-4500-9892-3bf9b0a3b55a';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-93f1c76d-ca41-4b18-a502-ebcdada22088';
  fold.hydrate(target);
});
</script></div></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-5bd79e0c-7220-4cdd-bd31-af4fd5954e8e';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We have failed to prove the statement and Imandra have created a counterexample <code>CX</code> module for us. This module  contains concrete values for the parameters of the verified statement, that violate the statement's condition. Let's examine the value of <code>CX.state</code>:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-22" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[11]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="nn">CX</span><span class="p">.</span><span class="n">state</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[11]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : state =
{mode = Turning; min_range = Some 2282; direction = None; incoming = None;
 outgoing =
  Some
   (Twist
     {Geometry_msgs.twist_linear =
       {Geometry_msgs.vector3_x = -1; vector3_y = 9; vector3_z = 10};
      twist_angular =
       {Geometry_msgs.vector3_x = 11; vector3_y = 12; vector3_z = 13}})}
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The counterexample <code>state</code> produced by imandra has the <code>incoming</code> message set to <code>None</code> and the <code>outgoing</code> message set to a <code>Twist</code> message with negative <code>linear.x</code>. Our <code>one_step</code> function keeps the state unchanged if the incoming message is empty.</p>
<p>We can either consider this behavior as a bug and change our <code>one_step</code> implementation; or we can consider this a normal behavior and amend our theorem, adding the non-empty incoming message as an extra premise of the theorem:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-24" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[12]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">theorem</span> <span class="n">never_goes_back</span> <span class="n">state</span> <span class="o">=</span> 
  <span class="n">state</span><span class="o">.</span><span class="n">incoming</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span>
  <span class="o">==&gt;</span>
  <span class="n">no_moving_back</span> <span class="o">(</span><span class="n">one_step</span> <span class="n">state</span><span class="o">).</span><span class="n">outgoing</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[12]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val never_goes_back : state -&gt; bool = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-vr imandra-vr-proved"><i class="fa fa-check-circle"></i><span>Proved</span></div><div><div class="imandra-alternatives" id="alt-046c39e2-78d9-4ffb-96ac-7ff85ccf3071"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>proof</a></li><li class="" data-toggle="tab"><a>call graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-0ec58a55-5385-4bd3-a847-cb9f3803371a"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-ab848bee-6518-4eec-9da5-61a38bd0d446"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-9af4443d-a2ea-4782-9813-fe34a0084f14"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.009s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-50494c7f-d44f-48ca-a9c0-49b369e1df12"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-69a5e7b9-bb12-48f8-b3db-7d0be68a3fa7"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-ca6bb978-3b64-4cb7-8af6-f7f7b6018e67"><table><tr><td><b>num checks</b></td><td>2</td></tr><tr><td><b>arith assert lower</b></td><td>5</td></tr><tr><td><b>rlimit count</b></td><td>2374</td></tr><tr><td><b>mk clause</b></td><td>48</td></tr><tr><td><b>mk bool var</b></td><td>282</td></tr><tr><td><b>arith assert upper</b></td><td>12</td></tr><tr><td><b>datatype splits</b></td><td>28</td></tr><tr><td><b>decisions</b></td><td>56</td></tr><tr><td><b>propagations</b></td><td>162</td></tr><tr><td><b>conflicts</b></td><td>21</td></tr><tr><td><b>datatype accessor ax</b></td><td>57</td></tr><tr><td><b>minimized lits</b></td><td>7</td></tr><tr><td><b>arith assert diseq</b></td><td>2</td></tr><tr><td><b>datatype constructor ax</b></td><td>74</td></tr><tr><td><b>num allocs</b></td><td>994561183</td></tr><tr><td><b>added eqs</b></td><td>534</td></tr><tr><td><b>del clause</b></td><td>3</td></tr><tr><td><b>arith eq adapter</b></td><td>5</td></tr><tr><td><b>memory</b></td><td>21.470000</td></tr><tr><td><b>max memory</b></td><td>21.470000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-50494c7f-d44f-48ca-a9c0-49b369e1df12';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-5cf70052-2aad-498b-aea8-ce480a8ee260"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.009s]
  not (:var_0:.incoming = None)
  ==&gt; (if (if :var_0:.incoming = None then :var_0:
           else
           if Is_a(Sensor, Option.get :var_0:.incoming)
           then if ….mode = Driving then … else …
           else if ….mode = Driving then … else …).outgoing
          = None
       then true
       else
         (Destruct(Twist, 0, …)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x
         &gt;= 0)</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-3586d253-54d3-4114-9d88-6553cab9c9cc"><table><tr><td><b>into</b></td><td><pre>(:var_0:.incoming = None
 || (if :var_0:.incoming = None then :var_0:
     else
     if Is_a(Sensor, Option.get :var_0:.incoming)
     then if :var_0:.mode = Driving then … else …
     else if :var_0:.mode = Driving then … else …).outgoing
    = None)
|| (Destruct(Twist, 0,
             Option.get
             (if :var_0:.incoming = None then :var_0:
              else
              if Is_a(Sensor, Option.get :var_0:.incoming)
              then if :var_0:.mode = Driving then … else …
              else if :var_0:.mode = Driving then … else …).outgoing)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x
   &gt;= 0</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div><h4>unsat</h4><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2693\||
          …</pre></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-5cf70052-2aad-498b-aea8-ce480a8ee260';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-1c7dcc28-5c0f-4940-8356-3a4110c0d3d0"><textarea style="display: none">digraph &quot;proof&quot; {
p_282 [label=&quot;Start (not (:var_0:.incoming = None)\l       ==\&gt; (if (if :var_0:.incoming = None then :var_0:\l                else\l                if Is_a(Sensor, Option.get :var_0:.incoming)\l                then if ….mode = Driving then … else …\l                else if ….mode = Driving then … else …).outgoing\l               = None\l            then true\l            else\l              (Destruct(Twist, 0, …)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x\l              \&gt;= 0)\l       :time 0.009s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_282 -&gt; p_281 [label=&quot;&quot;];
p_281 [label=&quot;Simplify ((:var_0:.incoming = None\l           \|\| (if :var_0:.incoming = None then :var_0:\l               else\l               if Is_a(Sensor, Option.get :var_0:.incoming)\l               then if :var_0:.mode = Driving then … else …\l               else if :var_0:.mode = Driving then … else …).outgoing\l              = None)\l          \|\| (Destruct(Twist, 0,\l                       Option.get\l                       (if :var_0:.incoming = None then :var_0:\l                        else\l                        if Is_a(Sensor, Option.get :var_0:.incoming)\l                        then if :var_0:.mode = Driving then … else …\l                        else if :var_0:.mode = Driving then … else …).outgoing)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x\l             \&gt;= 0\l          :expansions [] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_281 -&gt; p_280 [label=&quot;&quot;];
p_280 -&gt; p_z3_1376 [label=&quot;&quot;,fontname=&quot;courier&quot;,fontsize=14];
p_z3_1376 [label=&quot;(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2693\||
          …&quot;,shape=box,fontname=&quot;courier&quot;,fontsize=14];p_280 [label=&quot;unsat&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-1c7dcc28-5c0f-4940-8356-3a4110c0d3d0';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-ab848bee-6518-4eec-9da5-61a38bd0d446';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-0ec58a55-5385-4bd3-a847-cb9f3803371a';
  fold.hydrate(target);
});
</script></div></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-1b578b93-5565-4852-a037-b0fb9232d3ef"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;not\l((state.incoming = None\l  \|\| (if state.incoming = None then state\l      else\l      if Is_a(Sensor, Option.get state.incoming)\l      then if state.mode = Driving then … else …\l      else if state.mode = Driving then … else …).outgoing\l     = None)\l \|\| (Destruct(Twist, 0,\l              Option.get\l              (if state.incoming = None then state\l               else\l               if Is_a(Sensor, Option.get state.incoming)\l               then if state.mode = Driving then … else …\l               else if state.mode = Driving then … else …).outgoing)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x\l    \&gt;= 0)&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_162 [label=&quot;List.fold_right anon_fun.get_min_range.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_162 [label=&quot;calls&quot;];
call_177 [label=&quot;List.length\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_177 [label=&quot;calls&quot;];
call_180 [label=&quot;foldi ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0) None\lanon_fun.get_min_and_direction.0\l(Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_180 [label=&quot;calls&quot;];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-1b578b93-5565-4852-a037-b0fb9232d3ef';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-046c39e2-78d9-4ffb-96ac-7ff85ccf3071';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We've proven that the model never creates negative linear speed in response to any incoming message - alternatively we can set <code>state.outgoing = None</code> as a premise, proving that an empty <code>outgoing</code> message is never filled with a <code>Twist</code> with negative velocity:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-26" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[13]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">theorem</span> <span class="n">never_goes_back_alt</span> <span class="n">state</span> <span class="o">=</span> 
  <span class="n">state</span><span class="o">.</span><span class="n">outgoing</span> <span class="o">=</span> <span class="nc">None</span>
  <span class="o">==&gt;</span>
  <span class="n">no_moving_back</span> <span class="o">(</span><span class="n">one_step</span> <span class="n">state</span><span class="o">).</span><span class="n">outgoing</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[13]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val never_goes_back_alt : state -&gt; bool = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-vr imandra-vr-proved"><i class="fa fa-check-circle"></i><span>Proved</span></div><div><div class="imandra-alternatives" id="alt-ca620745-35ee-42d9-82d5-72895d030284"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>proof</a></li><li class="" data-toggle="tab"><a>call graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-51f713a1-2dc3-40ce-add2-eb653c32efad"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-e7380655-a24a-4d7f-ace0-ca6dea7e5011"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-d99e0768-b4ca-4341-8ba6-f511c632b248"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.009s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-7da18458-06ea-40e1-94b0-5c7b25dd9ac2"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-e7cefcd9-cbb8-46aa-9f77-4ec3d4c8b87b"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-de61aca0-9e34-4b74-945e-9285ded7f153"><table><tr><td><b>num checks</b></td><td>2</td></tr><tr><td><b>arith assert lower</b></td><td>3</td></tr><tr><td><b>rlimit count</b></td><td>2521</td></tr><tr><td><b>mk clause</b></td><td>51</td></tr><tr><td><b>mk bool var</b></td><td>265</td></tr><tr><td><b>arith assert upper</b></td><td>10</td></tr><tr><td><b>datatype splits</b></td><td>27</td></tr><tr><td><b>decisions</b></td><td>53</td></tr><tr><td><b>propagations</b></td><td>178</td></tr><tr><td><b>conflicts</b></td><td>23</td></tr><tr><td><b>datatype accessor ax</b></td><td>58</td></tr><tr><td><b>minimized lits</b></td><td>5</td></tr><tr><td><b>arith assert diseq</b></td><td>2</td></tr><tr><td><b>datatype constructor ax</b></td><td>63</td></tr><tr><td><b>num allocs</b></td><td>1063770730</td></tr><tr><td><b>added eqs</b></td><td>495</td></tr><tr><td><b>del clause</b></td><td>5</td></tr><tr><td><b>arith eq adapter</b></td><td>5</td></tr><tr><td><b>memory</b></td><td>22.870000</td></tr><tr><td><b>max memory</b></td><td>22.870000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-7da18458-06ea-40e1-94b0-5c7b25dd9ac2';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-9d8087d5-3114-487a-a008-5f97027ac2db"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.009s]
  :var_0:.outgoing = None
  ==&gt; (if (if :var_0:.incoming = None then :var_0:
           else
           if Is_a(Sensor, Option.get :var_0:.incoming)
           then if ….mode = Driving then … else …
           else if ….mode = Driving then … else …).outgoing
          = None
       then true
       else
         (Destruct(Twist, 0, …)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x
         &gt;= 0)</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-326838f9-5136-4edd-9b42-e086c4328f19"><table><tr><td><b>into</b></td><td><pre>(not (:var_0:.outgoing = None)
 || (if :var_0:.incoming = None then :var_0:
     else
     if Is_a(Sensor, Option.get :var_0:.incoming)
     then if :var_0:.mode = Driving then … else …
     else if :var_0:.mode = Driving then … else …).outgoing
    = None)
|| (Destruct(Twist, 0,
             Option.get
             (if :var_0:.incoming = None then :var_0:
              else
              if Is_a(Sensor, Option.get :var_0:.incoming)
              then if :var_0:.mode = Driving then … else …
              else if :var_0:.mode = Driving then … else …).outgoing)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x
   &gt;= 0</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div><h4>unsat</h4><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2772\||
          …</pre></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-9d8087d5-3114-487a-a008-5f97027ac2db';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-98e65006-5ab5-4128-8459-f117be98539d"><textarea style="display: none">digraph &quot;proof&quot; {
p_285 [label=&quot;Start (:var_0:.outgoing = None\l       ==\&gt; (if (if :var_0:.incoming = None then :var_0:\l                else\l                if Is_a(Sensor, Option.get :var_0:.incoming)\l                then if ….mode = Driving then … else …\l                else if ….mode = Driving then … else …).outgoing\l               = None\l            then true\l            else\l              (Destruct(Twist, 0, …)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x\l              \&gt;= 0)\l       :time 0.009s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_285 -&gt; p_284 [label=&quot;&quot;];
p_284 [label=&quot;Simplify ((not (:var_0:.outgoing = None)\l           \|\| (if :var_0:.incoming = None then :var_0:\l               else\l               if Is_a(Sensor, Option.get :var_0:.incoming)\l               then if :var_0:.mode = Driving then … else …\l               else if :var_0:.mode = Driving then … else …).outgoing\l              = None)\l          \|\| (Destruct(Twist, 0,\l                       Option.get\l                       (if :var_0:.incoming = None then :var_0:\l                        else\l                        if Is_a(Sensor, Option.get :var_0:.incoming)\l                        then if :var_0:.mode = Driving then … else …\l                        else if :var_0:.mode = Driving then … else …).outgoing)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x\l             \&gt;= 0\l          :expansions [] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_284 -&gt; p_283 [label=&quot;&quot;];
p_283 -&gt; p_z3_1396 [label=&quot;&quot;,fontname=&quot;courier&quot;,fontsize=14];
p_z3_1396 [label=&quot;(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2772\||
          …&quot;,shape=box,fontname=&quot;courier&quot;,fontsize=14];p_283 [label=&quot;unsat&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-98e65006-5ab5-4128-8459-f117be98539d';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-e7380655-a24a-4d7f-ace0-ca6dea7e5011';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-51f713a1-2dc3-40ce-add2-eb653c32efad';
  fold.hydrate(target);
});
</script></div></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-5b8fd932-c872-480a-8835-1c244f07047c"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;not\l((not (state.outgoing = None)\l  \|\| (if state.incoming = None then state\l      else\l      if Is_a(Sensor, Option.get state.incoming)\l      then if state.mode = Driving then … else …\l      else if state.mode = Driving then … else …).outgoing\l     = None)\l \|\| (Destruct(Twist, 0,\l              Option.get\l              (if state.incoming = None then state\l               else\l               if Is_a(Sensor, Option.get state.incoming)\l               then if state.mode = Driving then … else …\l               else if state.mode = Driving then … else …).outgoing)).Geometry_msgs.twist_linear.Geometry_msgs.vector3_x\l    \&gt;= 0)&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_201 [label=&quot;foldi ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0) None\lanon_fun.get_min_and_direction.0\l(Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_201 [label=&quot;calls&quot;];
call_180 [label=&quot;List.fold_right anon_fun.get_min_range.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_180 [label=&quot;calls&quot;];
call_176 [label=&quot;List.length\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_176 [label=&quot;calls&quot;];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-5b8fd932-c872-480a-8835-1c244f07047c';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-ca620745-35ee-42d9-82d5-72895d030284';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="4.-Inductive-proofs.-Stopping-near-objects.">4. Inductive proofs. Stopping near objects.<a class="anchor-link" href="#4.-Inductive-proofs.-Stopping-near-objects.">&#182;</a></h1><p>As a final formal verification goal, we want to be able to prove that the robot stops and starts turning if one of the values in the scanner <code>ranges</code> is lower than 0.2 meters. In general, reasoning about variable-sized lists requires inductive proofs - and these might require proving some lemmas to guide Imandra to the proof. So, we will first try to prove a simpler version of the theorem - if all the ranges in the incoming laser scan message are less than 0.2 meters, then we definitely transition to the <code>Turning</code> state. We'll try to encode our theorem using <code>List.for_all</code> standard function:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-28" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[14]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">verify</span> <span class="o">(</span> <span class="k">fun</span> <span class="n">state</span> <span class="o">-&gt;</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Sensor_msgs</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">state</span><span class="o">.</span><span class="n">incoming</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nc">Clock</span> <span class="o">_</span> <span class="o">)</span> <span class="o">-&gt;</span> <span class="bp">true</span> 
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span> <span class="nc">Sensor</span> <span class="n">data</span> <span class="o">)</span> <span class="o">-&gt;</span>
  <span class="o">(</span>  <span class="nn">List</span><span class="p">.</span><span class="n">for_all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">20000</span><span class="o">)</span> <span class="n">data</span><span class="o">.</span><span class="n">laserScan_ranges</span>    
  <span class="o">)</span> <span class="o">==&gt;</span> <span class="o">(</span><span class="n">one_step</span> <span class="n">state</span><span class="o">).</span><span class="n">mode</span> <span class="o">=</span> <span class="nc">Turning</span>
<span class="o">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[14]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : state -&gt; bool = &lt;fun&gt;
module CX : sig val state : state end
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><pre>Counterexample (after 4 steps, 0.027s):
 let state =
   {mode = Turning; min_range = (Some 7719); direction = None;
    incoming =
     (Some
      (Sensor
         ({Sensor_msgs.laserScan_range_min = 3;
           Sensor_msgs.laserScan_range_max = 25001;
           Sensor_msgs.laserScan_ranges = []})));
    outgoing = None}
</pre></div>

</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-vr imandra-vr-refuted"><i class="fa fa-times-circle-o"></i><span>Refuted</span></div><div><div class="imandra-alternatives" id="alt-42740742-a615-425e-a7fe-85bfa0835a4c"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>call graph</a></li><li class="" data-toggle="tab"><a>proof-attempt</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-graphviz" id="graphviz-26ecc8ff-9144-440e-86f1-2a45c9326a5e"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;not\l(((state.incoming = None\l   \|\| Is_a(Some, state.incoming) &amp;&amp; Is_a(Clock, Option.get state.incoming))\l  \|\| not\l     (List.for_all anon_fun._verify_target.0\l      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges))\l \|\| (if state.incoming = None then state\l     else\l     if Is_a(Sensor, Option.get state.incoming)\l     then if state.mode = Driving then … else …\l     else if state.mode = Driving then … else …).mode\l    = Turning)&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_1459 [label=&quot;List.length\l(List.tl (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1461 -&gt; call_1459 [label=&quot;calls&quot;];
call_163 [label=&quot;List.for_all anon_fun._verify_target.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_163 -&gt; expr_1530 [label=&quot;=&quot;];
expr_1530 [label=&quot;(Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges =\l[]\l\|\| not\l   (20000 \&lt;=\l    List.hd\l    (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\l   &amp;&amp; List.for_all anon_fun._verify_target.0\l      (List.tl\l       (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_163 [label=&quot;calls&quot;];
call_1527 [label=&quot;List.for_all anon_fun._verify_target.0\l(List.tl (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1530 -&gt; call_1527 [label=&quot;calls&quot;];
call_1063 [label=&quot;List.fold_right anon_fun.get_min_range.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l(List.tl (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1068 -&gt; call_1063 [label=&quot;calls&quot;];
expr_1068 -&gt; call_1063 [label=&quot;calls&quot;];
call_1206 [label=&quot;foldi ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0)\l(Some (1 + 0)) anon_fun.get_min_and_direction.0\l(List.tl (Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1213 -&gt; call_1206 [label=&quot;calls&quot;];
expr_1213 -&gt; call_1206 [label=&quot;calls&quot;];
call_170 [label=&quot;List.length\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_170 -&gt; expr_1461 [label=&quot;=&quot;];
expr_1461 [label=&quot;if (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\l   = []\lthen 0\lelse\l  1\l  + List.length\l    (List.tl\l     (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_170 [label=&quot;calls&quot;];
call_174 [label=&quot;foldi ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0) None\lanon_fun.get_min_and_direction.0\l(Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_174 -&gt; expr_1213 [label=&quot;=&quot;];
expr_1213 [label=&quot;if (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\l   = []\lthen\l  ((Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max,\l   0)\lelse\lif (foldi\l    ((Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max,\l     0)\l    (Some …) anon_fun.get_min_and_direction.0\l    (List.tl\l     (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)).0\l   \&lt;=\l   List.hd\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\lthen\l  foldi\l  ((Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max,\l   0)\l  (Some …) anon_fun.get_min_and_direction.0\l  (List.tl\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\lelse\l  (List.hd\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges,\l   if Is_a(Some, …) then … else 0)&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_174 [label=&quot;calls&quot;];
call_178 [label=&quot;List.fold_right anon_fun.get_min_range.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_178 -&gt; expr_1068 [label=&quot;=&quot;];
expr_1068 [label=&quot;if (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\l   = []\lthen\l  (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max\lelse\lif List.fold_right anon_fun.get_min_range.0\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max\l   (List.tl\l    (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\l   \&lt;=\l   List.hd\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\lthen\l  List.fold_right anon_fun.get_min_range.0\l  (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max\l  (List.tl\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\lelse\l  List.hd\l  (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_178 [label=&quot;calls&quot;];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-26ecc8ff-9144-440e-86f1-2a45c9326a5e';
  graphviz.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-1d97ff40-d7ff-4a9c-a2c7-13eac02b9005"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof attempt</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-7a100456-f72d-48f7-8081-d5cd320e6048"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-ecd70fb8-aa32-4e31-9899-1b7e82deef88"><table><tr><td><b>ground_instances</b></td><td>4</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.027s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-14c0eb9b-1d4a-45a6-9465-50fba2c61a49"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-edc8ff5f-e59b-4eac-9219-1702cc6b2b7f"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-4fa15a77-34be-42bf-ab39-db3069a06431"><table><tr><td><b>arith offset eqs</b></td><td>5</td></tr><tr><td><b>num checks</b></td><td>9</td></tr><tr><td><b>arith assert lower</b></td><td>38</td></tr><tr><td><b>arith pivots</b></td><td>16</td></tr><tr><td><b>rlimit count</b></td><td>7086</td></tr><tr><td><b>mk clause</b></td><td>109</td></tr><tr><td><b>datatype occurs check</b></td><td>2184</td></tr><tr><td><b>mk bool var</b></td><td>521</td></tr><tr><td><b>arith assert upper</b></td><td>35</td></tr><tr><td><b>datatype splits</b></td><td>60</td></tr><tr><td><b>decisions</b></td><td>304</td></tr><tr><td><b>arith add rows</b></td><td>25</td></tr><tr><td><b>arith bound prop</b></td><td>5</td></tr><tr><td><b>propagations</b></td><td>278</td></tr><tr><td><b>interface eqs</b></td><td>1</td></tr><tr><td><b>conflicts</b></td><td>24</td></tr><tr><td><b>arith fixed eqs</b></td><td>6</td></tr><tr><td><b>datatype accessor ax</b></td><td>66</td></tr><tr><td><b>minimized lits</b></td><td>2</td></tr><tr><td><b>arith assert diseq</b></td><td>13</td></tr><tr><td><b>datatype constructor ax</b></td><td>238</td></tr><tr><td><b>num allocs</b></td><td>1112345568</td></tr><tr><td><b>final checks</b></td><td>18</td></tr><tr><td><b>added eqs</b></td><td>1231</td></tr><tr><td><b>del clause</b></td><td>31</td></tr><tr><td><b>arith eq adapter</b></td><td>20</td></tr><tr><td><b>memory</b></td><td>26.960000</td></tr><tr><td><b>max memory</b></td><td>26.960000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-14c0eb9b-1d4a-45a6-9465-50fba2c61a49';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-84b613a2-5aeb-4ff4-8694-d75459e85b50"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.027s]
  if :var_0:.incoming = None
     || Is_a(Some, :var_0:.incoming)
        &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming)
  then true
  else
    List.for_all anon_fun._verify_target.0
    (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
    ==&gt; (if :var_0:.incoming = None then :var_0:
         else if Is_a(Sensor, Option.get :var_0:.incoming) then … else …).mode
        = Turning</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-bdd9e34b-1c85-4cdf-918f-4746ffdcf6d2"><table><tr><td><b>into</b></td><td><pre>((:var_0:.incoming = None
  || Is_a(Some, :var_0:.incoming) &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming))
 || not
    (List.for_all anon_fun._verify_target.0
     (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges))
|| (if :var_0:.incoming = None then :var_0:
    else
    if Is_a(Sensor, Option.get :var_0:.incoming)
    then if :var_0:.mode = Driving then … else …
    else if :var_0:.mode = Driving then … else …).mode
   = Turning</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-dc7157b4-c4aa-4b8f-a137-e3f31ae43809"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_range_max_2309\||
             (|\|get.Sensor.0_2856\||
       …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-30f91c22-e5fe-46e3-97a2-26ce342a2c01"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_range_max_2309\||
             (|\|get.Sensor.0_2856\||
       …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-f02ddc77-5d1b-4315-9123-e9f5f1034405"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2856\||
          …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-626ba8d9-6954-47c5-b49b-5d7d624efde0"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2856\||
          …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li>Sat (Some  let state =
   {mode = Turning; min_range = (Some 7719); direction = None;
    incoming =
     (Some
      (Sensor
         ({Sensor_msgs.laserScan_range_min = 3;
           Sensor_msgs.laserScan_range_max = 25001;
           Sensor_msgs.laserScan_ranges = []})));
    outgoing = None}
)</li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-84b613a2-5aeb-4ff4-8694-d75459e85b50';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-0e209bd1-8d13-4e2f-a122-ffdd5503ee5e"><textarea style="display: none">digraph &quot;proof&quot; {
p_292 [label=&quot;Start (if :var_0:.incoming = None\l          \|\| Is_a(Some, :var_0:.incoming)\l             &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming)\l       then true\l       else\l         List.for_all anon_fun._verify_target.0\l         (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l         ==\&gt; (if :var_0:.incoming = None then :var_0:\l              else\l              if Is_a(Sensor, Option.get :var_0:.incoming) then … else …).mode\l             = Turning\l       :time 0.027s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_292 -&gt; p_291 [label=&quot;&quot;];
p_291 [label=&quot;Simplify (((:var_0:.incoming = None\l            \|\| Is_a(Some, :var_0:.incoming)\l               &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming))\l           \|\| not\l              (List.for_all anon_fun._verify_target.0\l               (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges))\l          \|\| (if :var_0:.incoming = None then :var_0:\l              else\l              if Is_a(Sensor, Option.get :var_0:.incoming)\l              then if :var_0:.mode = Driving then … else …\l              else if :var_0:.mode = Driving then … else …).mode\l             = Turning\l          :expansions [] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_291 -&gt; p_290 [label=&quot;&quot;];
p_290 [label=&quot;Unroll ([List.fold_right anon_fun.get_min_range.0\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_290 -&gt; p_289 [label=&quot;&quot;];
p_289 [label=&quot;Unroll ([foldi\l         ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0) None\l         anon_fun.get_min_and_direction.0\l         (Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_289 -&gt; p_288 [label=&quot;&quot;];
p_288 [label=&quot;Unroll ([List.length\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_288 -&gt; p_287 [label=&quot;&quot;];
p_287 [label=&quot;Unroll ([List.for_all anon_fun._verify_target.0\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_287 -&gt; p_286 [label=&quot;&quot;];
p_286 [label=&quot;Sat (Some  let state =\l   \{mode = Turning; min_range = (Some 7719); direction = None;\l    incoming =\l     (Some\l      (Sensor\l         (\{Sensor_msgs.laserScan_range_min = 3;\l           Sensor_msgs.laserScan_range_max = 25001;\l           Sensor_msgs.laserScan_ranges = []\})));\l    outgoing = None\}\l)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-0e209bd1-8d13-4e2f-a122-ffdd5503ee5e';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-7a100456-f72d-48f7-8081-d5cd320e6048';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-1d97ff40-d7ff-4a9c-a2c7-13eac02b9005';
  fold.hydrate(target);
});
</script></div></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-42740742-a615-425e-a7fe-85bfa0835a4c';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We have failed to prove the statement and Imandra has created a counterexample <code>CX</code> module for us. Examining the counterexample state we notice that the incoming <code>laserScan_ranges list</code> is empty.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-30" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[15]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="nn">CX</span><span class="p">.</span><span class="n">state</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[15]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : state =
{mode = Turning; min_range = Some 7719; direction = None;
 incoming =
  Some
   (Sensor
     {Sensor_msgs.laserScan_range_min = 3; laserScan_range_max = 25001;
      laserScan_ranges = []});
 outgoing = None}
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Adding the extra requirement that the list is not <code>[]</code>, we successfully verify the statement:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-32" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[16]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">theorem</span> <span class="n">stopping_if_for_all</span> <span class="n">state</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Sensor_msgs</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">state</span><span class="o">.</span><span class="n">incoming</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nc">Clock</span> <span class="o">_</span> <span class="o">)</span> <span class="o">-&gt;</span> <span class="bp">true</span> 
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span> <span class="nc">Sensor</span> <span class="n">data</span> <span class="o">)</span> <span class="o">-&gt;</span>
  <span class="o">(</span>  <span class="n">data</span><span class="o">.</span><span class="n">laserScan_ranges</span> <span class="o">&lt;&gt;</span> <span class="bp">[]</span>
  <span class="o">&amp;&amp;</span> <span class="nn">List</span><span class="p">.</span><span class="n">for_all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">20000</span><span class="o">)</span> <span class="n">data</span><span class="o">.</span><span class="n">laserScan_ranges</span>    
  <span class="o">)</span> <span class="o">==&gt;</span> <span class="o">(</span><span class="n">one_step</span> <span class="n">state</span><span class="o">).</span><span class="n">mode</span> <span class="o">=</span> <span class="nc">Turning</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[16]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val stopping_if_for_all : state -&gt; bool = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-vr imandra-vr-proved"><i class="fa fa-check-circle"></i><span>Proved</span></div><div><div class="imandra-alternatives" id="alt-8de27294-6770-4602-88d4-ebedf0ff2e44"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>proof</a></li><li class="" data-toggle="tab"><a>call graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-0a7bd7d2-52c3-4b3c-b126-1137a769846b"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-955ca65b-ecb1-4d82-bfff-0ff830e21d8b"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-71ab9184-f6bd-4752-b3c0-9dad06e58471"><table><tr><td><b>ground_instances</b></td><td>4</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.027s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-0f301082-e545-4ea2-8641-32a469b2dd0b"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-f1248665-9819-4de3-84e0-e54c5baf768c"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-23413144-d75a-424e-9967-b7d6096f7f7d"><table><tr><td><b>arith offset eqs</b></td><td>5</td></tr><tr><td><b>num checks</b></td><td>10</td></tr><tr><td><b>arith assert lower</b></td><td>36</td></tr><tr><td><b>arith pivots</b></td><td>18</td></tr><tr><td><b>rlimit count</b></td><td>7652</td></tr><tr><td><b>mk clause</b></td><td>67</td></tr><tr><td><b>datatype occurs check</b></td><td>1584</td></tr><tr><td><b>mk bool var</b></td><td>571</td></tr><tr><td><b>arith assert upper</b></td><td>46</td></tr><tr><td><b>datatype splits</b></td><td>49</td></tr><tr><td><b>decisions</b></td><td>361</td></tr><tr><td><b>arith add rows</b></td><td>25</td></tr><tr><td><b>propagations</b></td><td>284</td></tr><tr><td><b>conflicts</b></td><td>27</td></tr><tr><td><b>arith fixed eqs</b></td><td>9</td></tr><tr><td><b>datatype accessor ax</b></td><td>56</td></tr><tr><td><b>minimized lits</b></td><td>2</td></tr><tr><td><b>arith conflicts</b></td><td>3</td></tr><tr><td><b>arith assert diseq</b></td><td>9</td></tr><tr><td><b>datatype constructor ax</b></td><td>301</td></tr><tr><td><b>num allocs</b></td><td>1149051618</td></tr><tr><td><b>final checks</b></td><td>12</td></tr><tr><td><b>added eqs</b></td><td>1385</td></tr><tr><td><b>del clause</b></td><td>35</td></tr><tr><td><b>arith eq adapter</b></td><td>18</td></tr><tr><td><b>memory</b></td><td>30.020000</td></tr><tr><td><b>max memory</b></td><td>30.020000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-0f301082-e545-4ea2-8641-32a469b2dd0b';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-89634692-3d66-46ae-8421-c4e04836942c"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.027s]
  if :var_0:.incoming = None
     || Is_a(Some, :var_0:.incoming)
        &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming)
  then true
  else
    not
    ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
     = [])
    &amp;&amp; List.for_all anon_fun._verify_target.0
       (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
    ==&gt; (if :var_0:.incoming = None then :var_0:
         else if Is_a(Sensor, Option.get :var_0:.incoming) then … else …).mode
        = Turning</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-be066ce1-bddd-483a-b9c7-2f527f96af2d"><table><tr><td><b>into</b></td><td><pre>((:var_0:.incoming = None
  || Is_a(Some, :var_0:.incoming) &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming))
 || not
    (not
     ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
      = [])
     &amp;&amp; List.for_all anon_fun._verify_target.0
        (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges))
|| (if :var_0:.incoming = None then :var_0:
    else
    if Is_a(Sensor, Option.get :var_0:.incoming)
    then if :var_0:.mode = Driving then … else …
    else if :var_0:.mode = Driving then … else …).mode
   = Turning</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-4e06f4a9-796c-46c6-b3cd-d8509661a8bd"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_range_max_2309\||
             (|\|get.Sensor.0_2955\||
       …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-29cf5621-f305-44a5-b995-50b4b7209e73"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_range_max_2309\||
             (|\|get.Sensor.0_2955\||
       …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-911a9722-9ce7-43c9-856b-4ea0b07a9344"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2955\||
          …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div>unroll<div class="imandra-table" id="table-679ac299-cbb3-4fae-804e-da8c786c04ee"><table><tr><td><b>expr</b></td><td><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2955\||
          …</pre></td></tr><tr><td><b>expansions</b></td><td><ul></ul></td></tr></table></div></div></li><li><div><h4>unsat</h4><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2955\||
          …</pre></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-89634692-3d66-46ae-8421-c4e04836942c';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-96ec9160-b609-48b6-8763-77d3c82d78b4"><textarea style="display: none">digraph &quot;proof&quot; {
p_299 [label=&quot;Start (if :var_0:.incoming = None\l          \|\| Is_a(Some, :var_0:.incoming)\l             &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming)\l       then true\l       else\l         not\l         ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l          = [])\l         &amp;&amp; List.for_all anon_fun._verify_target.0\l            (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l         ==\&gt; (if :var_0:.incoming = None then :var_0:\l              else\l              if Is_a(Sensor, Option.get :var_0:.incoming) then … else …).mode\l             = Turning\l       :time 0.027s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_299 -&gt; p_298 [label=&quot;&quot;];
p_298 [label=&quot;Simplify (((:var_0:.incoming = None\l            \|\| Is_a(Some, :var_0:.incoming)\l               &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming))\l           \|\| not\l              (not\l               ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l                = [])\l               &amp;&amp; List.for_all anon_fun._verify_target.0\l                  (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges))\l          \|\| (if :var_0:.incoming = None then :var_0:\l              else\l              if Is_a(Sensor, Option.get :var_0:.incoming)\l              then if :var_0:.mode = Driving then … else …\l              else if :var_0:.mode = Driving then … else …).mode\l             = Turning\l          :expansions [] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_298 -&gt; p_297 [label=&quot;&quot;];
p_297 [label=&quot;Unroll ([List.fold_right anon_fun.get_min_range.0\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_297 -&gt; p_296 [label=&quot;&quot;];
p_296 [label=&quot;Unroll ([foldi\l         ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0) None\l         anon_fun.get_min_and_direction.0\l         (Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_296 -&gt; p_295 [label=&quot;&quot;];
p_295 [label=&quot;Unroll ([List.length\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_295 -&gt; p_294 [label=&quot;&quot;];
p_294 [label=&quot;Unroll ([List.for_all anon_fun._verify_target.0\l         (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges],\l        [[]])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_294 -&gt; p_293 [label=&quot;&quot;];
p_293 -&gt; p_z3_1636 [label=&quot;&quot;,fontname=&quot;courier&quot;,fontsize=14];
p_z3_1636 [label=&quot;(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_2955\||
          …&quot;,shape=box,fontname=&quot;courier&quot;,fontsize=14];p_293 [label=&quot;unsat&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-96ec9160-b609-48b6-8763-77d3c82d78b4';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-955ca65b-ecb1-4d82-bfff-0ff830e21d8b';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-0a7bd7d2-52c3-4b3c-b126-1137a769846b';
  fold.hydrate(target);
});
</script></div></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-de6e25ab-dd4e-48eb-90e0-238ad747b313"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;not\l(((state.incoming = None\l   \|\| Is_a(Some, state.incoming) &amp;&amp; Is_a(Clock, Option.get state.incoming))\l  \|\| not\l     (not\l      ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges\l       = [])\l      &amp;&amp; List.for_all anon_fun._verify_target.0\l         (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges))\l \|\| (if state.incoming = None then state\l     else\l     if Is_a(Sensor, Option.get state.incoming)\l     then if state.mode = Driving then … else …\l     else if state.mode = Driving then … else …).mode\l    = Turning)&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_1038 [label=&quot;List.fold_right anon_fun.get_min_range.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l(List.tl (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1041 -&gt; call_1038 [label=&quot;calls&quot;];
expr_1041 -&gt; call_1038 [label=&quot;calls&quot;];
call_1334 [label=&quot;List.length\l(List.tl (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1336 -&gt; call_1334 [label=&quot;calls&quot;];
call_1394 [label=&quot;List.for_all anon_fun._verify_target.0\l(List.tl (Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1397 -&gt; call_1394 [label=&quot;calls&quot;];
call_280 [label=&quot;List.length\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_280 -&gt; expr_1336 [label=&quot;=&quot;];
expr_1336 [label=&quot;if (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\l   = []\lthen 0\lelse\l  1\l  + List.length\l    (List.tl\l     (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_280 [label=&quot;calls&quot;];
call_274 [label=&quot;List.for_all anon_fun._verify_target.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_274 -&gt; expr_1397 [label=&quot;=&quot;];
expr_1397 [label=&quot;(Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges =\l[]\l\|\| not\l   (20000 \&lt;=\l    List.hd\l    (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\l   &amp;&amp; List.for_all anon_fun._verify_target.0\l      (List.tl\l       (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_274 [label=&quot;calls&quot;];
call_1159 [label=&quot;foldi ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0)\l(Some (1 + 0)) anon_fun.get_min_and_direction.0\l(List.tl (Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges)&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
expr_1165 -&gt; call_1159 [label=&quot;calls&quot;];
expr_1165 -&gt; call_1159 [label=&quot;calls&quot;];
call_288 [label=&quot;List.fold_right anon_fun.get_min_range.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_288 -&gt; expr_1041 [label=&quot;=&quot;];
expr_1041 [label=&quot;if (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\l   = []\lthen\l  (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max\lelse\lif List.fold_right anon_fun.get_min_range.0\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max\l   (List.tl\l    (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\l   \&lt;=\l   List.hd\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\lthen\l  List.fold_right anon_fun.get_min_range.0\l  (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max\l  (List.tl\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\lelse\l  List.hd\l  (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_288 [label=&quot;calls&quot;];
call_284 [label=&quot;foldi ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0) None\lanon_fun.get_min_and_direction.0\l(Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;green&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_284 -&gt; expr_1165 [label=&quot;=&quot;];
expr_1165 [label=&quot;if (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\l   = []\lthen\l  ((Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max,\l   0)\lelse\lif (foldi\l    ((Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max,\l     0)\l    (Some …) anon_fun.get_min_and_direction.0\l    (List.tl\l     (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)).0\l   \&lt;=\l   List.hd\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges\lthen\l  foldi\l  ((Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_range_max,\l   0)\l  (Some …) anon_fun.get_min_and_direction.0\l  (List.tl\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges)\lelse\l  (List.hd\l   (Destruct(Sensor, 0, Option.get ….incoming)).Sensor_msgs.laserScan_ranges,\l   if Is_a(Some, …) then … else 0)&quot;,shape=box,style=filled,color=&quot;grey&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_284 [label=&quot;calls&quot;];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-de6e25ab-dd4e-48eb-90e0-238ad747b313';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-8de27294-6770-4602-88d4-ebedf0ff2e44';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Imandra successfully proves the <code>stopping_if_for_all</code> theorem, but our ultimate goal is to prove the theorem when <strong>some</strong> of the values in <code>laserScan_ranges</code> are less than the cutoff. If we simply try to replace the <code>List.for_all</code> with <code>List.exists</code>, Imandra will fail to either prove or disprove the theorem.  The inductive structure of this proof is too complex for Imandra to figure out automatically without any hints from the user. We need to help it with the overall logic of the proof. To do that we will break this final theorem into several smaller steps, making a rough "sketch" of the inductive proof we want and and ask Imandra to fill in the gaps.</p>
<p>As a first step, we extract the anonymous threshold function and prove a lemma that if the <code>get_min_range</code> function returns a value satisfying the threshold, then the conclusion about the <code>one_step</code> function holds:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-34" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[17]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="n">under_threshold</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">20000</span>

<span class="n">lemma</span> <span class="n">lemma1</span> <span class="n">state</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Sensor_msgs</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">state</span><span class="o">.</span><span class="n">incoming</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nc">Clock</span> <span class="o">_</span> <span class="o">)</span> <span class="o">-&gt;</span> <span class="bp">true</span> 
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span> <span class="nc">Sensor</span> <span class="n">data</span> <span class="o">)</span> <span class="o">-&gt;</span>
  <span class="o">(</span>  <span class="n">data</span><span class="o">.</span><span class="n">laserScan_ranges</span> <span class="o">&lt;&gt;</span> <span class="bp">[]</span>
  <span class="o">&amp;&amp;</span> <span class="n">under_threshold</span> <span class="o">(</span><span class="n">get_min_range</span> <span class="n">data</span><span class="o">.</span><span class="n">laserScan_range_max</span> <span class="n">data</span><span class="o">.</span><span class="n">laserScan_ranges</span><span class="o">)</span>
  <span class="o">)</span> <span class="o">==&gt;</span> <span class="o">(</span><span class="n">one_step</span> <span class="n">state</span><span class="o">).</span><span class="n">mode</span> <span class="o">=</span> <span class="nc">Turning</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[17]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val under_threshold : int -&gt; bool = &lt;fun&gt;
val lemma1 : state -&gt; bool = &lt;fun&gt;
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-vr imandra-vr-proved"><i class="fa fa-check-circle"></i><span>Proved</span></div><div><div class="imandra-alternatives" id="alt-d2d78ae2-4f9c-4a1b-8f95-08aeba7dde99"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>proof</a></li><li class="" data-toggle="tab"><a>call graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-a1de19b1-eadc-49ce-aa5f-2ff2d4f18960"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-d506e4f5-d7bb-4054-b99b-470240f12e9d"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-38d141d1-c149-4307-b136-1751649fe2dc"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>0</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.010s</pre></td></tr><tr><td><b>details</b></td><td><div class="imandra-fold panel panel-default" id="fold-ba0ec78e-5e91-46b5-873b-a00cb6a5124c"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><div class="imandra-table" id="table-4965477b-9832-482a-b2b7-36c091d290a9"><table><tr><td><b>smt_stats</b></td><td><div class="imandra-table" id="table-9f01a91a-e1bc-4730-85aa-7f75ae1b0b6e"><table><tr><td><b>num checks</b></td><td>2</td></tr><tr><td><b>arith assert lower</b></td><td>6</td></tr><tr><td><b>arith pivots</b></td><td>3</td></tr><tr><td><b>rlimit count</b></td><td>2362</td></tr><tr><td><b>mk clause</b></td><td>45</td></tr><tr><td><b>mk bool var</b></td><td>244</td></tr><tr><td><b>arith assert upper</b></td><td>17</td></tr><tr><td><b>datatype splits</b></td><td>26</td></tr><tr><td><b>decisions</b></td><td>60</td></tr><tr><td><b>arith add rows</b></td><td>1</td></tr><tr><td><b>propagations</b></td><td>101</td></tr><tr><td><b>conflicts</b></td><td>16</td></tr><tr><td><b>arith fixed eqs</b></td><td>2</td></tr><tr><td><b>datatype accessor ax</b></td><td>49</td></tr><tr><td><b>minimized lits</b></td><td>1</td></tr><tr><td><b>arith conflicts</b></td><td>1</td></tr><tr><td><b>arith assert diseq</b></td><td>1</td></tr><tr><td><b>datatype constructor ax</b></td><td>57</td></tr><tr><td><b>num allocs</b></td><td>1194582764</td></tr><tr><td><b>added eqs</b></td><td>361</td></tr><tr><td><b>del clause</b></td><td>25</td></tr><tr><td><b>arith eq adapter</b></td><td>5</td></tr><tr><td><b>memory</b></td><td>33.720000</td></tr><tr><td><b>max memory</b></td><td>33.720000</td></tr></table></div></td></tr></table></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-ba0ec78e-5e91-46b5-873b-a00cb6a5124c';
  fold.hydrate(target);
});
</script></div></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-1e6a0880-3f2d-4626-abdb-dffc45f2c7a6"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.010s]
  if :var_0:.incoming = None
     || Is_a(Some, :var_0:.incoming)
        &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming)
  then true
  else
    not
    ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
     = [])
    &amp;&amp; List.fold_right anon_fun.get_min_range.0
       (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_range_max
       (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
       &lt; 20000
    ==&gt; (if :var_0:.incoming = None then :var_0:
         else if Is_a(Sensor, Option.get :var_0:.incoming) then … else …).mode
        = Turning</pre></li><li><div><h4>simplify</h4><div class="imandra-table" id="table-94ddc8a1-b642-4808-bed8-546cf73f007a"><table><tr><td><b>into</b></td><td><pre>((:var_0:.incoming = None
  || Is_a(Some, :var_0:.incoming) &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming))
 || not
    (not
     ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
      = [])
     &amp;&amp; not
        (20000 &lt;=
         List.fold_right anon_fun.get_min_range.0
         (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_range_max
         (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges)))
|| (if :var_0:.incoming = None then :var_0:
    else
    if Is_a(Sensor, Option.get :var_0:.incoming)
    then if :var_0:.mode = Driving then … else …
    else if :var_0:.mode = Driving then … else …).mode
   = Turning</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li><li><div><h4>unsat</h4><pre>(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_3055\||
          …</pre></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-1e6a0880-3f2d-4626-abdb-dffc45f2c7a6';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-3155dd4a-b936-4224-b7dc-cab51eae73ac"><textarea style="display: none">digraph &quot;proof&quot; {
p_302 [label=&quot;Start (if :var_0:.incoming = None\l          \|\| Is_a(Some, :var_0:.incoming)\l             &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming)\l       then true\l       else\l         not\l         ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l          = [])\l         &amp;&amp; List.fold_right anon_fun.get_min_range.0\l            (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_range_max\l            (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l            \&lt; 20000\l         ==\&gt; (if :var_0:.incoming = None then :var_0:\l              else\l              if Is_a(Sensor, Option.get :var_0:.incoming) then … else …).mode\l             = Turning\l       :time 0.010s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_302 -&gt; p_301 [label=&quot;&quot;];
p_301 [label=&quot;Simplify (((:var_0:.incoming = None\l            \|\| Is_a(Some, :var_0:.incoming)\l               &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming))\l           \|\| not\l              (not\l               ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l                = [])\l               &amp;&amp; not\l                  (20000 \&lt;=\l                   List.fold_right anon_fun.get_min_range.0\l                   (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_range_max\l                   (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges)))\l          \|\| (if :var_0:.incoming = None then :var_0:\l              else\l              if Is_a(Sensor, Option.get :var_0:.incoming)\l              then if :var_0:.mode = Driving then … else …\l              else if :var_0:.mode = Driving then … else …).mode\l             = Turning\l          :expansions [] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_301 -&gt; p_300 [label=&quot;&quot;];
p_300 -&gt; p_z3_1039 [label=&quot;&quot;,fontname=&quot;courier&quot;,fontsize=14];
p_z3_1039 [label=&quot;(let ((a!1 (|\|Sensor_msgs.laserScan_ranges_2310\||
             (|\|get.Sensor.0_3055\||
          …&quot;,shape=box,fontname=&quot;courier&quot;,fontsize=14];p_300 [label=&quot;unsat&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-3155dd4a-b936-4224-b7dc-cab51eae73ac';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-d506e4f5-d7bb-4054-b99b-470240f12e9d';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-a1de19b1-eadc-49ce-aa5f-2ff2d4f18960';
  fold.hydrate(target);
});
</script></div></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-5fc8695e-c772-40e7-990b-d2e54f7bc4dc"><textarea style="display: none">digraph &quot;call graph&quot; {
goal [label=&quot;not\l(((state.incoming = None\l   \|\| Is_a(Some, state.incoming) &amp;&amp; Is_a(Clock, Option.get state.incoming))\l  \|\| not\l     (not\l      ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges\l       = [])\l      &amp;&amp; not\l         (20000 \&lt;=\l          List.fold_right anon_fun.get_min_range.0\l          (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max\l          (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges)))\l \|\| (if state.incoming = None then state\l     else\l     if Is_a(Sensor, Option.get state.incoming)\l     then if state.mode = Driving then … else …\l     else if state.mode = Driving then … else …).mode\l    = Turning)&quot;,shape=box,style=filled,color=&quot;cyan&quot;,fontname=&quot;courier&quot;,fontsize=14];
call_174 [label=&quot;List.fold_right anon_fun.get_min_range.0\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_range_max\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_174 [label=&quot;calls&quot;];
call_188 [label=&quot;foldi ((Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_range_max, 0) None\lanon_fun.get_min_and_direction.0\l(Destruct(Sensor, 0, …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_188 [label=&quot;calls&quot;];
call_184 [label=&quot;List.length\l(Destruct(Sensor, 0, Option.get …)).Sensor_msgs.laserScan_ranges&quot;,shape=box,style=filled,color=&quot;yellow&quot;,fontname=&quot;courier&quot;,fontsize=14];
goal -&gt; call_184 [label=&quot;calls&quot;];
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-5fc8695e-c772-40e7-990b-d2e54f7bc4dc';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-d2d78ae2-4f9c-4a1b-8f95-08aeba7dde99';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next, we prove a "bridge" lemma that translates between the <code>get_min_range</code>
concept and the <code>List.exists</code> concept for the <code>under_threshold</code> function. Then, we <code>[@@apply]</code> the two lemmas above to prove our final theorem with the <code>List.exists</code> condition: these proofs require induction - to tell Imandra to use induction one should add the <code>[@@induct]</code> attribute to the theorem declaration:</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Creating%20and%20Verifying%20a%20ROS%20Node.ipynb%23try-cell-36" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[18]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">lemma</span> <span class="n">bridge</span> <span class="n">max</span> <span class="n">lst</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="n">under_threshold</span> <span class="n">lst</span> <span class="o">==&gt;</span> <span class="n">under_threshold</span> <span class="o">(</span><span class="n">get_min_range</span> <span class="n">max</span> <span class="n">lst</span><span class="o">)</span>
  <span class="o">[@@</span><span class="n">induct</span><span class="o">]</span>

<span class="n">theorem</span> <span class="n">stopping_if_exists</span> <span class="n">state</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Sensor_msgs</span> <span class="k">in</span>
  <span class="k">match</span> <span class="n">state</span><span class="o">.</span><span class="n">incoming</span> <span class="k">with</span> <span class="nc">None</span> <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span><span class="nc">Clock</span> <span class="o">_</span> <span class="o">)</span> <span class="o">-&gt;</span> <span class="bp">true</span> 
  <span class="o">|</span> <span class="nc">Some</span> <span class="o">(</span> <span class="nc">Sensor</span> <span class="n">data</span> <span class="o">)</span> <span class="o">-&gt;</span>
  <span class="o">(</span>  <span class="n">data</span><span class="o">.</span><span class="n">laserScan_ranges</span> <span class="o">&lt;&gt;</span> <span class="bp">[]</span>
  <span class="o">&amp;&amp;</span> <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="n">under_threshold</span> <span class="n">data</span><span class="o">.</span><span class="n">laserScan_ranges</span>
  <span class="o">)</span> <span class="o">==&gt;</span> <span class="o">(</span><span class="n">one_step</span> <span class="n">state</span><span class="o">).</span><span class="n">mode</span> <span class="o">=</span> <span class="nc">Turning</span>
<span class="o">[@@</span><span class="n">apply</span> <span class="n">lemma1</span> <span class="n">state</span><span class="o">]</span>
<span class="o">[@@</span><span class="n">apply</span> <span class="n">bridge</span>
    <span class="o">(</span><span class="k">match</span> <span class="n">state</span><span class="o">.</span><span class="n">incoming</span> <span class="k">with</span> <span class="nc">Some</span> <span class="o">(</span><span class="nc">Sensor</span> <span class="n">data</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">laserScan_range_max</span> <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="o">(</span><span class="k">match</span> <span class="n">state</span><span class="o">.</span><span class="n">incoming</span> <span class="k">with</span> <span class="nc">Some</span> <span class="o">(</span><span class="nc">Sensor</span> <span class="n">data</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">data</span><span class="o">.</span><span class="n">laserScan_ranges</span> <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">[]</span><span class="o">)</span> <span class="o">]</span>
<span class="o">[@@</span><span class="n">induct</span><span class="o">]</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[18]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val bridge : int -&gt; int list -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

List.exists under_threshold lst ==&gt; under_threshold (get_min_range max lst).

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. List.exists under_threshold lst
 H1. 20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst
|---------------------------------------------------------------------------
 false

Verified up to bound 10 (after 0.052s).

Must try induction.

The recursive terms in the conjecture suggest 2 inductions.
Subsumption and merging reduces this to 1.

We shall induct according to a scheme derived from <span class="ansi-blue-intense-fg ansi-bold">List.fold_right</span>.

<span class="ansi-cyan-intense-fg ansi-bold">Induction scheme</span>:

 (lst = []
  &amp;&amp; not
     (not
      (List.hd lst &lt;
       List.fold_right anon_fun.get_min_range.0 max (List.tl lst))
      &amp;&amp; not (lst = []))
  ==&gt; φ max lst)
 &amp;&amp; (not (lst = [])
     &amp;&amp; not
        (List.hd lst &lt;
         List.fold_right anon_fun.get_min_range.0 max (List.tl lst))
        &amp;&amp; φ max (List.tl lst)
     ==&gt; φ max lst)
    &amp;&amp; (not (lst = []) &amp;&amp; φ max (List.tl lst) ==&gt; φ max lst).

3 nontautological subgoals.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.3</span>:

 H0. lst = []
 H1. not
     (List.fold_right anon_fun.get_min_range.0 max (List.tl lst) &lt;=
      List.hd lst &amp;&amp; not (lst = []))
 H2. List.exists under_threshold lst
 H3. 20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the definition of <span class="ansi-blue-intense-fg ansi-bold">List.exists</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.2</span>:

 H0. not (lst = [])
 H1. List.fold_right anon_fun.get_min_range.0 max (List.tl lst) &lt;=
     List.hd lst
 H2. not (List.exists under_threshold (List.tl lst))
     || not
        (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max (List.tl lst))
 H3. List.exists under_threshold lst
 H4. 20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.exists
</span>and<span class="ansi-blue-intense-fg ansi-bold"> List.fold_right</span>.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1.1</span>:

 H0. not (lst = [])
 H1. not (List.exists under_threshold (List.tl lst))
     || not
        (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max (List.tl lst))
 H2. List.exists under_threshold lst
 H3. 20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst
|---------------------------------------------------------------------------
 false

But simplification reduces this to true, using the definitions of <span class="ansi-blue-intense-fg ansi-bold">List.exists
</span>and<span class="ansi-blue-intense-fg ansi-bold"> List.fold_right</span>.

val stopping_if_exists : state -&gt; bool = &lt;fun&gt;
<span class="ansi-white-intense-fg ansi-bold">Goal</span>:

if state.incoming = None
   || Is_a(Some, state.incoming) &amp;&amp; Is_a(Clock, Option.get state.incoming)
then true
else
  let (data : Sensor_msgs.laserScan)
      = Destruct(Sensor, 0, Option.get state.incoming)
  in
  data.Sensor_msgs.laserScan_ranges &lt;&gt; []
  &amp;&amp; List.exists under_threshold data.Sensor_msgs.laserScan_ranges
  ==&gt; (one_step state).mode = Turning.

A hint has been given, resulting in the following augmented conjecture:

<span class="ansi-white-intense-fg ansi-bold">Goal&#39;</span>:

(if state.incoming = None
    || Is_a(Some, state.incoming) &amp;&amp; Is_a(Clock, Option.get state.incoming)
 then true
 else
   (not
    ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
     = [])
    &amp;&amp; List.fold_right anon_fun.get_min_range.0
       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
       &lt; 20000
    ==&gt; (if state.incoming = None then state
         else
         if Is_a(Sensor, Option.get state.incoming)
         then
           if state.mode = Driving
           then
             if (if (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                    &lt;
                    (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)).0
                &lt; 20000
             then
               {mode = Turning;
                min_range =
                Some
                (if (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                    &lt;
                    (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)).0;
                direction =
                Some
                (if (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                    &lt;
                    (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)).1;
                incoming = None; outgoing = None}
             else
               {mode = Driving; min_range = None; direction = None;
                incoming = None; outgoing = None}
           else
           if state.min_range = None &amp;&amp; state.mode = Turning
           then
             if (if (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                    &lt;
                    (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)).0
                &gt; 25000
             then
               {mode = Driving; min_range = None; direction = None;
                incoming = None; outgoing = None}
             else
               {mode = Turning;
                min_range =
                Some
                (if (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                    &lt;
                    (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)).0;
                direction =
                Some
                (if (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                    &lt;
                    (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)).1;
                incoming = None; outgoing = None}
           else
           if (if (foldi
                   ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                    0)
                   None anon_fun.get_min_and_direction.0
                   (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                  &lt;
                  (List.length
                   (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                   / 2)
               then
                 (List.fold_right anon_fun.get_min_range.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                  CW)
               else
                 (List.fold_right anon_fun.get_min_range.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                  CCW)).0
              &gt; 25000
           then
             {mode = Driving; min_range = None; direction = None;
              incoming = None; outgoing = None}
           else
           if (if (foldi
                   ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                    0)
                   None anon_fun.get_min_and_direction.0
                   (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                  &lt;
                  (List.length
                   (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                   / 2)
               then
                 (List.fold_right anon_fun.get_min_range.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                  CW)
               else
                 (List.fold_right anon_fun.get_min_range.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                  CCW)).0
              &gt; Option.get state.min_range
           then
             {mode = state.mode; min_range = state.min_range;
              direction = state.direction; incoming = None; outgoing = None}
           else
             {mode = Turning;
              min_range =
              Some
              (if (foldi
                   ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                    0)
                   None anon_fun.get_min_and_direction.0
                   (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                  &lt;
                  (List.length
                   (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                   / 2)
               then
                 (List.fold_right anon_fun.get_min_range.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                  CW)
               else
                 (List.fold_right anon_fun.get_min_range.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                  CCW)).0;
              direction =
              Some
              (if (foldi
                   ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                    0)
                   None anon_fun.get_min_and_direction.0
                   (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                  &lt;
                  (List.length
                   (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                   / 2)
               then
                 (List.fold_right anon_fun.get_min_range.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                  CW)
               else
                 (List.fold_right anon_fun.get_min_range.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                  CCW)).1;
              incoming = None; outgoing = None}
         else
         if state.mode = Driving
         then
           {mode = state.mode; min_range = state.min_range;
            direction = state.direction; incoming = None;
            outgoing =
            Some
            (Twist
             {Geometry_msgs.twist_linear =
              {Geometry_msgs.vector3_x = 10000; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = 0};
              Geometry_msgs.twist_angular =
              {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = 0}})}
         else
         if state.direction = None
            || Is_a(Some, state.direction) &amp;&amp; Option.get state.direction = CW
         then
           {mode = state.mode; min_range = state.min_range;
            direction = state.direction; incoming = None;
            outgoing =
            Some
            (Twist
             {Geometry_msgs.twist_linear =
              {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = 0};
              Geometry_msgs.twist_angular =
              {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = 10000}})}
         else
           {mode = state.mode; min_range = state.min_range;
            direction = state.direction; incoming = None;
            outgoing =
            Some
            (Twist
             {Geometry_msgs.twist_linear =
              {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = 0};
              Geometry_msgs.twist_angular =
              {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = -10000}})}).mode
        = Turning))
&amp;&amp; (List.exists under_threshold
    (if Is_a(Sensor, Option.get state.incoming) &amp;&amp; Is_a(Some, state.incoming)
     then
       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
     else [])
    ==&gt; List.fold_right anon_fun.get_min_range.0
        (if Is_a(Sensor, Option.get state.incoming)
            &amp;&amp; Is_a(Some, state.incoming)
         then
           (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
         else 0)
        (if Is_a(Sensor, Option.get state.incoming)
            &amp;&amp; Is_a(Some, state.incoming)
         then
           (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
         else [])
        &lt; 20000)
==&gt; (if state.incoming = None
        || Is_a(Some, state.incoming)
           &amp;&amp; Is_a(Clock, Option.get state.incoming)
     then true
     else
       not
       ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
        = [])
       &amp;&amp; List.exists under_threshold
          (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
       ==&gt; (if state.incoming = None then state
            else
            if Is_a(Sensor, Option.get state.incoming)
            then
              if state.mode = Driving
              then
                if (if (foldi
                        ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                         0)
                        None anon_fun.get_min_and_direction.0
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                       &lt;
                       (List.length
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                        / 2)
                    then
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CW)
                    else
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CCW)).0
                   &lt; 20000
                then
                  {mode = Turning;
                   min_range =
                   Some
                   (if (foldi
                        ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                         0)
                        None anon_fun.get_min_and_direction.0
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                       &lt;
                       (List.length
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                        / 2)
                    then
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CW)
                    else
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CCW)).0;
                   direction =
                   Some
                   (if (foldi
                        ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                         0)
                        None anon_fun.get_min_and_direction.0
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                       &lt;
                       (List.length
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                        / 2)
                    then
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CW)
                    else
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CCW)).1;
                   incoming = None; outgoing = None}
                else
                  {mode = Driving; min_range = None; direction = None;
                   incoming = None; outgoing = None}
              else
              if state.min_range = None &amp;&amp; state.mode = Turning
              then
                if (if (foldi
                        ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                         0)
                        None anon_fun.get_min_and_direction.0
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                       &lt;
                       (List.length
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                        / 2)
                    then
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CW)
                    else
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CCW)).0
                   &gt; 25000
                then
                  {mode = Driving; min_range = None; direction = None;
                   incoming = None; outgoing = None}
                else
                  {mode = Turning;
                   min_range =
                   Some
                   (if (foldi
                        ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                         0)
                        None anon_fun.get_min_and_direction.0
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                       &lt;
                       (List.length
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                        / 2)
                    then
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CW)
                    else
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CCW)).0;
                   direction =
                   Some
                   (if (foldi
                        ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                         0)
                        None anon_fun.get_min_and_direction.0
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                       &lt;
                       (List.length
                        (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                        / 2)
                    then
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CW)
                    else
                      (List.fold_right anon_fun.get_min_range.0
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                       CCW)).1;
                   incoming = None; outgoing = None}
              else
              if (if (foldi
                      ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                       0)
                      None anon_fun.get_min_and_direction.0
                      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                     &lt;
                     (List.length
                      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                      / 2)
                  then
                    (List.fold_right anon_fun.get_min_range.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                     CW)
                  else
                    (List.fold_right anon_fun.get_min_range.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                     CCW)).0
                 &gt; 25000
              then
                {mode = Driving; min_range = None; direction = None;
                 incoming = None; outgoing = None}
              else
              if (if (foldi
                      ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                       0)
                      None anon_fun.get_min_and_direction.0
                      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                     &lt;
                     (List.length
                      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                      / 2)
                  then
                    (List.fold_right anon_fun.get_min_range.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                     CW)
                  else
                    (List.fold_right anon_fun.get_min_range.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                     CCW)).0
                 &gt; Option.get state.min_range
              then
                {mode = state.mode; min_range = state.min_range;
                 direction = state.direction; incoming = None;
                 outgoing = None}
              else
                {mode = Turning;
                 min_range =
                 Some
                 (if (foldi
                      ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                       0)
                      None anon_fun.get_min_and_direction.0
                      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                     &lt;
                     (List.length
                      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                      / 2)
                  then
                    (List.fold_right anon_fun.get_min_range.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                     CW)
                  else
                    (List.fold_right anon_fun.get_min_range.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                     CCW)).0;
                 direction =
                 Some
                 (if (foldi
                      ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                       0)
                      None anon_fun.get_min_and_direction.0
                      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                     &lt;
                     (List.length
                      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                      / 2)
                  then
                    (List.fold_right anon_fun.get_min_range.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                     CW)
                  else
                    (List.fold_right anon_fun.get_min_range.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                     CCW)).1;
                 incoming = None; outgoing = None}
            else
            if state.mode = Driving
            then
              {mode = state.mode; min_range = state.min_range;
               direction = state.direction; incoming = None;
               outgoing =
               Some
               (Twist
                {Geometry_msgs.twist_linear =
                 {Geometry_msgs.vector3_x = 10000;
                  Geometry_msgs.vector3_y = 0; Geometry_msgs.vector3_z = 0};
                 Geometry_msgs.twist_angular =
                 {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
                  Geometry_msgs.vector3_z = 0}})}
            else
            if state.direction = None
               || Is_a(Some, state.direction)
                  &amp;&amp; Option.get state.direction = CW
            then
              {mode = state.mode; min_range = state.min_range;
               direction = state.direction; incoming = None;
               outgoing =
               Some
               (Twist
                {Geometry_msgs.twist_linear =
                 {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
                  Geometry_msgs.vector3_z = 0};
                 Geometry_msgs.twist_angular =
                 {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
                  Geometry_msgs.vector3_z = 10000}})}
            else
              {mode = state.mode; min_range = state.min_range;
               direction = state.direction; incoming = None;
               outgoing =
               Some
               (Twist
                {Geometry_msgs.twist_linear =
                 {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
                  Geometry_msgs.vector3_z = 0};
                 Geometry_msgs.twist_angular =
                 {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
                  Geometry_msgs.vector3_z = -10000}})}).mode
           = Turning).

1 nontautological subgoal.

<span class="ansi-white-intense-fg ansi-bold">Subgoal 1</span>:

 H0. ((state.incoming = None
       || Is_a(Some, state.incoming)
          &amp;&amp; Is_a(Clock, Option.get state.incoming))
      || not
         (not
          ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
           = [])
          &amp;&amp; not
             (20000 &lt;=
              List.fold_right anon_fun.get_min_range.0
              (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
              (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges)))
     || (if state.incoming = None then state
         else
         if Is_a(Sensor, Option.get state.incoming)
         then
           if state.mode = Driving
           then
             if 20000 &lt;=
                (if (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                    &lt;=
                    (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)).0
             then
               {mode = Driving; min_range = None; direction = None;
                incoming = None; outgoing = None}
             else
               {mode = Turning;
                min_range =
                Some
                (if (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                    &lt;=
                    (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)).0;
                direction =
                Some
                (if (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                    &lt;=
                    (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)).1;
                incoming = None; outgoing = None}
           else
           if state.min_range = None &amp;&amp; state.mode = Turning
           then
             if (if (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                    &lt;=
                    (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)).0
                &lt;= 25000
             then
               {mode = Turning;
                min_range =
                Some
                (if (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                    &lt;=
                    (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)).0;
                direction =
                Some
                (if (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                    &lt;=
                    (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)).1;
                incoming = None; outgoing = None}
             else
               {mode = Driving; min_range = None; direction = None;
                incoming = None; outgoing = None}
           else
           if (if (List.length
                   (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                   / 2)
                  &lt;=
                  (foldi
                   ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                    0)
                   None anon_fun.get_min_and_direction.0
                   (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
               then
                 (List.fold_right anon_fun.get_min_range.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                  CCW)
               else
                 (List.fold_right anon_fun.get_min_range.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                  CW)).0
              &lt;= 25000
           then
             if (if (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                    &lt;=
                    (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)).0
                &lt;= Option.get state.min_range
             then
               {mode = Turning;
                min_range =
                Some
                (if (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                    &lt;=
                    (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)).0;
                direction =
                Some
                (if (List.length
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                     / 2)
                    &lt;=
                    (foldi
                     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                      0)
                     None anon_fun.get_min_and_direction.0
                     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
                 then
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CCW)
                 else
                   (List.fold_right anon_fun.get_min_range.0
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                    CW)).1;
                incoming = None; outgoing = None}
             else
               {mode = state.mode; min_range = state.min_range;
                direction = state.direction; incoming = None; outgoing = None}
           else
             {mode = Driving; min_range = None; direction = None;
              incoming = None; outgoing = None}
         else
         if state.mode = Driving
         then
           {mode = state.mode; min_range = state.min_range;
            direction = state.direction; incoming = None;
            outgoing =
            Some
            (Twist
             {Geometry_msgs.twist_linear =
              {Geometry_msgs.vector3_x = 10000; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = 0};
              Geometry_msgs.twist_angular =
              {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = 0}})}
         else
         if state.direction = None
            || Is_a(Some, state.direction) &amp;&amp; Option.get state.direction = CW
         then
           {mode = state.mode; min_range = state.min_range;
            direction = state.direction; incoming = None;
            outgoing =
            Some
            (Twist
             {Geometry_msgs.twist_linear =
              {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = 0};
              Geometry_msgs.twist_angular =
              {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = 10000}})}
         else
           {mode = state.mode; min_range = state.min_range;
            direction = state.direction; incoming = None;
            outgoing =
            Some
            (Twist
             {Geometry_msgs.twist_linear =
              {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = 0};
              Geometry_msgs.twist_angular =
              {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
               Geometry_msgs.vector3_z = -10000}})}).mode
        = Turning
 H1. not
     (List.exists under_threshold
      (if Is_a(Sensor, Option.get state.incoming)
          &amp;&amp; Is_a(Some, state.incoming)
       then
         (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
       else []))
     || not
        (20000 &lt;=
         List.fold_right anon_fun.get_min_range.0
         (if Is_a(Sensor, Option.get state.incoming)
             &amp;&amp; Is_a(Some, state.incoming)
          then
            (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
          else 0)
         (if Is_a(Sensor, Option.get state.incoming)
             &amp;&amp; Is_a(Some, state.incoming)
          then
            (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
          else []))
 H2. not
     ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
      = [])
 H3. List.exists under_threshold
     (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
|---------------------------------------------------------------------------
 C0. state.incoming = None
 C1. Is_a(Some, state.incoming) &amp;&amp; Is_a(Clock, Option.get state.incoming)
 C2. (if state.incoming = None then state
      else
      if Is_a(Sensor, Option.get state.incoming)
      then
        if state.mode = Driving
        then
          if 20000 &lt;=
             (if (List.length
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                  / 2)
                 &lt;=
                 (foldi
                  ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                   0)
                  None anon_fun.get_min_and_direction.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
              then
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CCW)
              else
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CW)).0
          then
            {mode = Driving; min_range = None; direction = None;
             incoming = None; outgoing = None}
          else
            {mode = Turning;
             min_range =
             Some
             (if (List.length
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                  / 2)
                 &lt;=
                 (foldi
                  ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                   0)
                  None anon_fun.get_min_and_direction.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
              then
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CCW)
              else
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CW)).0;
             direction =
             Some
             (if (List.length
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                  / 2)
                 &lt;=
                 (foldi
                  ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                   0)
                  None anon_fun.get_min_and_direction.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
              then
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CCW)
              else
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CW)).1;
             incoming = None; outgoing = None}
        else
        if state.min_range = None &amp;&amp; state.mode = Turning
        then
          if (if (List.length
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                  / 2)
                 &lt;=
                 (foldi
                  ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                   0)
                  None anon_fun.get_min_and_direction.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
              then
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CCW)
              else
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CW)).0
             &lt;= 25000
          then
            {mode = Turning;
             min_range =
             Some
             (if (List.length
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                  / 2)
                 &lt;=
                 (foldi
                  ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                   0)
                  None anon_fun.get_min_and_direction.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
              then
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CCW)
              else
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CW)).0;
             direction =
             Some
             (if (List.length
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                  / 2)
                 &lt;=
                 (foldi
                  ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                   0)
                  None anon_fun.get_min_and_direction.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
              then
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CCW)
              else
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CW)).1;
             incoming = None; outgoing = None}
          else
            {mode = Driving; min_range = None; direction = None;
             incoming = None; outgoing = None}
        else
        if (if (List.length
                (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                / 2)
               &lt;=
               (foldi
                ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                 0)
                None anon_fun.get_min_and_direction.0
                (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
            then
              (List.fold_right anon_fun.get_min_range.0
               (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
               (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
               CCW)
            else
              (List.fold_right anon_fun.get_min_range.0
               (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
               (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
               CW)).0
           &lt;= 25000
        then
          if (if (List.length
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                  / 2)
                 &lt;=
                 (foldi
                  ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                   0)
                  None anon_fun.get_min_and_direction.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
              then
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CCW)
              else
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CW)).0
             &lt;= Option.get state.min_range
          then
            {mode = Turning;
             min_range =
             Some
             (if (List.length
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                  / 2)
                 &lt;=
                 (foldi
                  ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                   0)
                  None anon_fun.get_min_and_direction.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
              then
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CCW)
              else
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CW)).0;
             direction =
             Some
             (if (List.length
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                  / 2)
                 &lt;=
                 (foldi
                  ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max,
                   0)
                  None anon_fun.get_min_and_direction.0
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges).1
              then
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CCW)
              else
                (List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges,
                 CW)).1;
             incoming = None; outgoing = None}
          else
            {mode = state.mode; min_range = state.min_range;
             direction = state.direction; incoming = None; outgoing = None}
        else
          {mode = Driving; min_range = None; direction = None;
           incoming = None; outgoing = None}
      else
      if state.mode = Driving
      then
        {mode = state.mode; min_range = state.min_range;
         direction = state.direction; incoming = None;
         outgoing =
         Some
         (Twist
          {Geometry_msgs.twist_linear =
           {Geometry_msgs.vector3_x = 10000; Geometry_msgs.vector3_y = 0;
            Geometry_msgs.vector3_z = 0};
           Geometry_msgs.twist_angular =
           {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
            Geometry_msgs.vector3_z = 0}})}
      else
      if state.direction = None
         || Is_a(Some, state.direction) &amp;&amp; Option.get state.direction = CW
      then
        {mode = state.mode; min_range = state.min_range;
         direction = state.direction; incoming = None;
         outgoing =
         Some
         (Twist
          {Geometry_msgs.twist_linear =
           {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
            Geometry_msgs.vector3_z = 0};
           Geometry_msgs.twist_angular =
           {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
            Geometry_msgs.vector3_z = 10000}})}
      else
        {mode = state.mode; min_range = state.min_range;
         direction = state.direction; incoming = None;
         outgoing =
         Some
         (Twist
          {Geometry_msgs.twist_linear =
           {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
            Geometry_msgs.vector3_z = 0};
           Geometry_msgs.twist_angular =
           {Geometry_msgs.vector3_x = 0; Geometry_msgs.vector3_y = 0;
            Geometry_msgs.vector3_z = -10000}})}).mode
     = Turning

But simplification reduces this to true, using the definition of
<span class="ansi-blue-intense-fg ansi-bold">List.fold_right</span>.

</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-vr imandra-vr-proved"><i class="fa fa-check-circle"></i><span>Proved</span></div><div><div class="imandra-alternatives" id="alt-1e7d61c7-8515-4fd8-95cb-28a0756c8cf5"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>proof</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-7377a93c-72f8-43f2-8c2c-3acc969c432a"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-7281fba7-5ac5-4a99-a1c8-d9714db17c05"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-adfba1c9-6e99-4658-9118-25161191853a"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>9</td></tr><tr><td><b>inductions</b></td><td>1</td></tr><tr><td><b>search_time</b></td><td><pre>0.413s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-5b4a2485-5359-4d7a-b0d1-e184a3a7dd27"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.413s, &quot;Goal&quot;]
  List.exists under_threshold :var_0:
  ==&gt; List.fold_right anon_fun.get_min_range.0 :var_1: :var_0: &lt; 20000</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-0055a816-d981-4a3f-acab-e816df6ded09"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>not (List.exists under_threshold lst)
|| not (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst)</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.413s, &quot;1&quot;]
  not (List.exists under_threshold lst)
  || not (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst)</pre></li><li><pre>induction on (functional )
:scheme (lst = []
         &amp;&amp; not
            (not
             (List.hd lst &lt;
              List.fold_right anon_fun.get_min_range.0 max (List.tl lst))
             &amp;&amp; not (lst = []))
         ==&gt; φ max lst)
        &amp;&amp; (not (lst = [])
            &amp;&amp; not
               (List.hd lst &lt;
                List.fold_right anon_fun.get_min_range.0 max (List.tl lst))
               &amp;&amp; φ max (List.tl lst)
            ==&gt; φ max lst)
           &amp;&amp; (not (lst = []) &amp;&amp; φ max (List.tl lst) ==&gt; φ max lst)</pre></li><li><div><pre>Split ((((not
          (lst = []
           &amp;&amp; not
              (List.fold_right anon_fun.get_min_range.0 max (List.tl lst) &lt;=
               List.hd lst &amp;&amp; not (lst = [])))
          || not (List.exists under_threshold lst))
         || not (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst))
        &amp;&amp; ((not
             ((not (lst = [])
               &amp;&amp; List.fold_right anon_fun.get_min_range.0 max (List.tl lst)
                  &lt;= List.hd lst)
              &amp;&amp; (not (List.exists under_threshold (List.tl lst))
                  || not
                     (20000 &lt;=
                      List.fold_right anon_fun.get_min_range.0 max
                      (List.tl lst))))
             || not (List.exists under_threshold lst))
            || not
               (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst)))
       &amp;&amp; ((not
            (not (lst = [])
             &amp;&amp; (not (List.exists under_threshold (List.tl lst))
                 || not
                    (20000 &lt;=
                     List.fold_right anon_fun.get_min_range.0 max
                     (List.tl lst))))
            || not (List.exists under_threshold lst))
           || not (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst))
       :cases [((not (lst = [])
                 || List.fold_right anon_fun.get_min_range.0 max
                    (List.tl lst) &lt;= List.hd lst &amp;&amp; not (lst = []))
                || not (List.exists under_threshold lst))
               || not
                  (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst);
               (((lst = []
                  || not
                     (List.fold_right anon_fun.get_min_range.0 max
                      (List.tl lst) &lt;= List.hd lst))
                 || not
                    (not (List.exists under_threshold (List.tl lst))
                     || not
                        (20000 &lt;=
                         List.fold_right anon_fun.get_min_range.0 max
                         (List.tl lst))))
                || not (List.exists under_threshold lst))
               || not
                  (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst);
               ((lst = []
                 || not
                    (not (List.exists under_threshold (List.tl lst))
                     || not
                        (20000 &lt;=
                         List.fold_right anon_fun.get_min_range.0 max
                         (List.tl lst))))
                || not (List.exists under_threshold lst))
               || not
                  (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst)])</pre><ul><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-6dc12e40-bec8-463b-b01f-bc30b8070c0a"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((lst = []
  || not
     (not (List.exists under_threshold (List.tl lst))
      || not
         (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max (List.tl lst))))
 || not (List.exists under_threshold lst))
|| not (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst)</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.294s, &quot;1.1&quot;]
  ((lst = []
    || not
       (not (List.exists under_threshold (List.tl lst))
        || not
           (20000 &lt;=
            List.fold_right anon_fun.get_min_range.0 max (List.tl lst))))
   || not (List.exists under_threshold lst))
  || not (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst)</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-6ae8cca5-9b9f-4598-afb6-143bdb4d6b81"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[List.fold_right, List.exists, List.fold_right, List.exists]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-6dc12e40-bec8-463b-b01f-bc30b8070c0a';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-fd167c88-b303-4494-a364-db09bb344cda"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(((lst = []
   || not
      (List.fold_right anon_fun.get_min_range.0 max (List.tl lst) &lt;=
       List.hd lst))
  || not
     (not (List.exists under_threshold (List.tl lst))
      || not
         (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max (List.tl lst))))
 || not (List.exists under_threshold lst))
|| not (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst)</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.294s, &quot;1.2&quot;]
  (((lst = []
     || not
        (List.fold_right anon_fun.get_min_range.0 max (List.tl lst) &lt;=
         List.hd lst))
    || not
       (not (List.exists under_threshold (List.tl lst))
        || not
           (20000 &lt;=
            List.fold_right anon_fun.get_min_range.0 max (List.tl lst))))
   || not (List.exists under_threshold lst))
  || not (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst)</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-e1a563d6-313c-4430-bed2-4ffaa20be19d"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>[List.fold_right, List.exists, List.fold_right, List.exists]</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-fd167c88-b303-4494-a364-db09bb344cda';
  fold.hydrate(target);
});
</script></div></div></li><li><div><h5>subproof</h5><div class="imandra-fold panel panel-default" id="fold-3a4cd1b8-e93a-44be-a0e2-4ba3fefb0b8d"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>((not (lst = [])
  || List.fold_right anon_fun.get_min_range.0 max (List.tl lst) &lt;=
     List.hd lst &amp;&amp; not (lst = []))
 || not (List.exists under_threshold lst))
|| not (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst)</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.294s, &quot;1.3&quot;]
  ((not (lst = [])
    || List.fold_right anon_fun.get_min_range.0 max (List.tl lst) &lt;=
       List.hd lst &amp;&amp; not (lst = []))
   || not (List.exists under_threshold lst))
  || not (20000 &lt;= List.fold_right anon_fun.get_min_range.0 max lst)</pre></li><li><div><h6>simplify</h6><div class="imandra-table" id="table-3c96fd0f-df5b-477b-8cd6-0b681b5adb0b"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>List.exists</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-3a4cd1b8-e93a-44be-a0e2-4ba3fefb0b8d';
  fold.hydrate(target);
});
</script></div></div></li></ul></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-0055a816-d981-4a3f-acab-e816df6ded09';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-5b4a2485-5359-4d7a-b0d1-e184a3a7dd27';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-b85086b7-d8e6-484e-8de9-444bfab6c319"><textarea style="display: none">digraph &quot;proof&quot; {
p_328 [label=&quot;Start (List.exists under_threshold :var_0:\l       ==\&gt; List.fold_right anon_fun.get_min_range.0 :var_1: :var_0: \&lt; 20000\l       :name \&quot;Goal\&quot; :time 0.413s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_328 -&gt; p_326 [label=&quot;&quot;];
subgraph cluster_327 {
  color=blue;
p_326 [label=&quot;Start (not (List.exists under_threshold lst)\l       \|\| not (20000 \&lt;= List.fold_right anon_fun.get_min_range.0 max lst)\l       :name \&quot;1\&quot; :time 0.413s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_326 -&gt; p_325 [label=&quot;&quot;];
p_325 [label=&quot;Induct ((functional ),\l        :scheme (lst = []\l                 &amp;&amp; not\l                    (not\l                     (List.hd lst \&lt;\l                      List.fold_right anon_fun.get_min_range.0 max\l                      (List.tl lst))\l                     &amp;&amp; not (lst = []))\l                 ==\&gt; φ max lst)\l                &amp;&amp; (not (lst = [])\l                    &amp;&amp; not\l                       (List.hd lst \&lt;\l                        List.fold_right anon_fun.get_min_range.0 max\l                        (List.tl lst))\l                       &amp;&amp; φ max (List.tl lst)\l                    ==\&gt; φ max lst)\l                   &amp;&amp; (not (lst = []) &amp;&amp; φ max (List.tl lst) ==\&gt; φ max lst))&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_325 -&gt; p_324 [label=&quot;&quot;];
p_324 [label=&quot;Split ((((not\l          (lst = []\l           &amp;&amp; not\l              (List.fold_right anon_fun.get_min_range.0 max (List.tl lst) \&lt;=\l               List.hd lst &amp;&amp; not (lst = [])))\l          \|\| not (List.exists under_threshold lst))\l         \|\| not (20000 \&lt;= List.fold_right anon_fun.get_min_range.0 max lst))\l        &amp;&amp; ((not\l             ((not (lst = [])\l               &amp;&amp; List.fold_right anon_fun.get_min_range.0 max (List.tl lst)\l                  \&lt;= List.hd lst)\l              &amp;&amp; (not (List.exists under_threshold (List.tl lst))\l                  \|\| not\l                     (20000 \&lt;=\l                      List.fold_right anon_fun.get_min_range.0 max\l                      (List.tl lst))))\l             \|\| not (List.exists under_threshold lst))\l            \|\| not\l               (20000 \&lt;= List.fold_right anon_fun.get_min_range.0 max lst)))\l       &amp;&amp; ((not\l            (not (lst = [])\l             &amp;&amp; (not (List.exists under_threshold (List.tl lst))\l                 \|\| not\l                    (20000 \&lt;=\l                     List.fold_right anon_fun.get_min_range.0 max\l                     (List.tl lst))))\l            \|\| not (List.exists under_threshold lst))\l           \|\| not (20000 \&lt;= List.fold_right anon_fun.get_min_range.0 max lst))\l       :cases [((not (lst = [])\l                 \|\| List.fold_right anon_fun.get_min_range.0 max\l                    (List.tl lst) \&lt;= List.hd lst &amp;&amp; not (lst = []))\l                \|\| not (List.exists under_threshold lst))\l               \|\| not\l                  (20000 \&lt;= List.fold_right anon_fun.get_min_range.0 max lst);\l               (((lst = []\l                  \|\| not\l                     (List.fold_right anon_fun.get_min_range.0 max\l                      (List.tl lst) \&lt;= List.hd lst))\l                 \|\| not\l                    (not (List.exists under_threshold (List.tl lst))\l                     \|\| not\l                        (20000 \&lt;=\l                         List.fold_right anon_fun.get_min_range.0 max\l                         (List.tl lst))))\l                \|\| not (List.exists under_threshold lst))\l               \|\| not\l                  (20000 \&lt;= List.fold_right anon_fun.get_min_range.0 max lst);\l               ((lst = []\l                 \|\| not\l                    (not (List.exists under_threshold (List.tl lst))\l                     \|\| not\l                        (20000 \&lt;=\l                         List.fold_right anon_fun.get_min_range.0 max\l                         (List.tl lst))))\l                \|\| not (List.exists under_threshold lst))\l               \|\| not\l                  (20000 \&lt;= List.fold_right anon_fun.get_min_range.0 max lst)])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_324 -&gt; p_316 [label=&quot;&quot;];
subgraph cluster_317 {
  color=blue;
p_316 [label=&quot;Start (((lst = []\l         \|\| not\l            (not (List.exists under_threshold (List.tl lst))\l             \|\| not\l                (20000 \&lt;=\l                 List.fold_right anon_fun.get_min_range.0 max (List.tl lst))))\l        \|\| not (List.exists under_threshold lst))\l       \|\| not (20000 \&lt;= List.fold_right anon_fun.get_min_range.0 max lst)\l       :name \&quot;1.1\&quot; :time 0.294s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_316 -&gt; p_315 [label=&quot;&quot;];
p_315 [label=&quot;Simplify (true\l          :expansions [List.fold_right;\l                       List.exists;\l                       List.fold_right;\l                       List.exists]\l          :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_324 -&gt; p_319 [label=&quot;&quot;];
subgraph cluster_320 {
  color=blue;
p_319 [label=&quot;Start ((((lst = []\l          \|\| not\l             (List.fold_right anon_fun.get_min_range.0 max (List.tl lst) \&lt;=\l              List.hd lst))\l         \|\| not\l            (not (List.exists under_threshold (List.tl lst))\l             \|\| not\l                (20000 \&lt;=\l                 List.fold_right anon_fun.get_min_range.0 max (List.tl lst))))\l        \|\| not (List.exists under_threshold lst))\l       \|\| not (20000 \&lt;= List.fold_right anon_fun.get_min_range.0 max lst)\l       :name \&quot;1.2\&quot; :time 0.294s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_319 -&gt; p_318 [label=&quot;&quot;];
p_318 [label=&quot;Simplify (true\l          :expansions [List.fold_right;\l                       List.exists;\l                       List.fold_right;\l                       List.exists]\l          :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
p_324 -&gt; p_322 [label=&quot;&quot;];
subgraph cluster_323 {
  color=blue;
p_322 [label=&quot;Start (((not (lst = [])\l         \|\| List.fold_right anon_fun.get_min_range.0 max (List.tl lst) \&lt;=\l            List.hd lst &amp;&amp; not (lst = []))\l        \|\| not (List.exists under_threshold lst))\l       \|\| not (20000 \&lt;= List.fold_right anon_fun.get_min_range.0 max lst)\l       :name \&quot;1.3\&quot; :time 0.294s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_322 -&gt; p_321 [label=&quot;&quot;];
p_321 [label=&quot;Simplify (true :expansions [List.exists] :rw [] :fc [])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-b85086b7-d8e6-484e-8de9-444bfab6c319';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-7281fba7-5ac5-4a99-a1c8-d9714db17c05';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-7377a93c-72f8-43f2-8c2c-3acc969c432a';
  fold.hydrate(target);
});
</script></div></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-1e7d61c7-8515-4fd8-95cb-28a0756c8cf5';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div><div class="imandra-vr imandra-vr-proved"><i class="fa fa-check-circle"></i><span>Proved</span></div><div><div class="imandra-alternatives" id="alt-e560daff-d1d3-49d2-8efb-5e46b07d92cd"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>proof</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-proof-top"><div class="imandra-fold panel panel-default" id="fold-9724017c-f9bc-4e38-a503-1eb275f7c5ca"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>proof</span></div></div><div class="panel-body collapse"><div class="imandra-proof"><div class="imandra-alternatives" id="alt-b541c839-0e3c-472a-afdc-08da011ac602"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>summary</a></li><li class="" data-toggle="tab"><a>full</a></li><li class="" data-toggle="tab"><a>graph</a></li></ul><div class="tab-content"><div class="tab-pane active"><div class="imandra-table" id="table-ebf27755-2553-42e1-a194-23c9c1b9a108"><table><tr><td><b>ground_instances</b></td><td>0</td></tr><tr><td><b>definitions</b></td><td>1</td></tr><tr><td><b>inductions</b></td><td>0</td></tr><tr><td><b>search_time</b></td><td><pre>0.066s</pre></td></tr></table></div></div><div class="tab-pane"><div class="imandra-fold panel panel-default" id="fold-834e7a87-54c6-4032-a8fe-17a18e136e25"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>Expand</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.066s, &quot;Goal&quot;]
  (if :var_0:.incoming = None
      || Is_a(Some, :var_0:.incoming)
         &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming)
   then true
   else
     (not
      ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
       = [])
      &amp;&amp; List.fold_right anon_fun.get_min_range.0
         (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_range_max
         (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
         &lt; 20000
      ==&gt; (if :var_0:.incoming = None then :var_0:
           else
           if Is_a(Sensor, Option.get :var_0:.incoming) then … else …).mode
          = Turning))
  &amp;&amp; (List.exists under_threshold
      (if Is_a(Sensor, Option.get :var_0:.incoming)
          &amp;&amp; Is_a(Some, :var_0:.incoming)
       then
         (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
       else [])
      ==&gt; List.fold_right anon_fun.get_min_range.0
          (if Is_a(Sensor, Option.get :var_0:.incoming)
              &amp;&amp; Is_a(Some, :var_0:.incoming)
           then
             (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_range_max
           else 0)
          (if Is_a(Sensor, Option.get :var_0:.incoming)
              &amp;&amp; Is_a(Some, :var_0:.incoming)
           then
             (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
           else [])
          &lt; 20000)
  ==&gt; (if :var_0:.incoming = None
          || Is_a(Some, :var_0:.incoming)
             &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming)
       then true
       else
         not
         ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
          = [])
         &amp;&amp; List.exists under_threshold
            (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges
         ==&gt; (if :var_0:.incoming = None then :var_0:
              else
              if Is_a(Sensor, Option.get :var_0:.incoming) then … else …).mode
             = Turning)</pre></li><li><div><h4>subproof</h4><div class="imandra-fold panel panel-default" id="fold-3cf45167-ec25-4446-978f-fb73c492bd7b"><div class="panel-heading"><div><i class="fa fa-chevron-down hidden"></i><i class="fa fa-chevron-right"></i><span>(((((not
     (((state.incoming = None
        || Is_a(Some, state.incoming)
           &amp;&amp; Is_a(Clock, Option.get state.incoming))
       || not
          (not
           ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
            = [])
           &amp;&amp; not
              (20000 &lt;=
               List.fold_right anon_fun.get_min_range.0
               (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
               (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges)))
      || (if state.incoming = None then state
          else
          if Is_a(Sensor, Option.get state.incoming)
          then if state.mode = Driving then … else …
          else if state.mode = Driving then … else …).mode
         = Turning)
     || not
        (not
         (List.exists under_threshold
          (if Is_a(Sensor, Option.get state.incoming)
              &amp;&amp; Is_a(Some, state.incoming)
           then
             (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
           else []))
         || not
            (20000 &lt;=
             List.fold_right anon_fun.get_min_range.0
             (if Is_a(Sensor, Option.get state.incoming)
                 &amp;&amp; Is_a(Some, state.incoming)
              then
                (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
              else 0)
             (if Is_a(Sensor, Option.get state.incoming)
                 &amp;&amp; Is_a(Some, state.incoming)
              then
                (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
              else []))))
    || (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
       = [])
   || not
      (List.exists under_threshold
       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges))
  || state.incoming = None)
 || Is_a(Some, state.incoming) &amp;&amp; Is_a(Clock, Option.get state.incoming))
|| (if state.incoming = None then state
    else
    if Is_a(Sensor, Option.get state.incoming)
    then if state.mode = Driving then … else …
    else if state.mode = Driving then … else …).mode
   = Turning</span></div></div><div class="panel-body collapse"><ul><li><pre>start[0.060s, &quot;1&quot;]
  (((((not
       (((state.incoming = None
          || Is_a(Some, state.incoming)
             &amp;&amp; Is_a(Clock, Option.get state.incoming))
         || not
            (not
             ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
              = [])
             &amp;&amp; not
                (20000 &lt;=
                 List.fold_right anon_fun.get_min_range.0
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                 (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges)))
        || (if state.incoming = None then state
            else
            if Is_a(Sensor, Option.get state.incoming)
            then if state.mode = Driving then … else …
            else if state.mode = Driving then … else …).mode
           = Turning)
       || not
          (not
           (List.exists under_threshold
            (if Is_a(Sensor, Option.get state.incoming)
                &amp;&amp; Is_a(Some, state.incoming)
             then
               (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
             else []))
           || not
              (20000 &lt;=
               List.fold_right anon_fun.get_min_range.0
               (if Is_a(Sensor, Option.get state.incoming)
                   &amp;&amp; Is_a(Some, state.incoming)
                then
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max
                else 0)
               (if Is_a(Sensor, Option.get state.incoming)
                   &amp;&amp; Is_a(Some, state.incoming)
                then
                  (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
                else []))))
      || (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges
         = [])
     || not
        (List.exists under_threshold
         (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges))
    || state.incoming = None)
   || Is_a(Some, state.incoming) &amp;&amp; Is_a(Clock, Option.get state.incoming))
  || (if state.incoming = None then state
      else
      if Is_a(Sensor, Option.get state.incoming)
      then if state.mode = Driving then … else …
      else if state.mode = Driving then … else …).mode
     = Turning</pre></li><li><div><h5>simplify</h5><div class="imandra-table" id="table-a4309dfc-34ff-432c-bebf-a09e830ebd27"><table><tr><td><b>into</b></td><td><pre>true</pre></td></tr><tr><td><b>expansions</b></td><td><pre>List.fold_right</pre></td></tr><tr><td><b>rewrite_steps</b></td><td><ul></ul></td></tr><tr><td><b>forward_chaining</b></td><td><ul><li><pre>List.len_nonnegative</pre></li><li><pre>List.len_nonnegative</pre></li></ul></td></tr></table></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-3cf45167-ec25-4446-978f-fb73c492bd7b';
  fold.hydrate(target);
});
</script></div></div></li></ul></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-834e7a87-54c6-4032-a8fe-17a18e136e25';
  fold.hydrate(target);
});
</script></div></div><div class="tab-pane"><div class="imandra-graphviz" id="graphviz-65ab77ea-ae9d-43f6-bd57-65ce6e348713"><textarea style="display: none">digraph &quot;proof&quot; {
p_332 [label=&quot;Start ((if :var_0:.incoming = None\l           \|\| Is_a(Some, :var_0:.incoming)\l              &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming)\l        then true\l        else\l          (not\l           ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l            = [])\l           &amp;&amp; List.fold_right anon_fun.get_min_range.0\l              (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_range_max\l              (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l              \&lt; 20000\l           ==\&gt; (if :var_0:.incoming = None then :var_0:\l                else\l                if Is_a(Sensor, Option.get :var_0:.incoming) then …\l                else …).mode\l               = Turning))\l       &amp;&amp; (List.exists under_threshold\l           (if Is_a(Sensor, Option.get :var_0:.incoming)\l               &amp;&amp; Is_a(Some, :var_0:.incoming)\l            then\l              (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l            else [])\l           ==\&gt; List.fold_right anon_fun.get_min_range.0\l               (if Is_a(Sensor, Option.get :var_0:.incoming)\l                   &amp;&amp; Is_a(Some, :var_0:.incoming)\l                then\l                  (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_range_max\l                else 0)\l               (if Is_a(Sensor, Option.get :var_0:.incoming)\l                   &amp;&amp; Is_a(Some, :var_0:.incoming)\l                then\l                  (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l                else [])\l               \&lt; 20000)\l       ==\&gt; (if :var_0:.incoming = None\l               \|\| Is_a(Some, :var_0:.incoming)\l                  &amp;&amp; Is_a(Clock, Option.get :var_0:.incoming)\l            then true\l            else\l              not\l              ((Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l               = [])\l              &amp;&amp; List.exists under_threshold\l                 (Destruct(Sensor, 0, Option.get :var_0:.incoming)).Sensor_msgs.laserScan_ranges\l              ==\&gt; (if :var_0:.incoming = None then :var_0:\l                   else\l                   if Is_a(Sensor, Option.get :var_0:.incoming) then …\l                   else …).mode\l                  = Turning)\l       :name \&quot;Goal\&quot; :time 0.066s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_332 -&gt; p_330 [label=&quot;&quot;];
subgraph cluster_331 {
  color=blue;
p_330 [label=&quot;Start ((((((not\l            (((state.incoming = None\l               \|\| Is_a(Some, state.incoming)\l                  &amp;&amp; Is_a(Clock, Option.get state.incoming))\l              \|\| not\l                 (not\l                  ((Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges\l                   = [])\l                  &amp;&amp; not\l                     (20000 \&lt;=\l                      List.fold_right anon_fun.get_min_range.0\l                      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max\l                      (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges)))\l             \|\| (if state.incoming = None then state\l                 else\l                 if Is_a(Sensor, Option.get state.incoming)\l                 then if state.mode = Driving then … else …\l                 else if state.mode = Driving then … else …).mode\l                = Turning)\l            \|\| not\l               (not\l                (List.exists under_threshold\l                 (if Is_a(Sensor, Option.get state.incoming)\l                     &amp;&amp; Is_a(Some, state.incoming)\l                  then\l                    (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges\l                  else []))\l                \|\| not\l                   (20000 \&lt;=\l                    List.fold_right anon_fun.get_min_range.0\l                    (if Is_a(Sensor, Option.get state.incoming)\l                        &amp;&amp; Is_a(Some, state.incoming)\l                     then\l                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_range_max\l                     else 0)\l                    (if Is_a(Sensor, Option.get state.incoming)\l                        &amp;&amp; Is_a(Some, state.incoming)\l                     then\l                       (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges\l                     else []))))\l           \|\| (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges\l              = [])\l          \|\| not\l             (List.exists under_threshold\l              (Destruct(Sensor, 0, Option.get state.incoming)).Sensor_msgs.laserScan_ranges))\l         \|\| state.incoming = None)\l        \|\| Is_a(Some, state.incoming)\l           &amp;&amp; Is_a(Clock, Option.get state.incoming))\l       \|\| (if state.incoming = None then state\l           else\l           if Is_a(Sensor, Option.get state.incoming)\l           then if state.mode = Driving then … else …\l           else if state.mode = Driving then … else …).mode\l          = Turning\l       :name \&quot;1\&quot; :time 0.060s)&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
p_330 -&gt; p_329 [label=&quot;&quot;];
p_329 [label=&quot;Simplify (true :expansions [List.fold_right] :rw []\l          :fc [List.len_nonnegative; List.len_nonnegative])&quot;,shape=box,style=filled,fontname=&quot;courier&quot;,fontsize=14];
}
}
</textarea><button class="btn btn-primary">Load graph</button><div class="imandra-graphviz-loading display-none">Loading..</div><div class="imandra-graphviz-target"></div><script>
require(['nbextensions/nbimandra/graphviz'], function (graphviz) {
  var target = '#graphviz-65ab77ea-ae9d-43f6-bd57-65ce6e348713';
  graphviz.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-b541c839-0e3c-472a-afdc-08da011ac602';
  alternatives.hydrate(target);
});
</script></div></div></div><script>
require(['nbextensions/nbimandra/fold'], function (fold) {
  var target = '#fold-9724017c-f9bc-4e38-a503-1eb275f7c5ca';
  fold.hydrate(target);
});
</script></div></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-e560daff-d1d3-49d2-8efb-5e46b07d92cd';
  alternatives.hydrate(target);
});
</script></div></div></div>

</div>

</div>

</div>
</div>

</div>
                    </div>

                    <div class="sidebar-right">
                        <div class="sidebar-right__menu">
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h1" href="#Creating-and-Verifying-a-ROS-Node">Creating and Verifying a ROS Node</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h1" href="#1.-ROS-message-OCaml-types">1. ROS message OCaml types</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h1" href="#2.-Creating-a-simple-ROS-Node-model">2. Creating a simple ROS Node model</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h2" href="#2.1-State-datatype">2.1 State datatype</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h2" href="#2.2-State-transition-one_step-function">2.2 State transition one_step function</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h2" href="#2.3-Running-the-model-as-a-ROS-node">2.3 Running the model as a ROS node</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h1" href="#3.-Verifying-the-ROS-node-model">3. Verifying the ROS node model</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h2" href="#3.1-Verifying-outgoing-Twist-message-at-Clock-ticks">3.1 Verifying outgoing Twist message at Clock ticks</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h2" href="#3.2-Verifying-that-we-never-drive-backwards">3.2 Verifying that we never drive backwards</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h1" href="#4.-Inductive-proofs.-Stopping-near-objects.">4. Inductive proofs. Stopping near objects.</a>
                            
                        </div>
                    </div></article>
            </main>
            <footer class="Footer">
                <a class="Copyrights"href="http://imandra.ai">&#9400; 2018 Aesthetic Integration Ltd. All rights reserved.</a>
            </footer>
        </div>
    </body>
    
 


        </div>
        </div>
        </div>
    </body>
</html>
