<!DOCTYPE html>
<html>
    <head><meta charset="utf-8" />
        <meta content="width=device-width, initial-scale=1.0" name="viewport">
        <title>Imandra Documentation - Imandra-tools Introduction</title>
        <meta property="og:url" content="https://docs.imandra.ai/imandra-docs/notebooks/imandra-tools-intro/">
        <meta property="og:type" content="website">
        <meta property="og:title" content="Imandra Documentation - Imandra-tools Introduction">
        <meta property="og:description" content="In this notebook weâ€™re going to introduce the imandra-tools library and explore how it extends Imandra's principal region decomposition utilities.">
        <meta property="og:image" content="https://storage.googleapis.com/imandra-assets/images/og_image_default_i78.jpg">


        
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116937440-6"></script>
        <script>
         window.dataLayer = window.dataLayer || [];
         function gtag(){dataLayer.push(arguments);}
         gtag('js', new Date());

         gtag('config', 'UA-116937440-1');
        </script>
        <script type="text/javascript"> var sc_project=11767520; var sc_invisible=1; var sc_security="fa7e88d1"; </script>
        <script type="text/javascript" src="https://www.statcounter.com/counter/counter.js" async></script>
        <noscript><div class="statcounter">
            <a title="Web Analytics" href="http://statcounter.com/" target="_blank">
                <img class="statcounter" src="//c.statcounter.com/11767520/0/fa7e88d1/1/" alt="Web Analytics"></a>
        </div></noscript>
        

        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js"></script>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:300,300i,400,400i%7CMerriweather:300,300i,400,400i%7CRoboto+Slab:300,300i,400,400i">

        <link rel="stylesheet" href="/imandra-docs/static/style/style.min.9ef6027e.css" type="text/css">
        <link rel="stylesheet" href="/imandra-docs/static/nbextensions/nbimandra/styles.c7ed3d1a.css" type="text/css">
        <link rel="stylesheet" href="/imandra-docs/static/docs-styles.86fc0481.css" type="text/css">
        
        <link rel="stylesheet" href="/imandra-docs/static/jekyll-styles.73f39aa7.css" type="text/css">
        

        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
        <script src="/imandra-docs/static/nbimandra-rjs-bundle.2469bcb7.js"></script>

        <style type="text/css">
         .highlight .hll { background-color: #ffffcc }
         .highlight  { background: #f8f8f8; }
         .highlight .c { color: #408080; font-style: italic } /* Comment */
         .highlight .err { border: 1px solid #FF0000 } /* Error */
         .highlight .k { color: #008000; font-weight: bold } /* Keyword */
         .highlight .o { color: #666666 } /* Operator */
         .highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
         .highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
         .highlight .cp { color: #BC7A00 } /* Comment.Preproc */
         .highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
         .highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
         .highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
         .highlight .gd { color: #A00000 } /* Generic.Deleted */
         .highlight .ge { font-style: italic } /* Generic.Emph */
         .highlight .gr { color: #FF0000 } /* Generic.Error */
         .highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
         .highlight .gi { color: #00A000 } /* Generic.Inserted */
         .highlight .go { color: #888888 } /* Generic.Output */
         .highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
         .highlight .gs { font-weight: bold } /* Generic.Strong */
         .highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
         .highlight .gt { color: #0044DD } /* Generic.Traceback */
         .highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
         .highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
         .highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
         .highlight .kp { color: #008000 } /* Keyword.Pseudo */
         .highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
         .highlight .kt { color: #B00040 } /* Keyword.Type */
         .highlight .m { color: #666666 } /* Literal.Number */
         .highlight .s { color: #BA2121 } /* Literal.String */
         .highlight .na { color: #7D9029 } /* Name.Attribute */
         .highlight .nb { color: #008000 } /* Name.Builtin */
         .highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
         .highlight .no { color: #880000 } /* Name.Constant */
         .highlight .nd { color: #AA22FF } /* Name.Decorator */
         .highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
         .highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
         .highlight .nf { color: #0000FF } /* Name.Function */
         .highlight .nl { color: #A0A000 } /* Name.Label */
         .highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
         .highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
         .highlight .nv { color: #19177C } /* Name.Variable */
         .highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
         .highlight .w { color: #bbbbbb } /* Text.Whitespace */
         .highlight .mb { color: #666666 } /* Literal.Number.Bin */
         .highlight .mf { color: #666666 } /* Literal.Number.Float */
         .highlight .mh { color: #666666 } /* Literal.Number.Hex */
         .highlight .mi { color: #666666 } /* Literal.Number.Integer */
         .highlight .mo { color: #666666 } /* Literal.Number.Oct */
         .highlight .sa { color: #BA2121 } /* Literal.String.Affix */
         .highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
         .highlight .sc { color: #BA2121 } /* Literal.String.Char */
         .highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */
         .highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
         .highlight .s2 { color: #BA2121 } /* Literal.String.Double */
         .highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
         .highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
         .highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
         .highlight .sx { color: #008000 } /* Literal.String.Other */
         .highlight .sr { color: #BB6688 } /* Literal.String.Regex */
         .highlight .s1 { color: #BA2121 } /* Literal.String.Single */
         .highlight .ss { color: #19177C } /* Literal.String.Symbol */
         .highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
         .highlight .fm { color: #0000FF } /* Name.Function.Magic */
         .highlight .vc { color: #19177C } /* Name.Variable.Class */
         .highlight .vg { color: #19177C } /* Name.Variable.Global */
         .highlight .vi { color: #19177C } /* Name.Variable.Instance */
         .highlight .vm { color: #19177C } /* Name.Variable.Magic */
         .highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
        </style>

        <!-- Loading mathjax macro -->
        <!-- Load mathjax -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>
    <!-- MathJax configuration -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true,
            processEnvironments: true
        },
        // Center justify equations in code and markdown cells. Elsewhere
        // we use CSS to left justify single line equations in code cells.
        displayAlign: 'center',
        "HTML-CSS": {
            styles: {'.MathJax_Display': {"margin": 0}},
            linebreaks: { automatic: true }
        }
    });
    </script>
    <!-- End of mathjax configuration --><script>
  function handleCopyClick() {
      var el = this;
      var terminal = el.closest('.terminal');
      var highlight = terminal.getElementsByClassName('highlight')[0];
      copyToClipboardMsg(highlight);

      terminal.classList.add('terminal--hide');
      setTimeout(function () {
          terminal.classList.remove('terminal--hide');
      }, 2000);


      function copyToClipboardMsg(elem) {
          var succeed = copyToClipboard(elem);
          var msg;
          if (!succeed) {
              msg = 'Error!';
          } else {
              msg = 'Copied!';
          }

          var msgElem = terminal.querySelector('.terminal__copy-msg');
          msgElem.innerHTML = msg;
          setTimeout(function () {
              msgElem.innerHTML = 'You rock!';
          }, 1000);
      }

      function copyToClipboard(elem) {
          // create hidden text element, if it doesn't already exist
          var targetId = '_hiddenCopyText_';
          var isInput = elem.tagName === 'INPUT' || elem.tagName === 'TEXTAREA';
          var origSelectionStart, origSelectionEnd;
          if (isInput) {
              // can just use the original source element for the selection and copy
              target = elem;
              origSelectionStart = elem.selectionStart;
              origSelectionEnd = elem.selectionEnd;
          } else {
              // must use a temporary form element for the selection and copy
              target = terminal.querySelector('#' + targetId);
              if (!target) {
                  var target = document.createElement('textarea');
                  // target.style.display = 'flex';
                  // target.style.position = 'absolute';
                  // target.style.left = '-1000%';
                  target.id = targetId;
                 elem.appendChild(target);
              }
              target.textContent = elem.textContent.trim();
          }
          
          // select the content
          var currentFocus = document.activeElement;
          target.focus();
          target.setSelectionRange(0, target.value.length);

          // copy the selection
          var succeed;
          try {
              succeed = document.execCommand('copy');
          } catch (e) {
              succeed = false;
          }
          // restore original focus
          if (currentFocus && typeof currentFocus.focus === 'function') {
              currentFocus.focus();
          }

          if (isInput) {
              // restore prior selection
              elem.setSelectionRange(origSelectionStart, origSelectionEnd);
          } else {
              // clear temporary content
              elem.removeChild(target);
          }
          return succeed;
      }
  }
</script>
    </head>
    <body>
        <div class="background">
        </div>
        <div class="page-container">
            <main class="main-content-column">
                <!-- Jupyter (Imandra core docs) version -->
<header class="header">
    <div class="top-row-container">
        <div class="top-row">

            <div id="toggler--left" class="side__left-menu-toggler">
                <div class="side__toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
                <p class="side__toggle-text">Docs</p>
            </div>

            <div class="side__logo-container">
                <a class="side__logo-link" href="/">
                    <img class="side__logo " src = "/imandra-docs/jekyll-resources/assets/img/ai_logo_green.svg">
                </a>
            </div>

            <div id="toggler--right" class="side__right-menu-toggler">
                <p class="side__toggle-text">Pages</p>
                <div class="side__toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>

            <nav class="side__nav-container side__nav-container--hidden">

                <ul class="side__nav-list">
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link" href="/">Documentation Home</a>
                        
                    </li>
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link side__nav-link--active" href="/imandra-docs">Imandra</a>
                        
                        <ul class="side__nav-list--sub-level-1">
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/welcome">A Quick Tour</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/installation">Installation</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/installation-simple">Simple</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/installation-docker">Docker</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/installation-vscode">VSCode</a>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/logic-and-program-modes">Logic and Program Modes</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/verification">Verification</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Commands">Commands</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Attributes">Attributes</a>
                                        
                                        <ul class="side__nav-list--sub-level-3">
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Verification-Hints">Verification Hints</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Rule-Classes">Rule Classes</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Unrolling">Unrolling</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Simplification">Simplification</a>
                                        
                                        <ul class="side__nav-list--sub-level-3">
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Rewrite-Rules">Rewrite Rules</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Forward-chaining-Rules">Forward-chaining Rules</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Blast">Blast</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Induction">Induction</a>
                                        
                                        <ul class="side__nav-list--sub-level-3">
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Functional-Induction">Functional Induction</a>
                                            </li>
                                            
                                            <li class="side__nav-list-item--sub-level-3">
                                              <a class="side__nav-link" href="/imandra-docs/notebooks/verification/#Structural-Induction">Structural Induction</a>
                                            </li>
                                            
                                        </ul>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/extracting-ocaml-modules-with-imandra-extract">Extracting OCaml modules with imandra-extract</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/proving-program-termination">Proving Program Termination</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                Region Decomposition
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/decomposition-flags">Imandra Decomposition Flags</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link side__nav-link--active" href="/imandra-docs/notebooks/imandra-tools-intro">Imandra Tools Introduction</a>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                            <li class="side__nav-list-item--sub-level-1">
                                
                                <a class="side__nav-link" href="/imandra-docs/notebooks/examples">Examples</a>
                                
                                <ul class="side__nav-list--sub-level-2">
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/recursion-induction-and-rewriting">Recursion, Induction and Rewriting</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verifying-merge-sort">Verifying Merge Sort in Imandra</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/ubs-case-study">Analysing the UBS ATS Dark Pool</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/webservice-auth-logic">Analysing Web-app Authentication Logic</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/simple-vehicle-controller">Simple Vehicle Controller</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/ripple-carry-adder">Verifying a Ripple Carry Adder</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/verifying-an-ros-node">Creating and Verifying a ROS Node</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/reasonml-tic-tac-toe">Tic Tac Toe with ReasonML</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/probabilistic-reasoning-in-reasonml">Probabilistic Reasoning in ReasonML</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/sudoku">Solving Sudoku with Imandra</a>
                                        
                                    </li>
                                    
                                    <li class="side__nav-list-item--sub-level-2">
                                        <a class="side__nav-link" href="/imandra-docs/notebooks/crossing-river-safely">Crossing the River Safely</a>
                                        
                                    </li>
                                    
                                </ul>
                            </li>
                            
                        </ul>
                        
                    </li>
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link" href="/ipl">Imandra Protocol Language</a>
                        
                    </li>
                    
                    <li class="side__nav-list-item TopNavListItem">
                        <a class="side__nav-link" href="/fix-engine">FIX Engine</a>
                        
                    </li>
                    
                </ul>
            </nav>
        </div>
    </div>

    <div class="background">
    </div>

    <div class="template-header">
        <div class="top-bar">
            <nav class="top-bar__nav-container">
                <a href="#" class="top-bar__toggle">â‰¡</a>
                <ul class="top-bar__nav-list top-bar__nav-list--hidden">
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/">Home</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://try.imandra.ai/">Try</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://medium.com/imandra">Blog</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/research">Research</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://docs.imandra.ai/">Docs</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/media">Media</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/about">About AI</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/careers">CAREERS</a></li>
                    <li class="top-bar__nav-list-item"><a class="top-bar__nav-link" href="https://www.imandra.ai/contact">CONTACT</a></li>
                </ul>
            </nav>
        </div>

        <div class="template-header__image-container template-header__image-container--jupyter">
            <div class="template-header__image" href ="/imandra-docs">
                <img class="SiteSpecificImage" src="/imandra-docs/static/img/site_specific_image_v_2.svg">
            </div>
        </div>
        
    </div>

    <script>
        document.getElementById('toggler--left').addEventListener('click', function () {
            document.querySelector('.side__right-menu-toggler .side__toggle').classList.remove('side__toggle--active');
            document.querySelector('.side__left-menu-toggler .side__toggle').classList.toggle('side__toggle--active');
            document.getElementsByClassName('side__nav-container')[0].classList.toggle('side__nav-container--hidden');
            document.getElementsByClassName('top-bar__nav-list')[0].classList.add('top-bar__nav-list--hidden');
        });

        document.getElementById('toggler--right').addEventListener('click', function () {
            document.querySelector('.side__left-menu-toggler .side__toggle').classList.remove('side__toggle--active');
            document.querySelector('.side__right-menu-toggler .side__toggle').classList.toggle('side__toggle--active');
            document.getElementsByClassName('side__nav-container')[0].classList.add('side__nav-container--hidden');
            document.getElementsByClassName('top-bar__nav-list')[0].classList.toggle('top-bar__nav-list--hidden');
        });

    </script>
</header>
                <article class="article__container article__container--notebooks">
                    <div class="main-content main-content--jupyter">
                        
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h1 id="An-introduction-to-imandra-tools">An introduction to <code>imandra-tools</code><a class="anchor-link" href="#An-introduction-to-imandra-tools">&#182;</a></h1><p>In this notebook, we'll introduce the <code>imandra-tools</code> library and go through how to use its powerful modules to augment Imandra's decomposition facilities.</p>
<p>Normally, before using <code>imandra-tools</code>, one would have to require it in their Imandra toplevel by executing the require statement <code>#require "imandra-tools"</code>. Since the <code>#require</code> directive is disabled for security reasons in this notebook, this step won't be necessary as we've pre-loaded imandra-tools.</p>
<p>Let's make sure this is actually the case before starting.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-2" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="o">#</span><span class="n">show</span> <span class="nc">Imandra_tools</span><span class="o">;;</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[1]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>module Imandra_tools :
  sig
    module Idf = Imandra_tools__Idf
    module Region_pp = Imandra_tools__Region_pp
    module Term_synth = Imandra_tools__Term_synth
  end
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Great! Let's start exploring <code>imandra-tools</code>.</p>
<ul>
<li><a href="#Iterative-Decomposition-Framework-%28Idf%29">Idf</a></li>
<li><a href="#Region-Pretty-Printer-%28Region_pp%29">Region_pp</a></li>
<li><a href="#Term-Synthesizer-%28Term_synth%29">Term_synth</a></li>
</ul>
<div style="margin-top: 1em; background-color: #ffcc66; padding: 1em">
Note: this is an introductory walkthrough of the capabilities of `imandra-tools`, much more than what's described in this notebook is possible with it, but we'll defer a more in-depth explanation of each module in future notebooks.
</div><h1 id="Iterative-Decomposition-Framework-(Idf)">Iterative Decomposition Framework (Idf)<a class="anchor-link" href="#Iterative-Decomposition-Framework-(Idf)">&#182;</a></h1><p>The first module we're going to explore is <code>Imandra_tools.Idf</code>. Its broad purpose is to provide a framework allowing for iterative, lazy decomposition of state-machine models.</p>
<p>Before diving into its usage, let's first define a simple example of such a model.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-4" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">module</span> <span class="nc">Model</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">message</span> <span class="o">=</span> <span class="nc">Add</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Sub</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Reset</span>

  <span class="k">type</span> <span class="n">counter_state</span> <span class="o">=</span> <span class="o">{</span> <span class="n">counter</span> <span class="o">:</span> <span class="kt">int</span>
                       <span class="o">;</span> <span class="n">default</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">}</span>

  <span class="k">let</span> <span class="n">one_step</span> <span class="n">msg</span> <span class="n">state</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">1337</span> <span class="k">then</span>
      <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">default</span> <span class="o">}</span>
    <span class="k">else</span>
      <span class="k">match</span> <span class="n">msg</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Reset</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">}</span>
      <span class="o">|</span> <span class="nc">Add</span> <span class="n">n</span> <span class="o">-&gt;</span>
         <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">counter</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">9000</span> <span class="k">then</span>
           <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">}</span>
         <span class="k">else</span>
           <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">counter</span> <span class="o">+</span> <span class="n">n</span> <span class="o">}</span>
      <span class="o">|</span> <span class="nc">Sub</span> <span class="n">n</span> <span class="o">-&gt;</span>
         <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">.</span><span class="n">counter</span> <span class="k">then</span>
           <span class="n">state</span>
         <span class="k">else</span>
           <span class="o">{</span> <span class="n">state</span> <span class="k">with</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">counter</span> <span class="o">-</span> <span class="n">n</span> <span class="o">}</span>
  <span class="k">end</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[2]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>module Model :
  sig
    type message = Add of int | Sub of int | Reset
    type counter_state = { counter : int; default : int; }
    val one_step : message -&gt; counter_state -&gt; counter_state
  end
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The above model is not very interesting but it exemplifies all that's needed for a model to be suitable for usage with <code>Idf</code>:</p>
<ul>
<li>A variant type describing all the possible messages a model can react to (<code>message</code>)</li>
<li>A record type describing the current state of the model (<code>counter_state</code>)</li>
<li>A transition function from message and state to new state (<code>one_step</code>)</li>
</ul>
<p>Now that the module is defined, we need to set-up <code>Idf</code> for its decomposition.</p>
<p>The first thing we need to do is define a module implementing the <code>Idf.SIG_TPL</code> module signature:</p>
<ul>
<li>an <code>event</code> type mapping to the model message type</li>
<li>a <code>state</code> type mapping to the model state type</li>
<li>an <code>init_state</code> value of type <code>state</code></li>
<li>a <code>step</code> transition function mapping to the model transition function</li>
<li>an <code>is_valid</code> function that takes an <code>event</code> and a <code>state</code> and checks whether that <code>&lt;event,state&gt;</code> transition is valid or not</li>
<li>a <code>pp_state</code> function of <code>state</code> to <code>string</code> to serialize a <code>state</code> value (usually, for complex types, the <code>Genpp</code> module provided with imandra is used to automatically generate this function)</li>
<li>a <code>module_name</code> value mapping to the name of the module being defined (this is necessary for reflection purposes)</li>
<li>an <code>enough_samples</code> function (we'll gloss over describing what this does for now and defer to a more in-depth tutorial specific to <code>Idf</code>, a default implementation just returns <code>true</code>)</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-6" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">open</span> <span class="nc">Imandra_tools</span>

<span class="k">module</span> <span class="nc">DecompositionConfig</span> <span class="o">=</span> <span class="k">struct</span>

  <span class="k">open</span> <span class="nc">Model</span>

  <span class="k">type</span> <span class="n">event</span> <span class="o">=</span> <span class="n">message</span>
  <span class="k">type</span> <span class="n">state</span> <span class="o">=</span> <span class="n">counter_state</span>

  <span class="k">let</span> <span class="n">init_state</span> <span class="o">:</span> <span class="n">state</span> <span class="o">=</span>
    <span class="o">{</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">;</span> <span class="n">default</span> <span class="o">=</span> <span class="mi">23</span> <span class="o">}</span>

  <span class="k">let</span> <span class="n">step</span> <span class="o">(</span><span class="n">event</span> <span class="o">:</span> <span class="n">event</span><span class="o">)</span> <span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">state</span><span class="o">)</span> <span class="o">:</span> <span class="n">state</span> <span class="o">=</span>
     <span class="n">one_step</span> <span class="n">event</span> <span class="n">state</span>

  <span class="k">let</span> <span class="n">is_valid</span> <span class="o">(</span><span class="n">event</span> <span class="o">:</span> <span class="n">event</span><span class="o">)</span> <span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">state</span><span class="o">)</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">event</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Reset</span> <span class="o">-&gt;</span> <span class="bp">true</span>
    <span class="o">|</span> <span class="nc">Add</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="o">|</span> <span class="nc">Sub</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">state</span><span class="o">.</span><span class="n">counter</span>

  <span class="k">let</span> <span class="n">pp_state</span> <span class="o">(</span><span class="n">state</span> <span class="o">:</span> <span class="n">state</span><span class="o">)</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;{ counter = %s; default = %s }&quot;</span>
                   <span class="o">(</span><span class="nn">Int</span><span class="p">.</span><span class="n">to_string</span> <span class="n">state</span><span class="o">.</span><span class="n">counter</span><span class="o">)</span>
                   <span class="o">(</span><span class="nn">Int</span><span class="p">.</span><span class="n">to_string</span> <span class="n">state</span><span class="o">.</span><span class="n">default</span><span class="o">)</span>
    <span class="o">[@@</span><span class="n">program</span><span class="o">]</span>

  <span class="k">let</span> <span class="n">module_name</span> <span class="o">=</span> <span class="s2">&quot;DecompositionConfig&quot;</span>
  <span class="k">let</span> <span class="n">enough_samples</span> <span class="o">~</span><span class="n">strategy</span> <span class="o">~</span><span class="n">arg</span> <span class="o">~</span><span class="n">region</span> <span class="n">evs</span> <span class="o">=</span> <span class="bp">true</span> <span class="o">[@@</span><span class="n">program</span><span class="o">]</span>
<span class="k">end</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[3]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>module DecompositionConfig :
  sig
    type event = Model.message
    type state = Model.counter_state
    val init_state : state
    val step : event -&gt; state -&gt; state
    val is_valid : event -&gt; state -&gt; bool
    val pp_state : state -&gt; string
    val module_name : string
    val enough_samples : strategy:&#39;a -&gt; arg:&#39;b -&gt; region:&#39;c -&gt; &#39;d -&gt; bool
  end
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The second thing we need to do is to define a <code>Template</code> module implementing the <code>Idf.Template.SIG</code> module signature:</p>
<ul>
<li>a <code>t</code> variant type symbolically describing events from our model</li>
<li>a <code>concrete</code> function from <code>t</code> to a list of strings mapping the symbolic event to concrete <code>event</code> type names</li>
</ul>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-8" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[4]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">module</span> <span class="nc">Template</span> <span class="o">=</span> <span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Add</span> <span class="o">|</span> <span class="nc">Sub</span> <span class="o">|</span> <span class="nc">Reset</span> <span class="o">|</span> <span class="nc">Any</span>

  <span class="k">let</span> <span class="n">concrete</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Add</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="s2">&quot;Model.Add&quot;</span><span class="o">]</span>
    <span class="o">|</span> <span class="nc">Sub</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="s2">&quot;Model.Sub&quot;</span><span class="o">]</span>
    <span class="o">|</span> <span class="nc">Reset</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="s2">&quot;Model.Reset&quot;</span><span class="o">]</span>
    <span class="o">|</span> <span class="nc">Any</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
<span class="k">end</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[4]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>module Template :
  sig type t = Add | Sub | Reset | Any val concrete : t -&gt; string list end
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We're now ready to create a decomposition recipe and apply it to an event template:</p>
<p>First we use <code>Idf.mex_for</code> to create an imandra <code>Mex</code> module (this is just a convenience function wrapping imandra's <code>Extract</code> module)</p>
<p>Second we can finally hook it all together by passing <code>DecompositionConfig</code>, <code>Mex</code>, and <code>Template</code> as parameters to the <code>Idf.Make</code> functor, and obtain a <code>D</code> module of signature <code>Idf.SIG</code>.</p>
<p>We can use the <code>D</code> module to start decomposing any sequences of events, by using either <code>D.Symbolic.decompose</code> or <code>D.Concrete.decompose</code>, depending on which decomposition strategy we want:</p>
<ul>
<li>concrete: this strategy will decompose the first event in the sequence, sample a value off each region and continue decomposition using the sampled value as next initial state when decomposing the next event. Because of its reliance on random sampling, this strategy is not complete, but is quite fast.</li>
<li>symbolic: this strategy will synthesize the constraints and invariants of each region as ocaml code and inject them into the decomposition of the next event, no sampling is done and thus this strategy is complete, but can also be much slower than concrete.</li>
</ul>
<p>Let's use <code>D.Symbolic.decompose</code> for this notebook, over a template of <code>[any; add; any]</code> events:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-10" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[5]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="o">#</span><span class="n">program</span><span class="o">;;</span>
                                   
<span class="nn">Idf</span><span class="p">.</span><span class="n">mex_for</span> <span class="nn">DecompositionConfig</span><span class="p">.</span><span class="n">module_name</span> <span class="bp">()</span> 
<span class="k">module</span> <span class="nc">D</span> <span class="o">=</span> <span class="nn">Idf</span><span class="p">.</span><span class="nc">Make</span><span class="o">(</span><span class="nc">DecompositionConfig</span><span class="o">)(</span><span class="nc">Mex</span><span class="o">)(</span><span class="nc">Template</span><span class="o">)</span>

<span class="k">let</span> <span class="n">paths</span><span class="o">,</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">D</span><span class="p">.</span><span class="nn">Symbolic</span><span class="p">.</span><span class="n">decompose</span> <span class="o">(</span><span class="nn">D</span><span class="p">.</span><span class="nc">Template</span> <span class="nn">Template</span><span class="p">.</span><span class="o">[</span><span class="nc">Any</span><span class="o">;</span><span class="nc">Add</span><span class="o">;</span><span class="nc">Any</span><span class="o">])</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[5]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val imandra_gensym__1 :
  DecompositionConfig.event list -&gt; DecompositionConfig.state = &lt;fun&gt;
module Mex :
  sig
    module E = Imandra_interactive.Extract_frontend
    val get_option : (E.expr -&gt; &#39;a_0) -&gt; E.expr -&gt; &#39;a_0 option
    val get_Peano_nat_t : E.expr -&gt; Peano_nat.t
    val get_unit : E.expr -&gt; unit
    val get_result :
      (E.expr -&gt; &#39;a_0) -&gt; (E.expr -&gt; &#39;a_1) -&gt; E.expr -&gt; (&#39;a_0, &#39;a_1) result
    val get_Result_t :
      (E.expr -&gt; &#39;a_0) -&gt; (E.expr -&gt; &#39;a_1) -&gt; E.expr -&gt; (&#39;a_0, &#39;a_1) Result.t
    val get_either :
      (E.expr -&gt; &#39;a_0) -&gt; (E.expr -&gt; &#39;a_1) -&gt; E.expr -&gt; (&#39;a_0, &#39;a_1) either
    val get_List_t : (E.expr -&gt; &#39;a_0) -&gt; E.expr -&gt; &#39;a_0 List.t
    val get_Int_t : E.expr -&gt; Int.t
    val get_Option_t : (E.expr -&gt; &#39;a_0) -&gt; E.expr -&gt; &#39;a_0 Option.t
    val get_Real_t : E.expr -&gt; Real.t
    val get_Map_t :
      (E.expr -&gt; &#39;a_0) -&gt; (E.expr -&gt; &#39;a_1) -&gt; E.expr -&gt; (&#39;a_0, &#39;a_1) Map.t
    val get_Multiset_t : (E.expr -&gt; &#39;a_0) -&gt; E.expr -&gt; &#39;a_0 Multiset.t
    val get_Set_t : (E.expr -&gt; &#39;a_0) -&gt; E.expr -&gt; &#39;a_0 Set.t
    val get_String_t : E.expr -&gt; String.t
    val get_Float_t : E.expr -&gt; Float.t
    val get_Model_message : E.expr -&gt; Model.message
    val get_Model_counter_state : E.expr -&gt; Model.counter_state
    val get_DecompositionConfig_event : E.expr -&gt; DecompositionConfig.event
    val get_DecompositionConfig_state : E.expr -&gt; DecompositionConfig.state
    val get_Template_t : E.expr -&gt; Template.t
    type e_t = DecompositionConfig.event list
    type extract_type = { e : e_t; }
    val ret_e : extract_type -&gt; e_t
    val of_model :
      ?signature:string -&gt;
      Imandra_surface.Top_result.term_model -&gt; extract_type
  end
- : unit = ()
module D :
  sig
    type template = Template.t list
    type funs = Imandra_prelude.string list * Imandra_prelude.string list
    type target =
      Imandra_tools__Idf.Make(DecompositionConfig)(Mex)(Template).target =
        Template of template
      | Funs of funs
    module L :
      sig
        type &#39;a t =
            &#39;a
            Imandra_tools__Idf.Make(DecompositionConfig)(Mex)(Template).L.t
        val lazily : (Imandra_prelude.unit -&gt; &#39;a t) -&gt; &#39;a t
        val reify : Imandra_prelude.Caml.Int.t -&gt; &#39;a t -&gt; &#39;a list
        val reify_all : &#39;a t -&gt; &#39;a list
        val of_list : &#39;a list -&gt; &#39;a t
        val of_gen : &#39;a Imandra_tools__Idf.gen -&gt; &#39;a t
        val empty : &#39;a t
        val is_empty : &#39;a t -&gt; bool
        val map : f:(&#39;a -&gt; &#39;b) -&gt; &#39;a t -&gt; &#39;b t
        val flat_map : f:(&#39;a -&gt; &#39;b t) -&gt; &#39;a t -&gt; &#39;b t
        val return : &#39;a -&gt; &#39;a t
        val default : default:&#39;a t -&gt; &#39;a t -&gt; &#39;a t
        val cons : &#39;a -&gt; &#39;a t -&gt; &#39;a t
      end
    module Gen :
      sig
        val funs_of_template : template -&gt; funs
        val funs_of_steps : Imandra_prelude.string list list -&gt; funs
        val target_of_funs : funs -&gt; target
      end
    module Mex :
      sig
        type event = DecompositionConfig.event
        val events_of_region :
          arg:Imandra_prelude.Caml.Int.t -&gt;
          signature:Imandra_prelude.string -&gt;
          Imandra_tools__Idf.Decompose.t -&gt;
          (Imandra_surface.Top_result.term_model * event)
          Imandra_tools__Idf.gen
      end
    module Strategy :
      sig
        module Concrete :
          sig
            type state = DecompositionConfig.state
            type event = DecompositionConfig.event
            type node_t = DecompositionConfig.state
            val module_name : Imandra_prelude.string
            val root_node : node_t
            val node_tpl_for_target : node_t -&gt; Imandra_prelude.string
            val node_tpl_for_side_cond : node_t -&gt; Imandra_prelude.string
            val node_hash : node_t -&gt; Imandra_prelude.Caml.Int.t
            val node_equal : node_t -&gt; node_t -&gt; bool
            val step_into_region :
              node:node_t -&gt;
              signature:Imandra_prelude.string -&gt;
              Imandra_prelude.Caml.Int.t -&gt;
              Imandra_tools__Idf.Decompose.t -&gt;
              (Imandra_surface.Top_result.term_model * event * node_t)
              Imandra_tools__Idf.gen
            val strategy : Imandra_tools__Idf.strategy
          end
        type node_t =
          Imandra_tools__Idf.Make(DecompositionConfig)(Mex)(Template).Strategy.node_t =
            Expr of (Imandra_surface.Term.t * Imandra_surface.Term.t list)
          | Str of Imandra_prelude.string * Imandra_prelude.string
        module Symbolic :
          sig
            type state = DecompositionConfig.state
            type event = DecompositionConfig.event
            type node_t = node_t
            val module_name : Imandra_prelude.string
            val root_node : node_t
            val node_tpl_for_target : node_t -&gt; Imandra_prelude.string
            val node_tpl_for_side_cond : node_t -&gt; Imandra_prelude.string
            val node_hash : node_t -&gt; Imandra_prelude.Caml.Int.t
            val node_equal : node_t -&gt; node_t -&gt; bool
            val step_into_region :
              node:node_t -&gt;
              signature:Imandra_prelude.string -&gt;
              Imandra_prelude.Caml.Int.t -&gt;
              Imandra_tools__Idf.Decompose.t -&gt;
              (Imandra_surface.Top_result.term_model * event * node_t)
              Imandra_tools__Idf.gen
            val strategy : Imandra_tools__Idf.strategy
          end
      end
    module type SIG =
      functor
        (S : sig
               type state = DecompositionConfig.state
               type event = DecompositionConfig.event
               type node_t
               val module_name : Imandra_prelude.string
               val root_node : node_t
               val node_tpl_for_target : node_t -&gt; Imandra_prelude.string
               val node_tpl_for_side_cond : node_t -&gt; Imandra_prelude.string
               val node_hash : node_t -&gt; Imandra_prelude.Caml.Int.t
               val node_equal : node_t -&gt; node_t -&gt; bool
               val step_into_region :
                 node:node_t -&gt;
                 signature:Imandra_prelude.string -&gt;
                 Imandra_prelude.Caml.Int.t -&gt;
                 Imandra_tools__Idf.Decompose.t -&gt;
                 (Imandra_surface.Top_result.term_model * event * node_t)
                 Imandra_tools__Idf.gen
               val strategy : Imandra_tools__Idf.strategy
             end) -&gt;
        sig
          type decomp_step = {
            sample : S.event;
            region : Imandra_tools__Idf.Decompose.t;
            signature : Imandra_prelude.string;
            model : Imandra_surface.Top_result.term_model;
          }
          type indexed_state = {
            state : S.node_t;
            idx : Imandra_prelude.Caml.Int.t;
          }
          module G :
            sig
              type t
              module V : Graph.Sig.VERTEX
              type vertex = V.t
              module E :
                sig
                  type t
                  val compare : t -&gt; t -&gt; int
                  type vertex = vertex
                  val src : t -&gt; vertex
                  val dst : t -&gt; vertex
                  type label
                  val create : vertex -&gt; label -&gt; vertex -&gt; t
                  val label : t -&gt; label
                end
              type edge = E.t
              val is_directed : bool
              val is_empty : t -&gt; bool
              val nb_vertex : t -&gt; int
              val nb_edges : t -&gt; int
              val out_degree : t -&gt; vertex -&gt; int
              val in_degree : t -&gt; vertex -&gt; int
              val mem_vertex : t -&gt; vertex -&gt; bool
              val mem_edge : t -&gt; vertex -&gt; vertex -&gt; bool
              val mem_edge_e : t -&gt; edge -&gt; bool
              val find_edge : t -&gt; vertex -&gt; vertex -&gt; edge
              val find_all_edges : t -&gt; vertex -&gt; vertex -&gt; edge list
              val succ : t -&gt; vertex -&gt; vertex list
              val pred : t -&gt; vertex -&gt; vertex list
              val succ_e : t -&gt; vertex -&gt; edge list
              val pred_e : t -&gt; vertex -&gt; edge list
              val iter_vertex : (vertex -&gt; unit) -&gt; t -&gt; unit
              val fold_vertex : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
              val iter_edges : (vertex -&gt; vertex -&gt; unit) -&gt; t -&gt; unit
              val fold_edges :
                (vertex -&gt; vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
              val iter_edges_e : (edge -&gt; unit) -&gt; t -&gt; unit
              val fold_edges_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
              val map_vertex : (vertex -&gt; vertex) -&gt; t -&gt; t
              val iter_succ : (vertex -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
              val iter_pred : (vertex -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
              val fold_succ : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
              val fold_pred : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
              val iter_succ_e : (edge -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
              val fold_succ_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
              val iter_pred_e : (edge -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
              val fold_pred_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
              val create :
                ?size:Imandra_prelude.Caml.Int.t -&gt; Imandra_prelude.unit -&gt; t
              module type LH =
                sig
                  val decomp_step_hash :
                    decomp_step -&gt; Imandra_prelude.Caml.Int.t
                  val indexed_state_hash :
                    indexed_state -&gt; Imandra_prelude.Caml.Int.t
                  val decomp_step_label :
                    decomp_step -&gt; Imandra_prelude.string
                  val indexed_state_label :
                    indexed_state -&gt; Imandra_prelude.string
                end
              module type SIG =
                sig
                  val output_graph :
                    t -&gt; Imandra_prelude.string -&gt; Imandra_prelude.unit
                  val find_edges :
                    t -&gt; Imandra_prelude.Caml.Int.t -&gt; decomp_step list
                  val find_vertices :
                    t -&gt; Imandra_prelude.Caml.Int.t -&gt; indexed_state list
                end
              val root : t -&gt; vertex
              module Make : functor (L : LH) -&gt; SIG
            end
          type step = indexed_state * decomp_step * indexed_state
          type path = step list
          type t = path L.t * G.t
          val paths : ?v:G.vertex -&gt; G.t -&gt; path L.t
          val region_of_path : path -&gt; Imandra_tools__Idf.Decompose.t list
          val regions : path L.t -&gt; Imandra_tools__Idf.Decompose.t list L.t
          val replay_path : path -&gt; (S.state * S.event * S.state) list
          type decomp_data =
              S.event * S.node_t * Imandra_tools__Idf.Decompose.t
          type &#39;a prod = [ `Prod of &#39;a ]
          type consumable_step =
              (decomp_data * step * bool) *
              (Imandra_prelude.unit -&gt; consumable_step L.t prod)
          val decompose_one :
            ?g:G.t -&gt;
            ?root:S.node_t -&gt;
            ?idx:Imandra_prelude.Caml.Int.t -&gt;
            ?basis:Imandra_prelude.string list -&gt;
            ?max_asm_lookahead:Imandra_prelude.Caml.Int.t -&gt;
            ?max_ctx_simp:Imandra_prelude.Caml.Int.t -&gt;
            ?reduce_symmetry:bool -&gt;
            ?ctx_asm_simp:bool -&gt;
            ?aggressive_rec:bool -&gt;
            ?compound:bool -&gt; target -&gt; consumable_step L.t
          val node_of_consumable_step : consumable_step -&gt; S.node_t
          val decompose :
            ?g:G.t -&gt;
            ?root:S.node_t -&gt;
            ?idx:Imandra_prelude.Caml.Int.t -&gt;
            ?cache_convergent_paths:bool -&gt;
            ?include_partials:bool -&gt;
            ?basis:Imandra_prelude.string list -&gt;
            ?max_asm_lookahead:Imandra_prelude.Caml.Int.t -&gt;
            ?max_ctx_simp:Imandra_prelude.Caml.Int.t -&gt;
            ?reduce_symmetry:bool -&gt;
            ?ctx_asm_simp:bool -&gt;
            ?aggressive_rec:bool -&gt; ?compound:bool -&gt; target -&gt; t
        end
    module WithStrategy :
      functor
        (S : sig
               type state = DecompositionConfig.state
               type event = DecompositionConfig.event
               type node_t
               val module_name : Imandra_prelude.string
               val root_node : node_t
               val node_tpl_for_target : node_t -&gt; Imandra_prelude.string
               val node_tpl_for_side_cond : node_t -&gt; Imandra_prelude.string
               val node_hash : node_t -&gt; Imandra_prelude.Caml.Int.t
               val node_equal : node_t -&gt; node_t -&gt; bool
               val step_into_region :
                 node:node_t -&gt;
                 signature:Imandra_prelude.string -&gt;
                 Imandra_prelude.Caml.Int.t -&gt;
                 Imandra_tools__Idf.Decompose.t -&gt;
                 (Imandra_surface.Top_result.term_model * event * node_t)
                 Imandra_tools__Idf.gen
               val strategy : Imandra_tools__Idf.strategy
             end) -&gt;
        sig
          type decomp_step =
            Imandra_tools__Idf.Make(DecompositionConfig)(Mex)(Template).WithStrategy(S).decomp_step = {
            sample : S.event;
            region : Imandra_tools__Idf.Decompose.t;
            signature : Imandra_prelude.string;
            model : Imandra_surface.Top_result.term_model;
          }
          type indexed_state =
            Imandra_tools__Idf.Make(DecompositionConfig)(Mex)(Template).WithStrategy(S).indexed_state = {
            state : S.node_t;
            idx : Imandra_prelude.Caml.Int.t;
          }
          module G :
            sig
              type t =
                  Imandra_tools__Idf.Make(DecompositionConfig)(Mex)(Template).WithStrategy(S).G.t
              module V :
                sig
                  type t =
                      Imandra_tools__Idf.Make(DecompositionConfig)(Mex)(Template).WithStrategy(S).G.V.t
                  val compare : t -&gt; t -&gt; int
                  val hash : t -&gt; int
                  val equal : t -&gt; t -&gt; bool
                  type label =
                      Imandra_tools__Idf.Make(DecompositionConfig)(Mex)(Template).WithStrategy(S).G.V.label
                  val create : label -&gt; t
                  val label : t -&gt; label
                end
              type vertex = V.t
              module E :
                sig
                  type t =
                      Imandra_tools__Idf.Make(DecompositionConfig)(Mex)(Template).WithStrategy(S).G.E.t
                  val compare : t -&gt; t -&gt; int
                  type vertex = vertex
                  val src : t -&gt; vertex
                  val dst : t -&gt; vertex
                  type label =
                      Imandra_tools__Idf.Make(DecompositionConfig)(Mex)(Template).WithStrategy(S).G.E.label
                  val create : vertex -&gt; label -&gt; vertex -&gt; t
                  val label : t -&gt; label
                end
              type edge = E.t
              val is_directed : bool
              val is_empty : t -&gt; bool
              val nb_vertex : t -&gt; int
              val nb_edges : t -&gt; int
              val out_degree : t -&gt; vertex -&gt; int
              val in_degree : t -&gt; vertex -&gt; int
              val mem_vertex : t -&gt; vertex -&gt; bool
              val mem_edge : t -&gt; vertex -&gt; vertex -&gt; bool
              val mem_edge_e : t -&gt; edge -&gt; bool
              val find_edge : t -&gt; vertex -&gt; vertex -&gt; edge
              val find_all_edges : t -&gt; vertex -&gt; vertex -&gt; edge list
              val succ : t -&gt; vertex -&gt; vertex list
              val pred : t -&gt; vertex -&gt; vertex list
              val succ_e : t -&gt; vertex -&gt; edge list
              val pred_e : t -&gt; vertex -&gt; edge list
              val iter_vertex : (vertex -&gt; unit) -&gt; t -&gt; unit
              val fold_vertex : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
              val iter_edges : (vertex -&gt; vertex -&gt; unit) -&gt; t -&gt; unit
              val fold_edges :
                (vertex -&gt; vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
              val iter_edges_e : (edge -&gt; unit) -&gt; t -&gt; unit
              val fold_edges_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
              val map_vertex : (vertex -&gt; vertex) -&gt; t -&gt; t
              val iter_succ : (vertex -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
              val iter_pred : (vertex -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
              val fold_succ : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
              val fold_pred : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
              val iter_succ_e : (edge -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
              val fold_succ_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
              val iter_pred_e : (edge -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
              val fold_pred_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
              val create :
                ?size:Imandra_prelude.Caml.Int.t -&gt; Imandra_prelude.unit -&gt; t
              module type LH =
                sig
                  val decomp_step_hash :
                    decomp_step -&gt; Imandra_prelude.Caml.Int.t
                  val indexed_state_hash :
                    indexed_state -&gt; Imandra_prelude.Caml.Int.t
                  val decomp_step_label :
                    decomp_step -&gt; Imandra_prelude.string
                  val indexed_state_label :
                    indexed_state -&gt; Imandra_prelude.string
                end
              module type SIG =
                sig
                  val output_graph :
                    t -&gt; Imandra_prelude.string -&gt; Imandra_prelude.unit
                  val find_edges :
                    t -&gt; Imandra_prelude.Caml.Int.t -&gt; decomp_step list
                  val find_vertices :
                    t -&gt; Imandra_prelude.Caml.Int.t -&gt; indexed_state list
                end
              val root : t -&gt; vertex
              module Make :
                functor (L : LH) -&gt;
                  sig
                    val output_graph :
                      t -&gt; Imandra_prelude.string -&gt; Imandra_prelude.unit
                    val find_edges :
                      t -&gt; Imandra_prelude.Caml.Int.t -&gt; decomp_step list
                    val find_vertices :
                      t -&gt; Imandra_prelude.Caml.Int.t -&gt; indexed_state list
                  end
            end
          type step = indexed_state * decomp_step * indexed_state
          type path = step list
          type t = path L.t * G.t
          val paths : ?v:G.vertex -&gt; G.t -&gt; path L.t
          val region_of_path : path -&gt; Imandra_tools__Idf.Decompose.t list
          val regions : path L.t -&gt; Imandra_tools__Idf.Decompose.t list L.t
          val replay_path : path -&gt; (S.state * S.event * S.state) list
          type decomp_data =
              S.event * S.node_t * Imandra_tools__Idf.Decompose.t
          type &#39;a prod = [ `Prod of &#39;a ]
          type consumable_step =
              (decomp_data * step * bool) *
              (Imandra_prelude.unit -&gt; consumable_step L.t prod)
          val decompose_one :
            ?g:G.t -&gt;
            ?root:S.node_t -&gt;
            ?idx:Imandra_prelude.Caml.Int.t -&gt;
            ?basis:Imandra_prelude.string list -&gt;
            ?max_asm_lookahead:Imandra_prelude.Caml.Int.t -&gt;
            ?max_ctx_simp:Imandra_prelude.Caml.Int.t -&gt;
            ?reduce_symmetry:bool -&gt;
            ?ctx_asm_simp:bool -&gt;
            ?aggressive_rec:bool -&gt;
            ?compound:bool -&gt; target -&gt; consumable_step L.t
          val node_of_consumable_step : consumable_step -&gt; S.node_t
          val decompose :
            ?g:G.t -&gt;
            ?root:S.node_t -&gt;
            ?idx:Imandra_prelude.Caml.Int.t -&gt;
            ?cache_convergent_paths:bool -&gt;
            ?include_partials:bool -&gt;
            ?basis:Imandra_prelude.string list -&gt;
            ?max_asm_lookahead:Imandra_prelude.Caml.Int.t -&gt;
            ?max_ctx_simp:Imandra_prelude.Caml.Int.t -&gt;
            ?reduce_symmetry:bool -&gt;
            ?ctx_asm_simp:bool -&gt;
            ?aggressive_rec:bool -&gt; ?compound:bool -&gt; target -&gt; t
        end
    module Concrete :
      sig
        type decomp_step =
          WithStrategy(Strategy.Concrete).decomp_step = {
          sample : Strategy.Concrete.event;
          region : Imandra_tools__Idf.Decompose.t;
          signature : Imandra_prelude.string;
          model : Imandra_surface.Top_result.term_model;
        }
        type indexed_state =
          WithStrategy(Strategy.Concrete).indexed_state = {
          state : Strategy.Concrete.node_t;
          idx : Imandra_prelude.Caml.Int.t;
        }
        module G :
          sig
            type t = WithStrategy(Strategy.Concrete).G.t
            module V :
              sig
                type t = WithStrategy(Strategy.Concrete).G.V.t
                val compare : t -&gt; t -&gt; int
                val hash : t -&gt; int
                val equal : t -&gt; t -&gt; bool
                type label = WithStrategy(Strategy.Concrete).G.V.label
                val create : label -&gt; t
                val label : t -&gt; label
              end
            type vertex = V.t
            module E :
              sig
                type t = WithStrategy(Strategy.Concrete).G.E.t
                val compare : t -&gt; t -&gt; int
                type vertex = vertex
                val src : t -&gt; vertex
                val dst : t -&gt; vertex
                type label = WithStrategy(Strategy.Concrete).G.E.label
                val create : vertex -&gt; label -&gt; vertex -&gt; t
                val label : t -&gt; label
              end
            type edge = E.t
            val is_directed : bool
            val is_empty : t -&gt; bool
            val nb_vertex : t -&gt; int
            val nb_edges : t -&gt; int
            val out_degree : t -&gt; vertex -&gt; int
            val in_degree : t -&gt; vertex -&gt; int
            val mem_vertex : t -&gt; vertex -&gt; bool
            val mem_edge : t -&gt; vertex -&gt; vertex -&gt; bool
            val mem_edge_e : t -&gt; edge -&gt; bool
            val find_edge : t -&gt; vertex -&gt; vertex -&gt; edge
            val find_all_edges : t -&gt; vertex -&gt; vertex -&gt; edge list
            val succ : t -&gt; vertex -&gt; vertex list
            val pred : t -&gt; vertex -&gt; vertex list
            val succ_e : t -&gt; vertex -&gt; edge list
            val pred_e : t -&gt; vertex -&gt; edge list
            val iter_vertex : (vertex -&gt; unit) -&gt; t -&gt; unit
            val fold_vertex : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
            val iter_edges : (vertex -&gt; vertex -&gt; unit) -&gt; t -&gt; unit
            val fold_edges : (vertex -&gt; vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
            val iter_edges_e : (edge -&gt; unit) -&gt; t -&gt; unit
            val fold_edges_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
            val map_vertex : (vertex -&gt; vertex) -&gt; t -&gt; t
            val iter_succ : (vertex -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
            val iter_pred : (vertex -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
            val fold_succ : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
            val fold_pred : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
            val iter_succ_e : (edge -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
            val fold_succ_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
            val iter_pred_e : (edge -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
            val fold_pred_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
            val create :
              ?size:Imandra_prelude.Caml.Int.t -&gt; Imandra_prelude.unit -&gt; t
            module type LH =
              sig
                val decomp_step_hash :
                  decomp_step -&gt; Imandra_prelude.Caml.Int.t
                val indexed_state_hash :
                  indexed_state -&gt; Imandra_prelude.Caml.Int.t
                val decomp_step_label : decomp_step -&gt; Imandra_prelude.string
                val indexed_state_label :
                  indexed_state -&gt; Imandra_prelude.string
              end
            module type SIG =
              sig
                val output_graph :
                  t -&gt; Imandra_prelude.string -&gt; Imandra_prelude.unit
                val find_edges :
                  t -&gt; Imandra_prelude.Caml.Int.t -&gt; decomp_step list
                val find_vertices :
                  t -&gt; Imandra_prelude.Caml.Int.t -&gt; indexed_state list
              end
            val root : t -&gt; vertex
            module Make :
              functor (L : LH) -&gt;
                sig
                  val output_graph :
                    t -&gt; Imandra_prelude.string -&gt; Imandra_prelude.unit
                  val find_edges :
                    t -&gt; Imandra_prelude.Caml.Int.t -&gt; decomp_step list
                  val find_vertices :
                    t -&gt; Imandra_prelude.Caml.Int.t -&gt; indexed_state list
                end
          end
        type step = indexed_state * decomp_step * indexed_state
        type path = step list
        type t = path L.t * G.t
        val paths : ?v:G.vertex -&gt; G.t -&gt; path L.t
        val region_of_path : path -&gt; Imandra_tools__Idf.Decompose.t list
        val regions : path L.t -&gt; Imandra_tools__Idf.Decompose.t list L.t
        val replay_path :
          path -&gt;
          (Strategy.Concrete.state * Strategy.Concrete.event *
           Strategy.Concrete.state)
          list
        type decomp_data =
            Strategy.Concrete.event * Strategy.Concrete.node_t *
            Imandra_tools__Idf.Decompose.t
        type &#39;a prod = [ `Prod of &#39;a ]
        type consumable_step =
            (decomp_data * step * bool) *
            (Imandra_prelude.unit -&gt; consumable_step L.t prod)
        val decompose_one :
          ?g:G.t -&gt;
          ?root:Strategy.Concrete.node_t -&gt;
          ?idx:Imandra_prelude.Caml.Int.t -&gt;
          ?basis:Imandra_prelude.string list -&gt;
          ?max_asm_lookahead:Imandra_prelude.Caml.Int.t -&gt;
          ?max_ctx_simp:Imandra_prelude.Caml.Int.t -&gt;
          ?reduce_symmetry:bool -&gt;
          ?ctx_asm_simp:bool -&gt;
          ?aggressive_rec:bool -&gt;
          ?compound:bool -&gt; target -&gt; consumable_step L.t
        val node_of_consumable_step :
          consumable_step -&gt; Strategy.Concrete.node_t
        val decompose :
          ?g:G.t -&gt;
          ?root:Strategy.Concrete.node_t -&gt;
          ?idx:Imandra_prelude.Caml.Int.t -&gt;
          ?cache_convergent_paths:bool -&gt;
          ?include_partials:bool -&gt;
          ?basis:Imandra_prelude.string list -&gt;
          ?max_asm_lookahead:Imandra_prelude.Caml.Int.t -&gt;
          ?max_ctx_simp:Imandra_prelude.Caml.Int.t -&gt;
          ?reduce_symmetry:bool -&gt;
          ?ctx_asm_simp:bool -&gt;
          ?aggressive_rec:bool -&gt; ?compound:bool -&gt; target -&gt; t
      end
    module Symbolic :
      sig
        type decomp_step =
          WithStrategy(Strategy.Symbolic).decomp_step = {
          sample : Strategy.Symbolic.event;
          region : Imandra_tools__Idf.Decompose.t;
          signature : Imandra_prelude.string;
          model : Imandra_surface.Top_result.term_model;
        }
        type indexed_state =
          WithStrategy(Strategy.Symbolic).indexed_state = {
          state : Strategy.Symbolic.node_t;
          idx : Imandra_prelude.Caml.Int.t;
        }
        module G :
          sig
            type t = WithStrategy(Strategy.Symbolic).G.t
            module V :
              sig
                type t = WithStrategy(Strategy.Symbolic).G.V.t
                val compare : t -&gt; t -&gt; int
                val hash : t -&gt; int
                val equal : t -&gt; t -&gt; bool
                type label = WithStrategy(Strategy.Symbolic).G.V.label
                val create : label -&gt; t
                val label : t -&gt; label
              end
            type vertex = V.t
            module E :
              sig
                type t = WithStrategy(Strategy.Symbolic).G.E.t
                val compare : t -&gt; t -&gt; int
                type vertex = vertex
                val src : t -&gt; vertex
                val dst : t -&gt; vertex
                type label = WithStrategy(Strategy.Symbolic).G.E.label
                val create : vertex -&gt; label -&gt; vertex -&gt; t
                val label : t -&gt; label
              end
            type edge = E.t
            val is_directed : bool
            val is_empty : t -&gt; bool
            val nb_vertex : t -&gt; int
            val nb_edges : t -&gt; int
            val out_degree : t -&gt; vertex -&gt; int
            val in_degree : t -&gt; vertex -&gt; int
            val mem_vertex : t -&gt; vertex -&gt; bool
            val mem_edge : t -&gt; vertex -&gt; vertex -&gt; bool
            val mem_edge_e : t -&gt; edge -&gt; bool
            val find_edge : t -&gt; vertex -&gt; vertex -&gt; edge
            val find_all_edges : t -&gt; vertex -&gt; vertex -&gt; edge list
            val succ : t -&gt; vertex -&gt; vertex list
            val pred : t -&gt; vertex -&gt; vertex list
            val succ_e : t -&gt; vertex -&gt; edge list
            val pred_e : t -&gt; vertex -&gt; edge list
            val iter_vertex : (vertex -&gt; unit) -&gt; t -&gt; unit
            val fold_vertex : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
            val iter_edges : (vertex -&gt; vertex -&gt; unit) -&gt; t -&gt; unit
            val fold_edges : (vertex -&gt; vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
            val iter_edges_e : (edge -&gt; unit) -&gt; t -&gt; unit
            val fold_edges_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; &#39;a -&gt; &#39;a
            val map_vertex : (vertex -&gt; vertex) -&gt; t -&gt; t
            val iter_succ : (vertex -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
            val iter_pred : (vertex -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
            val fold_succ : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
            val fold_pred : (vertex -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
            val iter_succ_e : (edge -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
            val fold_succ_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
            val iter_pred_e : (edge -&gt; unit) -&gt; t -&gt; vertex -&gt; unit
            val fold_pred_e : (edge -&gt; &#39;a -&gt; &#39;a) -&gt; t -&gt; vertex -&gt; &#39;a -&gt; &#39;a
            val create :
              ?size:Imandra_prelude.Caml.Int.t -&gt; Imandra_prelude.unit -&gt; t
            module type LH =
              sig
                val decomp_step_hash :
                  decomp_step -&gt; Imandra_prelude.Caml.Int.t
                val indexed_state_hash :
                  indexed_state -&gt; Imandra_prelude.Caml.Int.t
                val decomp_step_label : decomp_step -&gt; Imandra_prelude.string
                val indexed_state_label :
                  indexed_state -&gt; Imandra_prelude.string
              end
            module type SIG =
              sig
                val output_graph :
                  t -&gt; Imandra_prelude.string -&gt; Imandra_prelude.unit
                val find_edges :
                  t -&gt; Imandra_prelude.Caml.Int.t -&gt; decomp_step list
                val find_vertices :
                  t -&gt; Imandra_prelude.Caml.Int.t -&gt; indexed_state list
              end
            val root : t -&gt; vertex
            module Make :
              functor (L : LH) -&gt;
                sig
                  val output_graph :
                    t -&gt; Imandra_prelude.string -&gt; Imandra_prelude.unit
                  val find_edges :
                    t -&gt; Imandra_prelude.Caml.Int.t -&gt; decomp_step list
                  val find_vertices :
                    t -&gt; Imandra_prelude.Caml.Int.t -&gt; indexed_state list
                end
          end
        type step = indexed_state * decomp_step * indexed_state
        type path = step list
        type t = path L.t * G.t
        val paths : ?v:G.vertex -&gt; G.t -&gt; path L.t
        val region_of_path : path -&gt; Imandra_tools__Idf.Decompose.t list
        val regions : path L.t -&gt; Imandra_tools__Idf.Decompose.t list L.t
        val replay_path :
          path -&gt;
          (Strategy.Symbolic.state * Strategy.Symbolic.event *
           Strategy.Symbolic.state)
          list
        type decomp_data =
            Strategy.Symbolic.event * Strategy.Symbolic.node_t *
            Imandra_tools__Idf.Decompose.t
        type &#39;a prod = [ `Prod of &#39;a ]
        type consumable_step =
            (decomp_data * step * bool) *
            (Imandra_prelude.unit -&gt; consumable_step L.t prod)
        val decompose_one :
          ?g:G.t -&gt;
          ?root:Strategy.Symbolic.node_t -&gt;
          ?idx:Imandra_prelude.Caml.Int.t -&gt;
          ?basis:Imandra_prelude.string list -&gt;
          ?max_asm_lookahead:Imandra_prelude.Caml.Int.t -&gt;
          ?max_ctx_simp:Imandra_prelude.Caml.Int.t -&gt;
          ?reduce_symmetry:bool -&gt;
          ?ctx_asm_simp:bool -&gt;
          ?aggressive_rec:bool -&gt;
          ?compound:bool -&gt; target -&gt; consumable_step L.t
        val node_of_consumable_step :
          consumable_step -&gt; Strategy.Symbolic.node_t
        val decompose :
          ?g:G.t -&gt;
          ?root:Strategy.Symbolic.node_t -&gt;
          ?idx:Imandra_prelude.Caml.Int.t -&gt;
          ?cache_convergent_paths:bool -&gt;
          ?include_partials:bool -&gt;
          ?basis:Imandra_prelude.string list -&gt;
          ?max_asm_lookahead:Imandra_prelude.Caml.Int.t -&gt;
          ?max_ctx_simp:Imandra_prelude.Caml.Int.t -&gt;
          ?reduce_symmetry:bool -&gt;
          ?ctx_asm_simp:bool -&gt;
          ?aggressive_rec:bool -&gt; ?compound:bool -&gt; target -&gt; t
      end
  end
val side_cond_imandra_gensym__2_2 :
  DecompositionConfig.event list -&gt; DecompositionConfig.state -&gt; int -&gt; bool =
  &lt;fun&gt;
val side_cond_imandra_gensym__2_1 :
  DecompositionConfig.event list -&gt; DecompositionConfig.state -&gt; int -&gt; bool =
  &lt;fun&gt;
val side_cond_imandra_gensym__2_0 :
  DecompositionConfig.event list -&gt; DecompositionConfig.state -&gt; int -&gt; bool =
  &lt;fun&gt;
val target_imandra_gensym__2_2 :
  DecompositionConfig.event list -&gt;
  DecompositionConfig.state -&gt; DecompositionConfig.state = &lt;fun&gt;
val target_imandra_gensym__2_1 :
  Model.message list -&gt;
  DecompositionConfig.state -&gt; DecompositionConfig.state = &lt;fun&gt;
val target_imandra_gensym__2_0 :
  DecompositionConfig.event list -&gt;
  DecompositionConfig.state -&gt; DecompositionConfig.state = &lt;fun&gt;
val paths : D.Symbolic.path D.L.t = &lt;abstr&gt;
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Something odd has happened: we've asked <code>Idf</code> to decompose our template, but nothing happened!</p>
<p>This is because <code>Idf</code> is a <em>lazy</em> framework, we need to tell it how many paths we want to produce:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-12" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[6]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">let</span> <span class="n">first_path</span> <span class="o">=</span> <span class="nn">D</span><span class="p">.</span><span class="nn">L</span><span class="p">.</span><span class="n">reify</span> <span class="mi">1</span><span class="n">i</span> <span class="n">paths</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">hd</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[6]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val imandra_gensym__3 : DecompositionConfig.event list -&gt; bool = &lt;fun&gt;
val imandra_gensym__4 :
  DecompositionConfig.event list -&gt; DecompositionConfig.state = &lt;fun&gt;
val imandra_gensym__33 : DecompositionConfig.event list -&gt; bool = &lt;fun&gt;
val imandra_gensym__34 : Model.message list -&gt; DecompositionConfig.state =
  &lt;fun&gt;
val imandra_gensym__59 : DecompositionConfig.event list -&gt; bool = &lt;fun&gt;
val imandra_gensym__60 :
  DecompositionConfig.event list -&gt; DecompositionConfig.state = &lt;fun&gt;
val first_path : D.Symbolic.path =
  [({D.Symbolic.state =
      D.Strategy.Expr ({Model.counter = 0; Model.default = 23}, []);
     idx = 0i},
    {D.Symbolic.sample = Model.Add 1337; region = &lt;abstr&gt;;
     signature = &#34;imandra_gensym__4&#34;;
     model =
      {Imandra_surface.Term.Model.tys = [];
       consts =
        [((e : DecompositionConfig.event list),
          [Model.Add 1337; Model.Add 1; Model.Reset])];
       funs = []}},
    {D.Symbolic.state =
      D.Strategy.Expr
       ({Model.counter = Destruct(Model.Add, 0, List.hd e);
         Model.default = 23},
        [List.tl (List.tl (List.tl e)) = []; (List.tl (List.tl e)) &lt;&gt; [];
         Is_a(Model.Add, List.hd (List.tl e)); (List.tl e) &lt;&gt; []; e &lt;&gt; [];
         not (List.hd e = Model.Reset); Is_a(Model.Add, List.hd e);
         Destruct(Model.Add, 0, List.hd e) &lt;= 9000]);
     idx = 1i});
   ({D.Symbolic.state =
      D.Strategy.Expr
       ({Model.counter = Destruct(Model.Add, 0, List.hd e);
         Model.default = 23},
        [List.tl (List.tl (List.tl e)) = []; (List.tl (List.tl e)) &lt;&gt; [];
         Is_a(Model.Add, List.hd (List.tl e)); (List.tl e) &lt;&gt; []; e &lt;&gt; [];
         not (List.hd e = Model.Reset); Is_a(Model.Add, List.hd e);
         Destruct(Model.Add, 0, List.hd e) &lt;= 9000]);
     idx = 1i},
    {D.Symbolic.sample = Model.Add 1; region = &lt;abstr&gt;;
     signature = &#34;imandra_gensym__34&#34;;
     model =
      {Imandra_surface.Term.Model.tys = [];
       consts =
        [((e : Model.message list),
          [Model.Add 1337; Model.Add 1; Model.Reset])];
       funs = []}},
    {D.Symbolic.state =
      D.Strategy.Expr
       ({Model.counter = 23; Model.default = 23},
        [e &lt;&gt; []; Is_a(Model.Add, List.hd e); (List.tl e) &lt;&gt; [];
         List.tl (List.tl (List.tl e)) = []; (List.tl (List.tl e)) &lt;&gt; [];
         Is_a(Model.Add, List.hd (List.tl e));
         Destruct(Model.Add, 0, List.hd e) &lt;= 9000;
         Destruct(Model.Add, 0, List.hd e) = 1337;
         not (List.hd e = Model.Reset)]);
     idx = 2i});
   ({D.Symbolic.state =
      D.Strategy.Expr
       ({Model.counter = 23; Model.default = 23},
        [e &lt;&gt; []; Is_a(Model.Add, List.hd e); (List.tl e) &lt;&gt; [];
         List.tl (List.tl (List.tl e)) = []; (List.tl (List.tl e)) &lt;&gt; [];
         Is_a(Model.Add, List.hd (List.tl e));
         Destruct(Model.Add, 0, List.hd e) &lt;= 9000;
         Destruct(Model.Add, 0, List.hd e) = 1337;
         not (List.hd e = Model.Reset)]);
     idx = 2i},
    {D.Symbolic.sample = Model.Reset; region = &lt;abstr&gt;;
     signature = &#34;imandra_gensym__60&#34;;
     model =
      {Imandra_surface.Term.Model.tys = [];
       consts =
        [((e : DecompositionConfig.event list),
          [Model.Add 1337; Model.Add 0; Model.Reset])];
       funs = []}},
    {D.Symbolic.state =
      D.Strategy.Expr
       ({Model.counter = 0; Model.default = 23},
        [e &lt;&gt; []; Is_a(Model.Add, List.hd e); (List.tl e) &lt;&gt; [];
         List.tl (List.tl (List.tl e)) = []; (List.tl (List.tl e)) &lt;&gt; [];
         Is_a(Model.Add, List.hd (List.tl e));
         Destruct(Model.Add, 0, List.hd e) = 1337;
         List.hd (List.tl (List.tl e)) = Model.Reset;
         Destruct(Model.Add, 0, List.hd e) &lt;= 9000;
         not (List.hd e = Model.Reset)]);
     idx = 3i})]
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div class="imandra-alternatives" id="alt-71be3796-075d-4b89-8637-f18fbf9f2b4d"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>Voronoi</a></li><li class="" data-toggle="tab"><a>Table</a></li></ul><div class="tab-content"><div class="tab-pane active"><div id="decompose-ff5e89d4-c6ad-4c4f-8aff-233f0629f9eb" class="decompose"><textarea class="display-none">{
  &quot;regions&quot;: [
    {
      &quot;constraints&quot;: [
        &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
        &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
        &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;
      ],
      &quot;region&quot;: null,
      &quot;groups&quot;: [
        {
          &quot;constraints&quot;: [
            &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
            &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
            &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
            &quot;List.hd e = Model.Reset&quot;
          ],
          &quot;region&quot;: {
            &quot;constraints&quot;: [
              &quot;List.tl (List.tl (List.tl e)) = []&quot;,
              &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;,
              &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
              &quot;e &lt;&gt; []&quot;, &quot;List.hd e = Model.Reset&quot;
            ],
            &quot;invariant&quot;: &quot;F = {Model.counter = 0; Model.default = 23}&quot;
          },
          &quot;groups&quot;: [],
          &quot;label&quot;: &quot;R[1.1.1.1.1.2]&quot;,
          &quot;weight&quot;: 1
        },
        {
          &quot;constraints&quot;: [
            &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
            &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
            &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
            &quot;Is_a(Model.Add, List.hd e)&quot;, &quot;not (List.hd e = Model.Reset)&quot;
          ],
          &quot;region&quot;: null,
          &quot;groups&quot;: [
            {
              &quot;constraints&quot;: [
                &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
                &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
                &quot;Is_a(Model.Add, List.hd e)&quot;,
                &quot;not (List.hd e = Model.Reset)&quot;,
                &quot;not (Destruct(Model.Add, 0, List.hd e) &lt;= 9000)&quot;
              ],
              &quot;region&quot;: {
                &quot;constraints&quot;: [
                  &quot;List.tl (List.tl (List.tl e)) = []&quot;,
                  &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;,
                  &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                  &quot;(List.tl e) &lt;&gt; []&quot;, &quot;e &lt;&gt; []&quot;,
                  &quot;not (List.hd e = Model.Reset)&quot;,
                  &quot;Is_a(Model.Add, List.hd e)&quot;,
                  &quot;not (Destruct(Model.Add, 0, List.hd e) &lt;= 9000)&quot;
                ],
                &quot;invariant&quot;: &quot;F = {Model.counter = 0; Model.default = 23}&quot;
              },
              &quot;groups&quot;: [],
              &quot;label&quot;: &quot;R[1.1.1.1.1.1.1.2]&quot;,
              &quot;weight&quot;: 1
            },
            {
              &quot;constraints&quot;: [
                &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
                &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
                &quot;Is_a(Model.Add, List.hd e)&quot;,
                &quot;not (List.hd e = Model.Reset)&quot;,
                &quot;Destruct(Model.Add, 0, List.hd e) &lt;= 9000&quot;
              ],
              &quot;region&quot;: {
                &quot;constraints&quot;: [
                  &quot;List.tl (List.tl (List.tl e)) = []&quot;,
                  &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;,
                  &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                  &quot;(List.tl e) &lt;&gt; []&quot;, &quot;e &lt;&gt; []&quot;,
                  &quot;not (List.hd e = Model.Reset)&quot;,
                  &quot;Is_a(Model.Add, List.hd e)&quot;,
                  &quot;Destruct(Model.Add, 0, List.hd e) &lt;= 9000&quot;
                ],
                &quot;invariant&quot;:
                  &quot;F = {Model.counter = Destruct(Model.Add, 0, List.hd e); Model.default = 23}&quot;
              },
              &quot;groups&quot;: [],
              &quot;label&quot;: &quot;R[1.1.1.1.1.1.1.1]&quot;,
              &quot;weight&quot;: 1
            }
          ],
          &quot;label&quot;: &quot;(1.1.1.1.1.1.1)&quot;,
          &quot;weight&quot;: 2
        }
      ],
      &quot;label&quot;: &quot;(1.1.1.1.1)&quot;,
      &quot;weight&quot;: 3
    }
  ]
}</textarea><div class="decompose-foamtree"></div><div class="decompose-details"><div class="decompose-details-header">Regions details</div><div class="decompose-details-no-selection">No group selected.</div><div class="decompose-details-selection hidden"><div><span class="decompose-details-label">Direct sub-regions: </span><span class="decompose-details-direct-sub-regions-text">-</span></div><div><span class="decompose-details-label">Contained regions: </span><span class="decompose-details-contained-regions-text">-</span></div><div class="decompose-details-section-header">Constraints</div><div class="decompose-details-constraints"><pre class="decompose-details-constraint">&lt;constraint&gt;</pre></div><div class="decompose-details-invariant"><div class="decompose-details-section-header">Invariant</div><pre class="decompose-details-invariant-text">&lt;invariant&gt;</pre></div></div></div><script>
(function () {
  require(['nbextensions/nbimandra/regions'], function (regions) {
    var target = '#decompose-ff5e89d4-c6ad-4c4f-8aff-233f0629f9eb';
    regions.hydrate(target);
  });
})();
</script></div></div><div class="tab-pane"><div><div class="imandra-table" id="table-6b5f321c-b25f-4526-8c24-022c2852a110"><table><thead><tr><th>Constraints</th><th>Invariant</th></tr></thead><tr><td><ul><li><pre>List.tl (List.tl (List.tl e)) = []</pre></li><li><pre>(List.tl (List.tl e)) &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl e))</pre></li><li><pre>(List.tl e) &lt;&gt; []</pre></li><li><pre>e &lt;&gt; []</pre></li><li><pre>List.hd e = Model.Reset</pre></li></ul></td><td><pre>F = {Model.counter = 0; Model.default = 23}</pre></td></tr><tr><td><ul><li><pre>List.tl (List.tl (List.tl e)) = []</pre></li><li><pre>(List.tl (List.tl e)) &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl e))</pre></li><li><pre>(List.tl e) &lt;&gt; []</pre></li><li><pre>e &lt;&gt; []</pre></li><li><pre>not (List.hd e = Model.Reset)</pre></li><li><pre>Is_a(Model.Add, List.hd e)</pre></li><li><pre>not (Destruct(Model.Add, 0, List.hd e) &lt;= 9000)</pre></li></ul></td><td><pre>F = {Model.counter = 0; Model.default = 23}</pre></td></tr><tr><td><ul><li><pre>List.tl (List.tl (List.tl e)) = []</pre></li><li><pre>(List.tl (List.tl e)) &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl e))</pre></li><li><pre>(List.tl e) &lt;&gt; []</pre></li><li><pre>e &lt;&gt; []</pre></li><li><pre>not (List.hd e = Model.Reset)</pre></li><li><pre>Is_a(Model.Add, List.hd e)</pre></li><li><pre>Destruct(Model.Add, 0, List.hd e) &lt;= 9000</pre></li></ul></td><td><pre>F = {Model.counter = Destruct(Model.Add, 0, List.hd e); Model.default = 23}</pre></td></tr></table></div></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-71be3796-075d-4b89-8637-f18fbf9f2b4d';
  alternatives.hydrate(target);
});
</script></div>

</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div class="imandra-alternatives" id="alt-44563770-1593-4e84-9500-694568f103eb"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>Voronoi</a></li><li class="" data-toggle="tab"><a>Table</a></li></ul><div class="tab-content"><div class="tab-pane active"><div id="decompose-67f5e0ee-86ea-4b8d-b837-9b5f08744836" class="decompose"><textarea class="display-none">{
  &quot;regions&quot;: [
    {
      &quot;constraints&quot;: [
        &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
        &quot;Destruct(Model.Add, 0, List.hd e) &lt;= 9000&quot;,
        &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;, &quot;Is_a(Model.Add, List.hd e)&quot;,
        &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;
      ],
      &quot;region&quot;: null,
      &quot;groups&quot;: [
        {
          &quot;constraints&quot;: [
            &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
            &quot;Destruct(Model.Add, 0, List.hd e) &lt;= 9000&quot;,
            &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
            &quot;Is_a(Model.Add, List.hd e)&quot;,
            &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
            &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;
          ],
          &quot;region&quot;: {
            &quot;constraints&quot;: [
              &quot;e &lt;&gt; []&quot;, &quot;Is_a(Model.Add, List.hd e)&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
              &quot;List.tl (List.tl (List.tl e)) = []&quot;,
              &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;,
              &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
              &quot;Destruct(Model.Add, 0, List.hd e) &lt;= 9000&quot;,
              &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;
            ],
            &quot;invariant&quot;: &quot;F = {Model.counter = 23; Model.default = 23}&quot;
          },
          &quot;groups&quot;: [],
          &quot;label&quot;: &quot;R[1.1.1.1.1.1.1.2]&quot;,
          &quot;weight&quot;: 1
        },
        {
          &quot;constraints&quot;: [
            &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
            &quot;Destruct(Model.Add, 0, List.hd e) &lt;= 9000&quot;,
            &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
            &quot;Is_a(Model.Add, List.hd e)&quot;,
            &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
            &quot;not (Destruct(Model.Add, 0, List.hd e) = 1337)&quot;
          ],
          &quot;region&quot;: null,
          &quot;groups&quot;: [
            {
              &quot;constraints&quot;: [
                &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
                &quot;Destruct(Model.Add, 0, List.hd e) &lt;= 9000&quot;,
                &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                &quot;Is_a(Model.Add, List.hd e)&quot;,
                &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
                &quot;not (Destruct(Model.Add, 0, List.hd e) = 1337)&quot;,
                &quot;not\n((Destruct(Model.Add, 0, List.hd e)\n  + Destruct(Model.Add, 0, List.hd (List.tl e)))\n &lt;= 9000)&quot;
              ],
              &quot;region&quot;: {
                &quot;constraints&quot;: [
                  &quot;e &lt;&gt; []&quot;, &quot;Is_a(Model.Add, List.hd e)&quot;,
                  &quot;(List.tl e) &lt;&gt; []&quot;, &quot;List.tl (List.tl (List.tl e)) = []&quot;,
                  &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;,
                  &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                  &quot;Destruct(Model.Add, 0, List.hd e) &lt;= 9000&quot;,
                  &quot;not (Destruct(Model.Add, 0, List.hd e) = 1337)&quot;,
                  &quot;not\n((Destruct(Model.Add, 0, List.hd e)\n  + Destruct(Model.Add, 0, List.hd (List.tl e)))\n &lt;= 9000)&quot;
                ],
                &quot;invariant&quot;: &quot;F = {Model.counter = 0; Model.default = 23}&quot;
              },
              &quot;groups&quot;: [],
              &quot;label&quot;: &quot;R[1.1.1.1.1.1.1.1.2]&quot;,
              &quot;weight&quot;: 1
            },
            {
              &quot;constraints&quot;: [
                &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
                &quot;Destruct(Model.Add, 0, List.hd e) &lt;= 9000&quot;,
                &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                &quot;Is_a(Model.Add, List.hd e)&quot;,
                &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
                &quot;not (Destruct(Model.Add, 0, List.hd e) = 1337)&quot;,
                &quot;(Destruct(Model.Add, 0, List.hd e)\n + Destruct(Model.Add, 0, List.hd (List.tl e)))\n&lt;= 9000&quot;
              ],
              &quot;region&quot;: {
                &quot;constraints&quot;: [
                  &quot;e &lt;&gt; []&quot;, &quot;Is_a(Model.Add, List.hd e)&quot;,
                  &quot;(List.tl e) &lt;&gt; []&quot;, &quot;List.tl (List.tl (List.tl e)) = []&quot;,
                  &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;,
                  &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                  &quot;Destruct(Model.Add, 0, List.hd e) &lt;= 9000&quot;,
                  &quot;not (Destruct(Model.Add, 0, List.hd e) = 1337)&quot;,
                  &quot;(Destruct(Model.Add, 0, List.hd e)\n + Destruct(Model.Add, 0, List.hd (List.tl e)))\n&lt;= 9000&quot;
                ],
                &quot;invariant&quot;:
                  &quot;F =\n{Model.counter =\n Destruct(Model.Add, 0, List.hd e)\n + Destruct(Model.Add, 0, List.hd (List.tl e)); Model.default = 23}&quot;
              },
              &quot;groups&quot;: [],
              &quot;label&quot;: &quot;R[1.1.1.1.1.1.1.1.1]&quot;,
              &quot;weight&quot;: 1
            }
          ],
          &quot;label&quot;: &quot;(1.1.1.1.1.1.1.1)&quot;,
          &quot;weight&quot;: 2
        }
      ],
      &quot;label&quot;: &quot;(1.1.1.1.1.1.1)&quot;,
      &quot;weight&quot;: 3
    }
  ]
}</textarea><div class="decompose-foamtree"></div><div class="decompose-details"><div class="decompose-details-header">Regions details</div><div class="decompose-details-no-selection">No group selected.</div><div class="decompose-details-selection hidden"><div><span class="decompose-details-label">Direct sub-regions: </span><span class="decompose-details-direct-sub-regions-text">-</span></div><div><span class="decompose-details-label">Contained regions: </span><span class="decompose-details-contained-regions-text">-</span></div><div class="decompose-details-section-header">Constraints</div><div class="decompose-details-constraints"><pre class="decompose-details-constraint">&lt;constraint&gt;</pre></div><div class="decompose-details-invariant"><div class="decompose-details-section-header">Invariant</div><pre class="decompose-details-invariant-text">&lt;invariant&gt;</pre></div></div></div><script>
(function () {
  require(['nbextensions/nbimandra/regions'], function (regions) {
    var target = '#decompose-67f5e0ee-86ea-4b8d-b837-9b5f08744836';
    regions.hydrate(target);
  });
})();
</script></div></div><div class="tab-pane"><div><div class="imandra-table" id="table-e7e38ead-b0a4-43f6-9eca-5b17302f5a75"><table><thead><tr><th>Constraints</th><th>Invariant</th></tr></thead><tr><td><ul><li><pre>e &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd e)</pre></li><li><pre>(List.tl e) &lt;&gt; []</pre></li><li><pre>List.tl (List.tl (List.tl e)) = []</pre></li><li><pre>(List.tl (List.tl e)) &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl e))</pre></li><li><pre>Destruct(Model.Add, 0, List.hd e) &lt;= 9000</pre></li><li><pre>not (Destruct(Model.Add, 0, List.hd e) = 1337)</pre></li><li><pre>not
((Destruct(Model.Add, 0, List.hd e)
  + Destruct(Model.Add, 0, List.hd (List.tl e)))
 &lt;= 9000)</pre></li></ul></td><td><pre>F = {Model.counter = 0; Model.default = 23}</pre></td></tr><tr><td><ul><li><pre>e &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd e)</pre></li><li><pre>(List.tl e) &lt;&gt; []</pre></li><li><pre>List.tl (List.tl (List.tl e)) = []</pre></li><li><pre>(List.tl (List.tl e)) &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl e))</pre></li><li><pre>Destruct(Model.Add, 0, List.hd e) &lt;= 9000</pre></li><li><pre>not (Destruct(Model.Add, 0, List.hd e) = 1337)</pre></li><li><pre>(Destruct(Model.Add, 0, List.hd e)
 + Destruct(Model.Add, 0, List.hd (List.tl e)))
&lt;= 9000</pre></li></ul></td><td><pre>F =
{Model.counter =
 Destruct(Model.Add, 0, List.hd e)
 + Destruct(Model.Add, 0, List.hd (List.tl e)); Model.default = 23}</pre></td></tr><tr><td><ul><li><pre>e &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd e)</pre></li><li><pre>(List.tl e) &lt;&gt; []</pre></li><li><pre>List.tl (List.tl (List.tl e)) = []</pre></li><li><pre>(List.tl (List.tl e)) &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl e))</pre></li><li><pre>Destruct(Model.Add, 0, List.hd e) &lt;= 9000</pre></li><li><pre>Destruct(Model.Add, 0, List.hd e) = 1337</pre></li></ul></td><td><pre>F = {Model.counter = 23; Model.default = 23}</pre></td></tr></table></div></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-44563770-1593-4e84-9500-694568f103eb';
  alternatives.hydrate(target);
});
</script></div>

</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div class="imandra-alternatives" id="alt-0618cbe0-82e0-4a7e-b287-fe7f56e3f64f"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>Voronoi</a></li><li class="" data-toggle="tab"><a>Table</a></li></ul><div class="tab-content"><div class="tab-pane active"><div id="decompose-01e106b0-4a9f-4043-90fc-ceb5f8050537" class="decompose"><textarea class="display-none">{
  &quot;regions&quot;: [
    {
      &quot;constraints&quot;: [
        &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
        &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
        &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;, &quot;Is_a(Model.Add, List.hd e)&quot;,
        &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;
      ],
      &quot;region&quot;: null,
      &quot;groups&quot;: [
        {
          &quot;constraints&quot;: [
            &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
            &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
            &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
            &quot;Is_a(Model.Add, List.hd e)&quot;,
            &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
            &quot;List.hd (List.tl (List.tl e)) = Model.Reset&quot;
          ],
          &quot;region&quot;: {
            &quot;constraints&quot;: [
              &quot;e &lt;&gt; []&quot;, &quot;Is_a(Model.Add, List.hd e)&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
              &quot;List.tl (List.tl (List.tl e)) = []&quot;,
              &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;,
              &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
              &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
              &quot;List.hd (List.tl (List.tl e)) = Model.Reset&quot;
            ],
            &quot;invariant&quot;: &quot;F = {Model.counter = 0; Model.default = 23}&quot;
          },
          &quot;groups&quot;: [],
          &quot;label&quot;: &quot;R[1.1.1.1.1.1.1.2]&quot;,
          &quot;weight&quot;: 1
        },
        {
          &quot;constraints&quot;: [
            &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
            &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
            &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
            &quot;Is_a(Model.Add, List.hd e)&quot;,
            &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
            &quot;not (List.hd (List.tl (List.tl e)) = Model.Reset)&quot;
          ],
          &quot;region&quot;: null,
          &quot;groups&quot;: [
            {
              &quot;constraints&quot;: [
                &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
                &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
                &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                &quot;Is_a(Model.Add, List.hd e)&quot;,
                &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
                &quot;not (List.hd (List.tl (List.tl e)) = Model.Reset)&quot;,
                &quot;Destruct(Model.Sub, 0, List.hd (List.tl (List.tl e))) &lt;= 23&quot;,
                &quot;not Is_a(Model.Add, List.hd (List.tl (List.tl e)))&quot;
              ],
              &quot;region&quot;: {
                &quot;constraints&quot;: [
                  &quot;e &lt;&gt; []&quot;, &quot;Is_a(Model.Add, List.hd e)&quot;,
                  &quot;(List.tl e) &lt;&gt; []&quot;, &quot;List.tl (List.tl (List.tl e)) = []&quot;,
                  &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;,
                  &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                  &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
                  &quot;not (List.hd (List.tl (List.tl e)) = Model.Reset)&quot;,
                  &quot;not Is_a(Model.Add, List.hd (List.tl (List.tl e)))&quot;,
                  &quot;Destruct(Model.Sub, 0, List.hd (List.tl (List.tl e))) &lt;= 23&quot;
                ],
                &quot;invariant&quot;:
                  &quot;F =\n{Model.counter =\n 23 + -1 * Destruct(Model.Sub, 0, List.hd (List.tl (List.tl e)));\n Model.default = 23}&quot;
              },
              &quot;groups&quot;: [],
              &quot;label&quot;: &quot;R[1.1.1.1.1.1.1.1.2.1]&quot;,
              &quot;weight&quot;: 1
            },
            {
              &quot;constraints&quot;: [
                &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
                &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
                &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                &quot;Is_a(Model.Add, List.hd e)&quot;,
                &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
                &quot;not (List.hd (List.tl (List.tl e)) = Model.Reset)&quot;,
                &quot;Is_a(Model.Add, List.hd (List.tl (List.tl e)))&quot;
              ],
              &quot;region&quot;: null,
              &quot;groups&quot;: [
                {
                  &quot;constraints&quot;: [
                    &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
                    &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
                    &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                    &quot;Is_a(Model.Add, List.hd e)&quot;,
                    &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
                    &quot;not (List.hd (List.tl (List.tl e)) = Model.Reset)&quot;,
                    &quot;Is_a(Model.Add, List.hd (List.tl (List.tl e)))&quot;,
                    &quot;not (Destruct(Model.Add, 0, List.hd (List.tl (List.tl e))) &lt;= 8977)&quot;
                  ],
                  &quot;region&quot;: {
                    &quot;constraints&quot;: [
                      &quot;e &lt;&gt; []&quot;, &quot;Is_a(Model.Add, List.hd e)&quot;,
                      &quot;(List.tl e) &lt;&gt; []&quot;,
                      &quot;List.tl (List.tl (List.tl e)) = []&quot;,
                      &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;,
                      &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                      &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
                      &quot;not (List.hd (List.tl (List.tl e)) = Model.Reset)&quot;,
                      &quot;Is_a(Model.Add, List.hd (List.tl (List.tl e)))&quot;,
                      &quot;not (Destruct(Model.Add, 0, List.hd (List.tl (List.tl e))) &lt;= 8977)&quot;
                    ],
                    &quot;invariant&quot;:
                      &quot;F = {Model.counter = 0; Model.default = 23}&quot;
                  },
                  &quot;groups&quot;: [],
                  &quot;label&quot;: &quot;R[1.1.1.1.1.1.1.1.1.2]&quot;,
                  &quot;weight&quot;: 1
                },
                {
                  &quot;constraints&quot;: [
                    &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;, &quot;(List.tl e) &lt;&gt; []&quot;,
                    &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
                    &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                    &quot;Is_a(Model.Add, List.hd e)&quot;,
                    &quot;List.tl (List.tl (List.tl e)) = []&quot;, &quot;e &lt;&gt; []&quot;,
                    &quot;not (List.hd (List.tl (List.tl e)) = Model.Reset)&quot;,
                    &quot;Is_a(Model.Add, List.hd (List.tl (List.tl e)))&quot;,
                    &quot;Destruct(Model.Add, 0, List.hd (List.tl (List.tl e))) &lt;= 8977&quot;
                  ],
                  &quot;region&quot;: {
                    &quot;constraints&quot;: [
                      &quot;e &lt;&gt; []&quot;, &quot;Is_a(Model.Add, List.hd e)&quot;,
                      &quot;(List.tl e) &lt;&gt; []&quot;,
                      &quot;List.tl (List.tl (List.tl e)) = []&quot;,
                      &quot;(List.tl (List.tl e)) &lt;&gt; []&quot;,
                      &quot;Is_a(Model.Add, List.hd (List.tl e))&quot;,
                      &quot;Destruct(Model.Add, 0, List.hd e) = 1337&quot;,
                      &quot;not (List.hd (List.tl (List.tl e)) = Model.Reset)&quot;,
                      &quot;Is_a(Model.Add, List.hd (List.tl (List.tl e)))&quot;,
                      &quot;Destruct(Model.Add, 0, List.hd (List.tl (List.tl e))) &lt;= 8977&quot;
                    ],
                    &quot;invariant&quot;:
                      &quot;F =\n{Model.counter = 23 + Destruct(Model.Add, 0, List.hd (List.tl (List.tl e)));\n Model.default = 23}&quot;
                  },
                  &quot;groups&quot;: [],
                  &quot;label&quot;: &quot;R[1.1.1.1.1.1.1.1.1.1]&quot;,
                  &quot;weight&quot;: 1
                }
              ],
              &quot;label&quot;: &quot;(1.1.1.1.1.1.1.1.1)&quot;,
              &quot;weight&quot;: 2
            }
          ],
          &quot;label&quot;: &quot;(1.1.1.1.1.1.1.1)&quot;,
          &quot;weight&quot;: 3
        }
      ],
      &quot;label&quot;: &quot;(1.1.1.1.1.1.1)&quot;,
      &quot;weight&quot;: 4
    }
  ]
}</textarea><div class="decompose-foamtree"></div><div class="decompose-details"><div class="decompose-details-header">Regions details</div><div class="decompose-details-no-selection">No group selected.</div><div class="decompose-details-selection hidden"><div><span class="decompose-details-label">Direct sub-regions: </span><span class="decompose-details-direct-sub-regions-text">-</span></div><div><span class="decompose-details-label">Contained regions: </span><span class="decompose-details-contained-regions-text">-</span></div><div class="decompose-details-section-header">Constraints</div><div class="decompose-details-constraints"><pre class="decompose-details-constraint">&lt;constraint&gt;</pre></div><div class="decompose-details-invariant"><div class="decompose-details-section-header">Invariant</div><pre class="decompose-details-invariant-text">&lt;invariant&gt;</pre></div></div></div><script>
(function () {
  require(['nbextensions/nbimandra/regions'], function (regions) {
    var target = '#decompose-01e106b0-4a9f-4043-90fc-ceb5f8050537';
    regions.hydrate(target);
  });
})();
</script></div></div><div class="tab-pane"><div><div class="imandra-table" id="table-e20dd0d2-ab5d-4f7b-939f-06d92de3058f"><table><thead><tr><th>Constraints</th><th>Invariant</th></tr></thead><tr><td><ul><li><pre>e &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd e)</pre></li><li><pre>(List.tl e) &lt;&gt; []</pre></li><li><pre>List.tl (List.tl (List.tl e)) = []</pre></li><li><pre>(List.tl (List.tl e)) &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl e))</pre></li><li><pre>Destruct(Model.Add, 0, List.hd e) = 1337</pre></li><li><pre>not (List.hd (List.tl (List.tl e)) = Model.Reset)</pre></li><li><pre>not Is_a(Model.Add, List.hd (List.tl (List.tl e)))</pre></li><li><pre>Destruct(Model.Sub, 0, List.hd (List.tl (List.tl e))) &lt;= 23</pre></li></ul></td><td><pre>F =
{Model.counter =
 23 + -1 * Destruct(Model.Sub, 0, List.hd (List.tl (List.tl e)));
 Model.default = 23}</pre></td></tr><tr><td><ul><li><pre>e &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd e)</pre></li><li><pre>(List.tl e) &lt;&gt; []</pre></li><li><pre>List.tl (List.tl (List.tl e)) = []</pre></li><li><pre>(List.tl (List.tl e)) &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl e))</pre></li><li><pre>Destruct(Model.Add, 0, List.hd e) = 1337</pre></li><li><pre>not (List.hd (List.tl (List.tl e)) = Model.Reset)</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl (List.tl e)))</pre></li><li><pre>not (Destruct(Model.Add, 0, List.hd (List.tl (List.tl e))) &lt;= 8977)</pre></li></ul></td><td><pre>F = {Model.counter = 0; Model.default = 23}</pre></td></tr><tr><td><ul><li><pre>e &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd e)</pre></li><li><pre>(List.tl e) &lt;&gt; []</pre></li><li><pre>List.tl (List.tl (List.tl e)) = []</pre></li><li><pre>(List.tl (List.tl e)) &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl e))</pre></li><li><pre>Destruct(Model.Add, 0, List.hd e) = 1337</pre></li><li><pre>not (List.hd (List.tl (List.tl e)) = Model.Reset)</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl (List.tl e)))</pre></li><li><pre>Destruct(Model.Add, 0, List.hd (List.tl (List.tl e))) &lt;= 8977</pre></li></ul></td><td><pre>F =
{Model.counter = 23 + Destruct(Model.Add, 0, List.hd (List.tl (List.tl e)));
 Model.default = 23}</pre></td></tr><tr><td><ul><li><pre>e &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd e)</pre></li><li><pre>(List.tl e) &lt;&gt; []</pre></li><li><pre>List.tl (List.tl (List.tl e)) = []</pre></li><li><pre>(List.tl (List.tl e)) &lt;&gt; []</pre></li><li><pre>Is_a(Model.Add, List.hd (List.tl e))</pre></li><li><pre>Destruct(Model.Add, 0, List.hd e) = 1337</pre></li><li><pre>List.hd (List.tl (List.tl e)) = Model.Reset</pre></li></ul></td><td><pre>F = {Model.counter = 0; Model.default = 23}</pre></td></tr></table></div></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-0618cbe0-82e0-4a7e-b287-fe7f56e3f64f';
  alternatives.hydrate(target);
});
</script></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This output is not very useful, but we can ask <code>Idf</code> to play out a sample execution of that path:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-14" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[7]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="nn">D</span><span class="p">.</span><span class="nn">Symbolic</span><span class="p">.</span><span class="n">replay_path</span> <span class="n">first_path</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[7]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : (D.Strategy.Symbolic.state * D.Strategy.Symbolic.event *
     D.Strategy.Symbolic.state)
    list
=
[({Model.counter = 0; default = 23}, Model.Add 1337,
  {Model.counter = 1337; default = 23});
 ({Model.counter = 1337; default = 23}, Model.Add 0,
  {Model.counter = 23; default = 23});
 ({Model.counter = 23; default = 23}, Model.Reset,
  {Model.counter = 0; default = 23})]
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Or we can ask <code>Idf</code> to let us inspect the regions for that path (each region in the list will correspond to the constraints and invariant of the model at each event in the template):</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-16" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[8]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="o">#</span><span class="n">install_printer</span> <span class="nn">Decompose</span><span class="p">.</span><span class="n">print</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">first_path_regions</span> <span class="o">=</span> <span class="nn">D</span><span class="p">.</span><span class="nn">Symbolic</span><span class="p">.</span><span class="n">region_of_path</span> <span class="n">first_path</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[8]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val first_path_regions : Imandra_tools__Idf.Decompose.t list =
  [{Imandra_tools__Idf.Decompose.reg_session = 1i; reg_id = 3i;
    reg_constraints =
     [List.tl (List.tl (List.tl e)) = []; (List.tl (List.tl e)) &lt;&gt; [];
      Is_a(Model.Add, List.hd (List.tl e)); (List.tl e) &lt;&gt; []; e &lt;&gt; [];
      not (List.hd e = Model.Reset); Is_a(Model.Add, List.hd e);
      Destruct(Model.Add, 0, List.hd e) &lt;= 9000];
    reg_invariant =
     F =
     {Model.counter = Destruct(Model.Add, 0, List.hd e); Model.default = 23}};
   {Imandra_tools__Idf.Decompose.reg_session = 2i; reg_id = 9i;
    reg_constraints =
     [e &lt;&gt; []; Is_a(Model.Add, List.hd e); (List.tl e) &lt;&gt; [];
      List.tl (List.tl (List.tl e)) = []; (List.tl (List.tl e)) &lt;&gt; [];
      Is_a(Model.Add, List.hd (List.tl e));
      Destruct(Model.Add, 0, List.hd e) &lt;= 9000;
      Destruct(Model.Add, 0, List.hd e) = 1337];
    reg_invariant = F = {Model.counter = 23; Model.default = 23}};
   {Imandra_tools__Idf.Decompose.reg_session = 3i; reg_id = 16i;
    reg_constraints =
     [e &lt;&gt; []; Is_a(Model.Add, List.hd e); (List.tl e) &lt;&gt; [];
      List.tl (List.tl (List.tl e)) = []; (List.tl (List.tl e)) &lt;&gt; [];
      Is_a(Model.Add, List.hd (List.tl e));
      Destruct(Model.Add, 0, List.hd e) = 1337;
      List.hd (List.tl (List.tl e)) = Model.Reset];
    reg_invariant = F = {Model.counter = 0; Model.default = 23}}]
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p><code>Idf</code> has many more capabilities and entry points than we've just described and we haven't even touched on its scalability properties but looking at the above regions we can spot a common problem with decompositions: the regions become very hard to read, even with quite simple models.</p>
<p>This is a good moment to introduce a second <code>imandra-tools</code> module:</p>
<h1 id="Region-Pretty-Printer-(Region_pp)">Region Pretty Printer (Region_pp)<a class="anchor-link" href="#Region-Pretty-Printer-(Region_pp)">&#182;</a></h1><p>The purpose of the <code>Region_pp</code> module is twofold: it provides a <em>default</em> drop-in pretty printer for regions, much more powerful than <code>Decompose.print</code> <em>and</em> it also provides an extensible framework for creating powerful printers with semantic and ontologic understanding of the model being decomposed.</p>
<p>Behind the scenes, the printer has phases for constraint unification, merging, normalisation and pruning, symbolic evaluation, and much more - all of it is user-extensible and customizable.</p>
<p>All it takes to start reaping the benefits is to install the default pretty printer:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-18" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[9]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="o">#</span><span class="n">install_printer</span> <span class="nn">Region_pp</span><span class="p">.</span><span class="n">print</span><span class="o">;;</span>

<span class="n">first_path_regions</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[9]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : Imandra_tools__Idf.Decompose.t list =
[---[region]---
 Constraints:
   [ (List.tl (List.tl (List.tl e))) = []
   ; (List.hd (List.tl e)) is Model.Add
   ; (List.hd e) is Model.Add
   ; (List.hd e).Model.Add_0 &lt;= 9000 ]
 Invariant:
   F = Model.{ counter = (List.hd e).Model.Add_0 ; default = 23 }
 -------------;
 ---[region]---
 Constraints:
   [ (List.hd e) is Model.Add
   ; (List.tl (List.tl (List.tl e))) = []
   ; (List.hd (List.tl e)) is Model.Add
   ; (List.hd e).Model.Add_0 = 1337 ]
 Invariant:
   F = Model.{ counter = 23 ; default = 23 }
 -------------;
 ---[region]---
 Constraints:
   [ (List.hd e) is Model.Add
   ; (List.tl (List.tl (List.tl e))) = []
   ; (List.hd (List.tl e)) is Model.Add
   ; (List.hd e).Model.Add_0 = 1337
   ; (List.hd (List.tl (List.tl e))) is Model.Reset ]
 Invariant:
   F = Model.{ counter = 0 ; default = 23 }
 -------------]
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can immediately appreciate that just under half the total constraints have been identified as redundant and eliminated.</p>
<p>Let's look at another example:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-20" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[10]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="o">#</span><span class="n">logic</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">int</span> <span class="nn">Set</span><span class="p">.</span><span class="n">t</span><span class="o">)</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span>
  <span class="k">if</span> <span class="nn">Set</span><span class="p">.</span><span class="n">subset</span> <span class="n">x</span> <span class="n">y</span> <span class="k">then</span>
    <span class="nn">Set</span><span class="p">.</span><span class="n">add</span> <span class="n">z</span> <span class="n">x</span>
  <span class="k">else</span>
    <span class="nn">Set</span><span class="p">.</span><span class="n">add</span> <span class="n">z</span> <span class="o">(</span><span class="nn">Set</span><span class="p">.</span><span class="n">empty</span><span class="o">);;</span>
    
<span class="o">#</span><span class="n">program</span><span class="o">;;</span>

<span class="k">let</span> <span class="n">rs</span> <span class="o">=</span> <span class="nn">Decompose</span><span class="p">.</span><span class="n">top</span> <span class="s2">&quot;f&quot;</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[10]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val f : int Set.t -&gt; int Set.t -&gt; int -&gt; int Set.t = &lt;fun&gt;
val rs : Imandra_reasoning.Decompose.t list =
  [---[region]---
   Constraints:
    [y = Set.union x y]
   Invariant:
    F = Map.add&#39; x z true
   -------------;
   ---[region]---
   Constraints:
    [not (y = Set.union x y)]
   Invariant:
    F = Map.add&#39; (Map.const false) z true
   -------------]
</pre>
</div>

</div>

<div class="output_area">

<div class="prompt"></div>



<div class="output_html rendered_html output_subarea ">
<div class="imandra-alternatives" id="alt-120ef7c8-40af-48b6-8c12-771a04393ad8"><ul class="nav nav-tabs"><li class="active" data-toggle="tab"><a>Voronoi</a></li><li class="" data-toggle="tab"><a>Table</a></li></ul><div class="tab-content"><div class="tab-pane active"><div id="decompose-79998d0f-7d32-4a65-ac12-ae6362dd79aa" class="decompose"><textarea class="display-none">{
  &quot;regions&quot;: [
    {
      &quot;constraints&quot;: [ &quot;y = Set.union x y&quot; ],
      &quot;region&quot;: {
        &quot;constraints&quot;: [ &quot;y = Set.union x y&quot; ],
        &quot;invariant&quot;: &quot;F = Map.add' x z true&quot;
      },
      &quot;groups&quot;: [],
      &quot;label&quot;: &quot;R[2]&quot;,
      &quot;weight&quot;: 1
    },
    {
      &quot;constraints&quot;: [ &quot;not (y = Set.union x y)&quot; ],
      &quot;region&quot;: {
        &quot;constraints&quot;: [ &quot;not (y = Set.union x y)&quot; ],
        &quot;invariant&quot;: &quot;F = Map.add' (Map.const false) z true&quot;
      },
      &quot;groups&quot;: [],
      &quot;label&quot;: &quot;R[1]&quot;,
      &quot;weight&quot;: 1
    }
  ]
}</textarea><div class="decompose-foamtree"></div><div class="decompose-details"><div class="decompose-details-header">Regions details</div><div class="decompose-details-no-selection">No group selected.</div><div class="decompose-details-selection hidden"><div><span class="decompose-details-label">Direct sub-regions: </span><span class="decompose-details-direct-sub-regions-text">-</span></div><div><span class="decompose-details-label">Contained regions: </span><span class="decompose-details-contained-regions-text">-</span></div><div class="decompose-details-section-header">Constraints</div><div class="decompose-details-constraints"><pre class="decompose-details-constraint">&lt;constraint&gt;</pre></div><div class="decompose-details-invariant"><div class="decompose-details-section-header">Invariant</div><pre class="decompose-details-invariant-text">&lt;invariant&gt;</pre></div></div></div><script>
(function () {
  require(['nbextensions/nbimandra/regions'], function (regions) {
    var target = '#decompose-79998d0f-7d32-4a65-ac12-ae6362dd79aa';
    regions.hydrate(target);
  });
})();
</script></div></div><div class="tab-pane"><div><div class="imandra-table" id="table-f510a0f3-3c81-417b-a66a-b277d6bdaf97"><table><thead><tr><th>Constraints</th><th>Invariant</th></tr></thead><tr><td><ul><li><pre>not (y = Set.union x y)</pre></li></ul></td><td><pre>F = Map.add' (Map.const false) z true</pre></td></tr><tr><td><ul><li><pre>y = Set.union x y</pre></li></ul></td><td><pre>F = Map.add' x z true</pre></td></tr></table></div></div></div></div><script>
require(['nbextensions/nbimandra/alternatives'], function (alternatives) {
  var target = '#alt-120ef7c8-40af-48b6-8c12-771a04393ad8';
  alternatives.hydrate(target);
});
</script></div>

</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>It seems like <code>Region_pp</code> could do a better job here:</p>
<ul>
<li><code>Set.subset x y</code> is printed as <code>Set.union x y = y</code> </li>
<li><code>Set.add x y</code> is printed as <code>Map.add x y true</code></li>
<li><code>Set.add z (Set.empty)</code> is printed as <code>Map.add' (Map.const false) z true</code> instead of using a more desiderable set syntax like <code>{ z }</code></li>
</ul>
<p>Let's use the extension mechanisms of <code>Region_pp</code> to achieve just that:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-22" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[11]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="k">open</span> <span class="nc">Region_pp</span>
<span class="k">open</span> <span class="nc">PPrinter</span>

<span class="k">module</span> <span class="nc">Custom</span> <span class="o">=</span> <span class="k">struct</span>

  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span>
    <span class="o">|</span> <span class="nc">Set</span> <span class="k">of</span> <span class="n">t</span> <span class="n">node_</span> <span class="kt">list</span>

  <span class="k">let</span> <span class="n">map</span> <span class="n">f</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Set</span> <span class="n">els</span> <span class="o">-&gt;</span> <span class="nc">Set</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">f</span> <span class="n">els</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">compare</span> <span class="n">one</span> <span class="n">two</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">one</span><span class="o">,</span> <span class="n">two</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Set</span> <span class="n">s_one</span><span class="o">,</span> <span class="nc">Set</span> <span class="n">s_two</span> <span class="o">-&gt;</span>
       <span class="k">if</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">s_one</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">s_two</span> <span class="o">&amp;&amp;</span>
            <span class="nn">CCList</span><span class="p">.</span><span class="n">for_all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">el</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">el</span> <span class="n">s_two</span><span class="o">)</span> <span class="n">s_one</span> <span class="k">then</span>
         <span class="nc">Equivalent</span>
       <span class="k">else</span>
         <span class="nc">UnComparable</span>
         
  <span class="k">let</span> <span class="n">print</span> <span class="n">p</span> <span class="o">~</span><span class="n">focus</span> <span class="n">out</span> <span class="o">=</span> <span class="k">function</span>
    <span class="o">|</span> <span class="nc">Set</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nn">CCFormat</span><span class="p">.</span><span class="o">(</span><span class="n">fprintf</span> <span class="n">out</span> <span class="s2">&quot;@[&lt;hv&gt;{ %a@ }@]&quot;</span> <span class="o">(</span><span class="kt">list</span> <span class="o">~</span><span class="n">sep</span><span class="o">:(</span><span class="n">return</span> <span class="s2">&quot;@ ; &quot;</span><span class="o">)</span> <span class="n">p</span><span class="o">))</span> <span class="n">s</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">PPrinter</span> <span class="o">=</span> <span class="nn">Region_pp</span><span class="p">.</span><span class="nc">PP</span><span class="o">(</span><span class="nc">Custom</span><span class="o">)</span>

<span class="k">open</span> <span class="nc">Custom</span>
<span class="k">open</span> <span class="nc">PPrinter</span>
 
<span class="k">let</span> <span class="k">rec</span> <span class="n">refine_</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Map.add&#39;&quot;</span><span class="o">,</span> <span class="o">_)</span> <span class="k">as</span> <span class="n">ks</span> <span class="k">when</span> <span class="n">is_proper_set</span> <span class="n">ks</span> <span class="o">-&gt;</span>
     <span class="nc">Custom</span> <span class="o">(</span><span class="nc">Set</span> <span class="o">(</span><span class="n">gather_keys</span> <span class="n">ks</span><span class="o">))</span>
       
  <span class="o">|</span> <span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Map.add&#39;&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">m</span><span class="o">;</span> <span class="n">k</span><span class="o">;</span> <span class="nc">Boolean</span> <span class="bp">true</span><span class="o">])</span> <span class="o">-&gt;</span> 
     <span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Set.add&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">m</span><span class="o">;</span> <span class="n">k</span><span class="o">])</span>
       
    <span class="c">(* verify (fun x y -&gt; Set.union x y = y ==&gt; Set.subset x y)  *)</span>

  <span class="o">|</span> <span class="nc">Eq</span> <span class="o">(</span><span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Set.union&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">]),</span> <span class="n">z</span><span class="o">)</span> <span class="k">when</span> <span class="nn">Comparator</span><span class="p">.</span><span class="o">(</span><span class="n">is_eq</span> <span class="o">(</span><span class="n">compare</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span> <span class="o">-&gt;</span>
     <span class="nc">Eq</span> <span class="o">(</span><span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Set.subset&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">]),</span> <span class="nc">Boolean</span> <span class="bp">true</span><span class="o">)</span>

  <span class="o">|</span> <span class="nc">Neq</span> <span class="o">(</span><span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Set.union&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">]),</span> <span class="n">z</span><span class="o">)</span> <span class="k">when</span> <span class="nn">Comparator</span><span class="p">.</span><span class="o">(</span><span class="n">is_eq</span> <span class="o">(</span><span class="n">compare</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span> <span class="o">-&gt;</span>
     <span class="nc">Eq</span> <span class="o">(</span><span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Set.subset&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">]),</span> <span class="nc">Boolean</span> <span class="bp">false</span><span class="o">)</span>

  <span class="o">|</span> <span class="nc">Eq</span> <span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Set.union&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">]))</span> <span class="k">when</span> <span class="nn">Comparator</span><span class="p">.</span><span class="o">(</span><span class="n">is_eq</span> <span class="o">(</span><span class="n">compare</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span> <span class="o">-&gt;</span>
     <span class="nc">Eq</span> <span class="o">(</span><span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Set.subset&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">]),</span> <span class="nc">Boolean</span> <span class="bp">true</span><span class="o">)</span>

  <span class="o">|</span> <span class="nc">Neq</span> <span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Set.union&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">]))</span> <span class="k">when</span> <span class="nn">Comparator</span><span class="p">.</span><span class="o">(</span><span class="n">is_eq</span> <span class="o">(</span><span class="n">compare</span> <span class="n">y</span> <span class="n">z</span><span class="o">))</span> <span class="o">-&gt;</span>
     <span class="nc">Eq</span> <span class="o">(</span><span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Set.subset&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">x</span><span class="o">;</span><span class="n">y</span><span class="o">]),</span> <span class="nc">Boolean</span> <span class="bp">false</span><span class="o">)</span>

  <span class="o">|</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>
    
<span class="ow">and</span> <span class="n">gather_keys</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Map.add&#39;&quot;</span><span class="o">,</span> <span class="o">[</span><span class="n">m</span><span class="o">;</span> <span class="n">k</span><span class="o">;</span> <span class="nc">Boolean</span> <span class="bp">true</span><span class="o">])</span> <span class="o">-&gt;</span> <span class="n">k</span><span class="o">::</span><span class="n">gather_keys</span> <span class="n">m</span>
  <span class="o">|</span> <span class="nc">Funcall</span> <span class="o">(</span><span class="s2">&quot;Map.const&quot;</span><span class="o">,</span> <span class="o">[</span><span class="nc">Boolean</span> <span class="bp">false</span><span class="o">])</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
  <span class="o">|</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">failwith</span> <span class="o">(</span><span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;Unexpected set value: %s&quot;</span> <span class="o">(</span><span class="nn">PPrinter</span><span class="p">.</span><span class="nn">Printer</span><span class="p">.</span><span class="n">to_string</span> <span class="n">x</span><span class="o">))</span>

<span class="ow">and</span> <span class="n">is_proper_set</span> <span class="n">x</span> <span class="o">=</span> 
  <span class="k">try</span> <span class="n">ignore</span><span class="o">(</span><span class="n">gather_keys</span> <span class="n">x</span><span class="o">);</span> <span class="bp">true</span> <span class="k">with</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">false</span>

<span class="k">let</span> <span class="n">refine</span> <span class="o">=</span> <span class="nn">XF</span><span class="p">.</span><span class="n">walk_fix</span> <span class="n">refine_</span>

<span class="k">let</span> <span class="n">print</span> <span class="o">=</span> <span class="nn">PPrinter</span><span class="p">.</span><span class="n">print</span> <span class="o">~</span><span class="n">refine</span> <span class="bp">()</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[11]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>module Custom :
  sig
    type t = Set of t Imandra_tools.Region_pp.node_ list
    val map :
      (t Imandra_tools.Region_pp.node_ -&gt; t Imandra_tools.Region_pp.node_) -&gt;
      t -&gt; t
    val compare : t -&gt; t -&gt; Imandra_tools.Region_pp.comparison
    val print :
      t Imandra_tools.Region_pp.node_ CCFormat.printer -&gt;
      focus:&#39;a -&gt; CCFormat.t -&gt; t -&gt; unit
  end
module PPrinter :
  sig
    type node = Custom.t Imandra_tools__Region_pp.node_
    module XF :
      sig
        val map :
          (Custom.t Imandra_tools__Region_pp.node_ -&gt;
           Custom.t Imandra_tools__Region_pp.node_) -&gt;
          Custom.t Imandra_tools__Region_pp.node_ -&gt;
          Custom.t Imandra_tools__Region_pp.node_
        val walk :
          pre:(node -&gt; Custom.t Imandra_tools__Region_pp.node_) -&gt;
          ?post:(Custom.t Imandra_tools__Region_pp.node_ -&gt;
                 Custom.t Imandra_tools__Region_pp.node_) -&gt;
          node -&gt; Custom.t Imandra_tools__Region_pp.node_
        val fix_ : ?bound:Z.t -&gt; (&#39;a -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;a -&gt; &#39;a
        val fix : ?bound:Z.t -&gt; (&#39;a -&gt; &#39;a) -&gt; &#39;a -&gt; &#39;a
        val walk_fix : (node -&gt; node) -&gt; node -&gt; node
        exception Iterated
        val iterated : Imandra_prelude.unit -&gt; &#39;a
        val iter : f:(node -&gt; &#39;a) -&gt; node -&gt; Imandra_prelude.unit
        val find : f:(node -&gt; bool) -&gt; node -&gt; bool
      end
    module VarClassifier :
      sig val classify : node -&gt; Imandra_tools__Region_pp.var_name list end
    module Printer :
      sig
        val print :
          ?focus:Imandra_tools__Region_pp.var_name -&gt;
          Imandra_prelude.unit -&gt; node CCFormat.printer
        val print_parens :
          focus:Imandra_tools__Region_pp.var_name -&gt; node CCFormat.printer
        val to_string :
          ?focus:Imandra_tools__Region_pp.var_name -&gt; node -&gt; string
      end
    module Comparator :
      sig
        val is_eq : Imandra_tools__Region_pp.comparison -&gt; bool
        val compare_all :
          Custom.t Imandra_tools__Region_pp.node_ list -&gt;
          Custom.t Imandra_tools__Region_pp.node_ list -&gt;
          Imandra_tools__Region_pp.comparison
        val compare :
          Custom.t Imandra_tools__Region_pp.node_ -&gt;
          Custom.t Imandra_tools__Region_pp.node_ -&gt;
          Imandra_tools__Region_pp.comparison
      end
    module Simplifier :
      sig
        val simp :
          &#39;a Imandra_tools__Region_pp.node_ -&gt;
          &#39;a Imandra_tools__Region_pp.node_
        val simplify : node -&gt; node
      end
    val has_symbolic_term : node -&gt; bool
    module Unifier :
      sig
        val unify_ :
          unify:(node -&gt; node -&gt; node option) -&gt; node -&gt; node -&gt; node option
        val unify_two :
          unify:(node -&gt; node -&gt; node option) -&gt; node -&gt; node -&gt; node option
        val unify :
          ?unify:(node -&gt; node -&gt; node option) -&gt; node list -&gt; node list
      end
    module Parser :
      sig
        module T = Imandra_surface.Term
        module Ty = Imandra_surface.Type
        module V = Imandra_surface.Var
        module U = Imandra_surface.Uid
        exception Discarded of T.t
        val discard : T.t -&gt; &#39;a
        val parse_binary_function :
          Imandra_prelude.string -&gt;
          T.t -&gt; T.t -&gt; &#39;a Imandra_tools__Region_pp.node_
        val parse : T.t -&gt; &#39;a Imandra_tools__Region_pp.node_
        val parse_list : T.t -&gt; T.t list
        val is_proper_list : T.t -&gt; bool
        val parse_expr : T.t -&gt; &#39;a Imandra_tools__Region_pp.node_ option
      end
    val pp :
      ?unify:(node -&gt; node -&gt; node option) -&gt;
      ?refine:(node -&gt; node) -&gt; ?focus:&#39;a -&gt; Parser.T.t CCList.t -&gt; node list
    val print :
      ?unify:(node -&gt; node -&gt; node option) -&gt;
      ?refine:(node -&gt; node) -&gt;
      Imandra_prelude.unit -&gt;
      Format.formatter -&gt; Imandra_surface.Top_result.decompose_region -&gt; unit
    val to_string :
      ?unify:(node -&gt; node -&gt; node option) -&gt;
      ?refine:(node -&gt; node) -&gt;
      Imandra_surface.Top_result.decompose_region -&gt; string
  end
val refine_ :
  Custom.t Imandra_tools.Region_pp.node_ -&gt;
  Custom.t Imandra_tools.Region_pp.node_ = &lt;fun&gt;
val gather_keys :
  Custom.t Imandra_tools.Region_pp.node_ -&gt;
  Custom.t Imandra_tools.Region_pp.node_ list = &lt;fun&gt;
val is_proper_set : Custom.t Imandra_tools.Region_pp.node_ -&gt; bool = &lt;fun&gt;
val refine : PPrinter.node -&gt; PPrinter.node = &lt;fun&gt;
val print :
  Format.formatter -&gt; Imandra_surface.Top_result.decompose_region -&gt; unit =
  &lt;fun&gt;
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let's look at what we've done:</p>
<ul>
<li>first we've defined a <code>Custom</code> module whose signature includes the signature of <code>Region_pp.SIG</code>, defining <code>map</code>ping, <code>print</code>ing and <code>compare</code>ing functions for an abstract <code>Set</code> value</li>
<li>next we instantiate <code>Region_pp.PP</code> using this <code>Custom</code> module, creating a <code>PPrinter</code> module that is <code>Set</code>-aware</li>
<li>finally we define a <code>refine</code> function that transforms a <code>PPrinter.node</code> into custom <code>Set</code> values or converts <code>Map.</code> invocations into appropriate <code>Set.</code> ones.</li>
</ul>
<p>Let's install this printer and look at the regions again:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-24" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[12]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="o">#</span><span class="n">install_printer</span> <span class="n">print</span><span class="o">;;</span>
<span class="n">rs</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[12]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : Imandra_reasoning.Decompose.t list =
[---[region]---
 Constraints:
  [y = Set.union x y]
 Invariant:
  F = Map.add&#39; x z true
 -------------;
 ---[region]---
 Constraints:
  [not (y = Set.union x y)]
 Invariant:
  F = Map.add&#39; (Map.const false) z true
 -------------]
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Great! Exactly what we wanted to be printed.</p>
<p><code>Region_pp</code> provides more extension hooks and utilities than just the <code>PP</code> functor and <code>~refine</code>, but we'll go over that in more detail in a dedicated notebook.</p>
<p>Let's explore the last <code>imandra-tools</code> module</p>
<h1 id="Term-Synthesizer-(Term_synth)">Term Synthesizer (Term_synth)<a class="anchor-link" href="#Term-Synthesizer-(Term_synth)">&#182;</a></h1><p><code>Imandra</code>'s ability to both reify failed proofs into counter-examples and sample values from regions provides a lot of power. <code>Term_synth</code> extends this power, allowing <code>Imandra</code> to synthesize any <code>Term</code> (such as a regions' constraints or invariant) as code.</p>
<p>This, combined with <code>Imandra</code>'s decomposition facilities, allow us to generate powerful and complete regression test suites, analyse existing test suites to detect region coverage, and much more.</p>
<p>Let's see a quick example of how this works in practice:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-26" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[13]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="nn">Caml</span><span class="p">.</span><span class="nn">List</span><span class="p">.</span><span class="n">mapi</span> <span class="o">(</span><span class="k">fun</span> <span class="n">i</span> <span class="o">{</span><span class="nn">Decompose</span><span class="p">.</span><span class="n">constraints</span><span class="o">;</span> <span class="o">_}</span> <span class="o">-&gt;</span> 
  <span class="k">let</span> <span class="n">gs</span> <span class="o">=</span> <span class="s2">&quot;region_&quot;</span> <span class="o">^</span> <span class="o">(</span><span class="n">string_of_int</span> <span class="n">i</span><span class="o">)</span> <span class="k">in</span> <span class="c">(* Imandra_util.Util.gensym () *)</span>
  <span class="k">let</span> <span class="n">term</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="nn">Expr_trans</span><span class="p">.</span><span class="n">to_term</span> <span class="n">constraints</span> <span class="o">|&gt;</span> <span class="nn">Term</span><span class="p">.</span><span class="n">and_l</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">body</span> <span class="o">=</span> <span class="nn">Term_synth</span><span class="p">.</span><span class="n">synthesize_term</span> <span class="o">~</span><span class="n">default</span><span class="o">:</span><span class="s2">&quot;false&quot;</span> <span class="n">term</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">func</span> <span class="o">=</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;let %s x y = %s&quot;</span> <span class="n">gs</span> <span class="n">body</span> <span class="k">in</span>
  <span class="nn">Reflect</span><span class="p">.</span><span class="n">eval</span> <span class="n">func</span><span class="o">;</span>
  <span class="n">gs</span><span class="o">)</span>
  <span class="n">rs</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[13]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>val region_0 : &#39;a Set.t -&gt; &#39;a Set.t -&gt; bool = &lt;fun&gt;
val region_1 : &#39;a Set.t -&gt; &#39;a Set.t -&gt; bool = &lt;fun&gt;
- : String.t list = [&#34;region_0&#34;; &#34;region_1&#34;]
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The above should be quite straightforward:</p>
<ul>
<li>We extract the constraints from the region</li>
<li>We convert each constraint to a <code>Term</code>, using Imandra's <code>Expr_trans</code> facility and we conjoin them into a single <code>Term</code></li>
<li>We ask <code>Term_synth</code> to synthesize our term, using <code>false</code> as a default value (we're synthesizing a boolean function)</li>
<li>Finally we generate a string representation of a function using the synthesized term as its body, and evaluate it</li>
</ul>
<p>We can start playing with those functions immediately:</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="try-this-container">
  <a href="https://try.imandra.ai/launch/?next=/h/user-redirect/notebooks/Imandra-tools%20Introduction.ipynb%23try-cell-28" target="_blank" rel="nofollow">
    <div class="try-this">Try this!</div>
  </a>
</div>
<div class="input">
<div class="prompt input_prompt">In&nbsp;[14]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ocaml"><pre><span></span><span class="n">region_0</span> <span class="o">(</span><span class="nn">Set</span><span class="p">.</span><span class="n">of_list</span> <span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="nn">Set</span><span class="p">.</span><span class="n">empty</span><span class="o">;;</span>
<span class="n">region_0</span> <span class="nn">Set</span><span class="p">.</span><span class="n">empty</span> <span class="o">(</span><span class="nn">Set</span><span class="p">.</span><span class="n">of_list</span> <span class="o">[</span><span class="mi">1</span><span class="o">]);;</span>

<span class="n">region_1</span> <span class="nn">Set</span><span class="p">.</span><span class="n">empty</span> <span class="o">(</span><span class="nn">Set</span><span class="p">.</span><span class="n">of_list</span> <span class="o">[</span><span class="mi">1</span><span class="o">]);;</span>
<span class="n">region_1</span> <span class="o">(</span><span class="nn">Set</span><span class="p">.</span><span class="n">of_list</span> <span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="nn">Set</span><span class="p">.</span><span class="n">empty</span><span class="o">;;</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area">

<div class="prompt output_prompt">Out[14]:</div>




<div class="output_text output_subarea output_execute_result">
<pre>- : bool = false
- : bool = true
- : bool = false
- : bool = true
</pre>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Great! <code>region_0</code> is now a boolean function that checks whether or not certain values of <code>x</code> and <code>y</code> belong to the region of behaviour 0. <code>region_1</code> does the same for the region of behaviour 1.</p>
<p>This ability to generate <em>total</em> functions from <em>partial regions of behaviour</em> is immensely powerful and at the core of <code>Idf</code> and other powerful analysis tools we build.</p>
</div>
</div>
</div>
                    </div>

                    <div class="sidebar-right">
                        <div class="sidebar-right__menu">
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h1" href="#An-introduction-to-imandra-tools">An introduction to imandra-tools</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h1" href="#Iterative-Decomposition-Framework-(Idf)">Iterative Decomposition Framework (Idf)</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h1" href="#Region-Pretty-Printer-(Region_pp)">Region Pretty Printer (Region_pp)</a>
                            
                            <a class="sidebar-right__menu-item sidebar-right__menu-item--h1" href="#Term-Synthesizer-(Term_synth)">Term Synthesizer (Term_synth)</a>
                            
                        </div>
                    </div></article>
            </main>
            <footer class="Footer">
                <a class="Copyrights"href="http://imandra.ai">&#9400; 2018 - 2019 Aesthetic Integration Ltd. All rights reserved.</a>
            </footer>
        </div>
    
 


    </body>
</html>
