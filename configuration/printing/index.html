<p>Custom printers can be installed for any Imandra type. This is done using the <code class="highlighter-rouge">:install_printer</code> directive. A custom printer for a type <code class="highlighter-rouge">t</code> should have type <code class="highlighter-rouge">Format.formatter -&gt; t -&gt; unit.</code> These printers can be defined in <code class="highlighter-rouge">:program</code> mode.</p>

<h3 id="installing-a-custom-printer">Installing a custom printer”</h3>

<p>Let us start with a small example, beginning by defining a type in <code class="highlighter-rouge">:logic</code> mode.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="o">#</span> <span class="k">type</span> <span class="n">order</span> <span class="o">=</span> <span class="nc">Market</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Limit</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span><span class="p">;;</span></code></pre></figure>

<p>With the type defined, we can begin reasoning about it. For example, we may ask for a value of type <code class="highlighter-rouge">order</code> using <code class="highlighter-rouge">instance</code>:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="o">#</span> <span class="n">instance</span> <span class="n">_</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">order</span><span class="p">)</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;;</span>
<span class="nc">Instance</span><span class="o">:</span>  <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Market</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span></code></pre></figure>

<p>Notice how the value <code class="highlighter-rouge">Market 0</code> is printed as part of a record. In fact, it is bound to a module <code class="highlighter-rouge">CX</code> and can be accessed by <code class="highlighter-rouge">CX.x</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># CX.x;;
- : order = Market 0
</code></pre></div></div>

<p>Let us now define a custom type printer for <code class="highlighter-rouge">order</code> values. We’ll do this in <code class="highlighter-rouge">:program</code> mode.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :program
&gt; let string_of_order x =
  let open Printf in
  match x with
  Market n    -&gt; sprintf "M(%d)" n
  | Limit (n,p) -&gt; sprintf "L(%d,%f)" n p;;
val string_of_order : order -&gt; string = &lt;fun&gt;
&gt; let print_order fmt x =
  Format.fprintf fmt "&lt;order %s&gt;" (string_of_order x);;
val print_order : Format.formatter -&gt; order -&gt; unit = &lt;fun&gt;
</code></pre></div></div>

<p>We install it:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; :install_printer print_order\nPrinter print_order installed.
</code></pre></div></div>

<p>And now <code class="highlighter-rouge">order</code> values obtained by evaluation will be printed using it:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Market 10;;
- : order = &lt;order M(10)&gt;
</code></pre></div></div>

<p>This applies also to tuples, records and other compound types that build upon <code class="highlighter-rouge">order</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; (Market 1, Limit (1, 3.0));;
- : order * order = (&lt;order M(1)&gt;, &lt;order L(1,3.000000)&gt;)
&gt; type t = { x : order; y : order };;
type t = { x : order; y : order; }
&gt; { x = Market 1; y = Limit (10, 25.0) };;
- : t = {x = &lt;order M(1)&gt;; y = &lt;order L(10,25.000000)&gt;}
</code></pre></div></div>

<p>Of course, we can further define our own custom printers for such compound types. These custom compound type printers will be given priority if they are installed:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; let print_t fmt (x : t) = 
let qty = function
  Market n     -&gt; n
  | Limit (n, _) -&gt; n
  in Format.fprintf fmt "&lt;t:%d&gt;" (qty x.x + qty x.y);;
&gt; :install_printer print_t
Printer print_t installed.
&gt; { x = Market 1; y = Limit (10, 25.0) };;
- : t = &lt;t:11&gt;
</code></pre></div></div>

<h4 id="for-cx-bound-values">For CX-bound values</h4>

<p>However, if we perform <code class="highlighter-rouge">instance</code> or <code class="highlighter-rouge">check</code> or <code class="highlighter-rouge">verify</code> commands that construct and print (counter-)examples, the custom printers will not by default be applied:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; :logic
# instance _ (x,y : order * order) = x &lt;&gt; y;;
Instance:
  { x = Market 0;
    y = Market 1; }
</code></pre></div></div>

<p>This is because, by default, values bound to the <code class="highlighter-rouge">CX</code> module are not “obtained by evaluation.” Compare this output to the following, which is obtained by evaluation:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># (CX.x, CX.y);;
- : order * order = (&lt;order M(0)&gt;, &lt;order M(1)&gt;)
</code></pre></div></div>

<p>We can instruct Imandra to print all values bound to the <code class="highlighter-rouge">CX</code> module in this latter format, i.e., as a tuple (rather than a record) that is obtained by evaluation and thus has all custom printers applied. We do this through the <code class="highlighter-rouge">:set_print cx_custom</code> directive.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :set_print cx_custom
</code></pre></div></div>

<p>Now, the result of <code class="highlighter-rouge">instance</code> and related commands will have our custom printers applied:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># instance _ (x,y : order * order) = x &lt;&gt; y;;
Instance:
- : order * order = (&lt;order M(0)&gt;, &lt;order M(1)&gt;)
</code></pre></div></div>

<h4 id="for-dx-bound-values">For DX-bound values</h4>

<p>We can cause the same printing behaviour to occur in <code class="highlighter-rouge">dash_mode</code> by enabling the <code class="highlighter-rouge">:set_print dash_dx</code> option. See <a href="doc:dashing-vgs">Dashing VGs</a> for more on this option.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :dash_mode on
&gt; type order = Market of int | Limit of int * float;;
type order = Market of int | Limit of int * float
&gt; let string_of_order x =
  let open Printf in
    match x with
    Market n    -&gt; sprintf "M(%d)" n
    | Limit (n,p) -&gt; sprintf "L(%d,%f)" n p;;
val string_of_order : order -&gt; string = &lt;fun&gt;
&gt; let print_order fmt x =
  Format.fprintf fmt "&lt;order %s&gt;" (string_of_order x);;
val print_order : Format.formatter -&gt; order -&gt; unit = &lt;fun&gt;
&gt; :install_printer print_order
Printer print_order installed.
&gt; dash _ (x,y) =
  match x,y with
  Market _, Limit _ -&gt; false
  | _ -&gt; true;;
dash _ = &lt;dashed:29&gt;
&gt; :set_print dash_dx
&gt; dash _ (x,y) =
  match x,y with
  Market _, Limit _ -&gt; false
  | _ -&gt; true;;
dash _ = &lt;dashed:29&gt;

Counterexample (List.hd DX.xs):
- : order * order = (&lt;order M(0)&gt;, &lt;order L(61,66.821092)&gt;)
</code></pre></div></div>

<h4 id="uninstalling-printers">Uninstalling printers</h4>

<p>Custom printers may be uninstalled with the <code class="highlighter-rouge">:uninstall_printer</code> directive:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; :uninstall_printer print_order
Printer print_order uninstalled.
&gt; dash _ (x,y) = 
  match x,y with
  Market _, Limit _ -&gt; false
  | _ -&gt; true;;
dash _ = &lt;dashed:29&gt;

Counterexample (List.hd DX.xs):
- : order * order = (Market 0, Limit (61, 66.8210921032085139))
</code></pre></div></div>
<h4 id="uniform-behaviour">Uniform behaviour</h4>

<p>To recap, to obtain uniform behaviour in the (custom) printing of all (counter-)examples bound either to <code class="highlighter-rouge">CX</code> or <code class="highlighter-rouge">DX</code>, we must do the following:</p>

<ul>
  <li><code class="highlighter-rouge">:set_print cx_custom</code></li>
  <li><code class="highlighter-rouge">:set_print dash_dx</code></li>
</ul>

<p>With these options enabled, <code class="highlighter-rouge">dash</code>, <code class="highlighter-rouge">verify</code>, <code class="highlighter-rouge">instance</code> and <code class="highlighter-rouge">check</code> will all print out (counter-)examples when they’re computed, and all (counter-)examples will be printed in a format that has all custom printers applied.</p>
