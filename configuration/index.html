<!DOCTYPE html>
<html>
    <head>
	  <meta charset="utf-8">
	  <meta http-equiv="x-ua-compatible" content="ie=edge">
	  <meta name="viewport" content="width=device-width, initial-scale=1">

	  <title>Configuration</title>
	  
	  <link rel="shortcut icon" type="image/x-icon" href="/imandra-docs/favicon.ico">
	  <link rel="stylesheet" href="/imandra-docs/css/main.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather+Sans:300,300i,400,400i%7CMerriweather:300,300i,400,400i%7CRoboto+Slab:300,300i,400,400i">

	  <link rel="canonical" href="https://docs.imandra.ai//imandra-docs/configuration/">
	  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.1/jquery.min.js"></script>
	  <script type="text/javascript" src = "/imandra-docs/jekyll-resources/assets/scripts/jquery.scrollme.min.js"></script>
	  <script type="text/javascript" src = "/imandra-docs/jekyll-resources/assets/scripts/jquery.sticky.min.js"></script>
	  <script type="text/javascript">
	  	 
		$(document).ready(function(){
			$("#StickMenu").sticky({topSpacing:52});
		});

	  </script>

</head> 


    <body>
	      <div class="TopRowContainer">
	<div class="TopRow">
		<div class="TopNavLogoContainer">
			<a class="TopNavLogoLink" href="https://docs.imandra.ai/">
				<img class="TopNavLogo" src = "/imandra-docs/jekyll-resources/assets/img/imandra_doc_logo_main.svg">
			</a>
		</div>
		<nav class="TopNavContainer">
			<ul class="TopNavList">
				
				 
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink TopNavLink__Active" href="/imandra-docs/configuration/">Configuration</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/examples/">Examples</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/hacking/">Hacking</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/regionDecomposition/">Region Decomposition</a></li>
				
				
				 
				
				
				
				
				<li class="TopNavListItem"><a class="TopNavLink" href="/imandra-docs/extra/">Further functionality</a></li>
				
				
				
			</ul>
		</nav>
	</div>
</div>

<header class="TemplateHeader">
	<div class="TemplateHeaderImageContainer">
	<a href ="/imandra-docs">
		<img class="SiteSpecificImage" src="/imandra-docs/assets/img/site_specific_image_v_2.svg">
	</a>
	</div>
</header>


	      <main class="MainContentColumn">
		        <article class="ArticleContainer">
			          <!-- Sidebar -->
<div class="SideMenuContainer">
    <div id="StickMenu" class="SideMenu">
        
        
        
        
        <A href=#>Configuration</A>
        
        
        
        <A href=#printing>Printing</A>
        
        
        
        <A href=#prompts>Prompts</A>
        
        
        
    </div>
</div>
<!--MainContent-->
<div class="MainContent">
    
    
    
    <h2 id=configuration>Configuration</h2>
    
    <p>In this section, we give an overview of key Imandra configuration options.</p>

    
    
    <h2 class="internalLink-padding" id=printing>Printing</h2>
    
    <p>Custom printers can be installed for any Imandra type. This is done using the <code class="highlighter-rouge">:install_printer</code> directive. A custom printer for a type <code class="highlighter-rouge">t</code> should have type <code class="highlighter-rouge">Format.formatter -&gt; t -&gt; unit.</code> These printers can be defined in <code class="highlighter-rouge">:program</code> mode.</p>

<h3 id="installing-a-custom-printer">Installing a custom printer”</h3>

<p>Let us start with a small example, beginning by defining a type in <code class="highlighter-rouge">:logic</code> mode.</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="o">#</span> <span class="k">type</span> <span class="n">order</span> <span class="o">=</span> <span class="nc">Market</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">|</span> <span class="nc">Limit</span> <span class="k">of</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">float</span><span class="p">;;</span></code></pre></figure>

<p>With the type defined, we can begin reasoning about it. For example, we may ask for a value of type <code class="highlighter-rouge">order</code> using <code class="highlighter-rouge">instance</code>:</p>

<figure class="highlight"><pre><code class="language-ocaml" data-lang="ocaml"><span class="o">#</span> <span class="n">instance</span> <span class="n">_</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">order</span><span class="p">)</span> <span class="o">=</span> <span class="bp">true</span><span class="p">;;</span>
<span class="nc">Instance</span><span class="o">:</span>  <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Market</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span></code></pre></figure>

<p>Notice how the value <code class="highlighter-rouge">Market 0</code> is printed as part of a record. In fact, it is bound to a module <code class="highlighter-rouge">CX</code> and can be accessed by <code class="highlighter-rouge">CX.x</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># CX.x;;
- : order = Market 0
</code></pre></div></div>

<p>Let us now define a custom type printer for <code class="highlighter-rouge">order</code> values. We’ll do this in <code class="highlighter-rouge">:program</code> mode.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :program
&gt; let string_of_order x =
  let open Printf in
  match x with
  Market n    -&gt; sprintf "M(%d)" n
  | Limit (n,p) -&gt; sprintf "L(%d,%f)" n p;;
val string_of_order : order -&gt; string = &lt;fun&gt;
&gt; let print_order fmt x =
  Format.fprintf fmt "&lt;order %s&gt;" (string_of_order x);;
val print_order : Format.formatter -&gt; order -&gt; unit = &lt;fun&gt;
</code></pre></div></div>

<p>We install it:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; :install_printer print_order\nPrinter print_order installed.
</code></pre></div></div>

<p>And now <code class="highlighter-rouge">order</code> values obtained by evaluation will be printed using it:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; Market 10;;
- : order = &lt;order M(10)&gt;
</code></pre></div></div>

<p>This applies also to tuples, records and other compound types that build upon <code class="highlighter-rouge">order</code>:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; (Market 1, Limit (1, 3.0));;
- : order * order = (&lt;order M(1)&gt;, &lt;order L(1,3.000000)&gt;)
&gt; type t = { x : order; y : order };;
type t = { x : order; y : order; }
&gt; { x = Market 1; y = Limit (10, 25.0) };;
- : t = {x = &lt;order M(1)&gt;; y = &lt;order L(10,25.000000)&gt;}
</code></pre></div></div>

<p>Of course, we can further define our own custom printers for such compound types. These custom compound type printers will be given priority if they are installed:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; let print_t fmt (x : t) = 
let qty = function
  Market n     -&gt; n
  | Limit (n, _) -&gt; n
  in Format.fprintf fmt "&lt;t:%d&gt;" (qty x.x + qty x.y);;
&gt; :install_printer print_t
Printer print_t installed.
&gt; { x = Market 1; y = Limit (10, 25.0) };;
- : t = &lt;t:11&gt;
</code></pre></div></div>

<h4 id="for-cx-bound-values">For CX-bound values</h4>

<p>However, if we perform <code class="highlighter-rouge">instance</code> or <code class="highlighter-rouge">check</code> or <code class="highlighter-rouge">verify</code> commands that construct and print (counter-)examples, the custom printers will not by default be applied:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; :logic
# instance _ (x,y : order * order) = x &lt;&gt; y;;
Instance:
  { x = Market 0;
    y = Market 1; }
</code></pre></div></div>

<p>This is because, by default, values bound to the <code class="highlighter-rouge">CX</code> module are not “obtained by evaluation.” Compare this output to the following, which is obtained by evaluation:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># (CX.x, CX.y);;
- : order * order = (&lt;order M(0)&gt;, &lt;order M(1)&gt;)
</code></pre></div></div>

<p>We can instruct Imandra to print all values bound to the <code class="highlighter-rouge">CX</code> module in this latter format, i.e., as a tuple (rather than a record) that is obtained by evaluation and thus has all custom printers applied. We do this through the <code class="highlighter-rouge">:set_print cx_custom</code> directive.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :set_print cx_custom
</code></pre></div></div>

<p>Now, the result of <code class="highlighter-rouge">instance</code> and related commands will have our custom printers applied:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># instance _ (x,y : order * order) = x &lt;&gt; y;;
Instance:
- : order * order = (&lt;order M(0)&gt;, &lt;order M(1)&gt;)
</code></pre></div></div>

<h4 id="for-dx-bound-values">For DX-bound values</h4>

<p>We can cause the same printing behaviour to occur in <code class="highlighter-rouge">dash_mode</code> by enabling the <code class="highlighter-rouge">:set_print dash_dx</code> option. See <a href="doc:dashing-vgs">Dashing VGs</a> for more on this option.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># :dash_mode on
&gt; type order = Market of int | Limit of int * float;;
type order = Market of int | Limit of int * float
&gt; let string_of_order x =
  let open Printf in
    match x with
    Market n    -&gt; sprintf "M(%d)" n
    | Limit (n,p) -&gt; sprintf "L(%d,%f)" n p;;
val string_of_order : order -&gt; string = &lt;fun&gt;
&gt; let print_order fmt x =
  Format.fprintf fmt "&lt;order %s&gt;" (string_of_order x);;
val print_order : Format.formatter -&gt; order -&gt; unit = &lt;fun&gt;
&gt; :install_printer print_order
Printer print_order installed.
&gt; dash _ (x,y) =
  match x,y with
  Market _, Limit _ -&gt; false
  | _ -&gt; true;;
dash _ = &lt;dashed:29&gt;
&gt; :set_print dash_dx
&gt; dash _ (x,y) =
  match x,y with
  Market _, Limit _ -&gt; false
  | _ -&gt; true;;
dash _ = &lt;dashed:29&gt;

Counterexample (List.hd DX.xs):
- : order * order = (&lt;order M(0)&gt;, &lt;order L(61,66.821092)&gt;)
</code></pre></div></div>

<h4 id="uninstalling-printers">Uninstalling printers</h4>

<p>Custom printers may be uninstalled with the <code class="highlighter-rouge">:uninstall_printer</code> directive:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; :uninstall_printer print_order
Printer print_order uninstalled.
&gt; dash _ (x,y) = 
  match x,y with
  Market _, Limit _ -&gt; false
  | _ -&gt; true;;
dash _ = &lt;dashed:29&gt;

Counterexample (List.hd DX.xs):
- : order * order = (Market 0, Limit (61, 66.8210921032085139))
</code></pre></div></div>
<h4 id="uniform-behaviour">Uniform behaviour</h4>

<p>To recap, to obtain uniform behaviour in the (custom) printing of all (counter-)examples bound either to <code class="highlighter-rouge">CX</code> or <code class="highlighter-rouge">DX</code>, we must do the following:</p>

<ul>
  <li><code class="highlighter-rouge">:set_print cx_custom</code></li>
  <li><code class="highlighter-rouge">:set_print dash_dx</code></li>
</ul>

<p>With these options enabled, <code class="highlighter-rouge">dash</code>, <code class="highlighter-rouge">verify</code>, <code class="highlighter-rouge">instance</code> and <code class="highlighter-rouge">check</code> will all print out (counter-)examples when they’re computed, and all (counter-)examples will be printed in a format that has all custom printers applied.</p>

    
    
    <h2 class="internalLink-padding" id=prompts>Prompts</h2>
    
    <h4 id="introduction">Introduction</h4>
<p>The Imandra top-level prompt may be configured via the <code class="highlighter-rouge">Reflect</code> API.</p>

<p>By default, it is either <code class="highlighter-rouge"># </code> or <code class="highlighter-rouge">&gt; </code>, depending whether one is in <code class="highlighter-rouge">:logic</code> or <code class="highlighter-rouge">:program</code> mode.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            .__      /\ .__                           .___            
     _____  |__|    / / |__| _____ _____    ____    __| _/___________   
     \__  \ |  |   / /  |  |/     \__   \  /    \  / __ |\_  __ \__  \  
      / __ \|  |  / /   |  |  Y Y  \/ __ \|   |  \/ /_/ | |  | \// __ \_
     (____  /__| / /    |__|__|_|  (____  /___|  /\____ | |__|  (____  /
          \/     \/              \/     \/     \/      \/            \/ 
----------------------------------------------------------------------------
 Imandra Commander 0.8a94 - (c)Copyright Aesthetic Integration Ltd, 2014-17
----------------------------------------------------------------------------
# 1 + 2;;
- : int = 3
# :program
&gt; 2 + 3;;
- : int = 5
&gt; :logic
# 3 + 4;;
- : int = 7
</code></pre></div></div>

<h4 id="api">API</h4>

<p>The relevant functions are:</p>
<ul>
  <li><code class="highlighter-rouge">Reflect.Prompt.set_logic_prompt : string -&gt; unit</code></li>
  <li><code class="highlighter-rouge">Reflect.Prompt.set_program_prompt : string -&gt; unit</code></li>
</ul>

<h4 id="example">Example</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Reflect.Prompt.set_logic_prompt
&gt;&gt;&gt; BEGIN IMANDRA PROMPT (LOGIC MODE)
#
&lt;&lt;&lt; END IMANDRA PROMPT\n  \";;
- : unit = ()
&gt;&gt;&gt; BEGIN IMANDRA PROMPT (LOGIC MODE)
#
&lt;&lt;&lt; END IMANDRA PROMPT
let f x = x + 1;;
val f : int -&gt; int = &lt;fun&gt;
&gt;&gt;&gt; BEGIN IMANDRA PROMPT (LOGIC MODE)
#
&lt;&lt;&lt; END IMANDRA PROMPT
:program
&gt; Reflect.Prompt.set_program_prompt
&gt;&gt;&gt; BEGIN IMANDRA PROMPT (PROGRAM MODE)
&gt;
&lt;&lt;&lt; END IMANDRA PROMPT
";;
- : unit = ()
&gt;&gt;&gt; BEGIN IMANDRA PROMPT (PROGRAM MODE)
&gt;
&lt;&lt;&lt; END IMANDRA PROMPT
1;;
- : int = 1
&gt;&gt;&gt; BEGIN IMANDRA PROMPT (PROGRAM MODE)
&gt;
&lt;&lt;&lt; END IMANDRA PROMPT
:logic
&gt;&gt;&gt; BEGIN IMANDRA PROMPT (LOGIC MODE)
#
&lt;&lt;&lt; END IMANDRA PROMPT
instance _ x = f x = 10;;

Instance:

{ x = 9; }

&gt;&gt;&gt; BEGIN IMANDRA PROMPT (LOGIC MODE)
#
&lt;&lt;&lt; END IMANDRA PROMPT
</code></pre></div></div>

    
    
</div>
		        </article>
	      </main>
	      <footer class="Footer">
	  <a class="Copyrights"href="http://imandra.ai">&#9400; 2018 Aesthetic Integration Ltd. All rights reserved.</a>
</footer>

    </body>

</html>
